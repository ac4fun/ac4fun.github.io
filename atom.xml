<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汇芳书院</title>
  <icon>https://www.gravatar.com/avatar/cf70e0ba3a16055a1a17e5a6ffea823e</icon>
  <subtitle>专注计算机视觉、机器学习、分布式计算等领域, 兼聊投资、写作、生活</subtitle>
  <link href="http://kingsleynuaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://kingsleynuaa.github.io/"/>
  <updated>2022-06-21T14:55:58.832Z</updated>
  <id>http://kingsleynuaa.github.io/</id>
  
  <author>
    <name>Jacob Jin</name>
    <email>kingsleynuaa AT gmail DOT com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 61. 扑克牌中的顺子</title>
    <link href="http://kingsleynuaa.github.io/2022/06/21/leetcode-Straight-in-poker/"/>
    <id>http://kingsleynuaa.github.io/2022/06/21/leetcode-Straight-in-poker/</id>
    <published>2022-06-21T14:55:24.000Z</published>
    <updated>2022-06-21T14:55:58.832Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入:</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>36. 有效的数独</title>
    <link href="http://kingsleynuaa.github.io/2022/06/19/leetcode-valid-sudoku/"/>
    <id>http://kingsleynuaa.github.io/2022/06/19/leetcode-valid-sudoku/</id>
    <published>2022-06-19T11:57:36.000Z</published>
    <updated>2022-06-19T13:54:22.918Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>37. 解数独</title>
    <link href="http://kingsleynuaa.github.io/2022/06/19/leetcode-sudoku-solver/"/>
    <id>http://kingsleynuaa.github.io/2022/06/19/leetcode-sudoku-solver/</id>
    <published>2022-06-19T11:52:05.000Z</published>
    <updated>2022-06-21T14:53:16.837Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="backtracking" scheme="http://kingsleynuaa.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <link href="http://kingsleynuaa.github.io/2022/06/13/leetcode-balance-a-binary-search-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/13/leetcode-balance-a-binary-search-tree/</id>
    <published>2022-06-12T23:53:27.000Z</published>
    <updated>2022-06-19T11:44:18.094Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。&lt;/p&gt;
&lt;p&gt;如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/12/leetcode-convert-sorted-array-to-binary-search-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/12/leetcode-convert-sorted-array-to-binary-search-tree/</id>
    <published>2022-06-12T14:35:01.000Z</published>
    <updated>2022-06-12T23:51:25.049Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。&lt;/p&gt;
&lt;p&gt;高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>NC144 懂二进制</title>
    <link href="http://kingsleynuaa.github.io/2022/06/12/leetcode-the-diff-bit-number/"/>
    <id>http://kingsleynuaa.github.io/2022/06/12/leetcode-the-diff-bit-number/</id>
    <published>2022-06-12T14:31:17.000Z</published>
    <updated>2022-06-12T14:33:50.084Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;描述&lt;br&gt;世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？&lt;br&gt;示例1&lt;br&gt;输入：&lt;br&gt;3,5&lt;br&gt;返回值：&lt;br&gt;2&lt;br&gt;说明：&lt;br&gt;3的二进制为11，5的二进制为101，总共有2位不同</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="bit" scheme="http://kingsleynuaa.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>1044. 最长重复子串</title>
    <link href="http://kingsleynuaa.github.io/2022/06/10/leetcode-longest-duplicate-substring/"/>
    <id>http://kingsleynuaa.github.io/2022/06/10/leetcode-longest-duplicate-substring/</id>
    <published>2022-06-10T08:50:44.000Z</published>
    <updated>2022-06-10T08:51:45.423Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。&lt;/p&gt;
&lt;p&gt;返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 “” 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>99. 恢复二叉搜索树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/09/leetcode-recover-binary-search-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/09/leetcode-recover-binary-search-tree/</id>
    <published>2022-06-08T17:01:50.000Z</published>
    <updated>2022-06-10T08:48:04.665Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：root =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.05. 阶乘尾数</title>
    <link href="http://kingsleynuaa.github.io/2022/06/08/leetcode-factorial-zeros-lcci/"/>
    <id>http://kingsleynuaa.github.io/2022/06/08/leetcode-factorial-zeros-lcci/</id>
    <published>2022-06-08T00:42:46.000Z</published>
    <updated>2022-06-08T16:53:00.161Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;设计一个算法，算出 n 阶乘有多少个尾随零。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 3&lt;br&gt;输出: 0&lt;br&gt;解释: 3! = 6, 尾数中没有零。&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: 5&lt;br&gt;输出: 1&lt;br&gt;解释: 5! = 120, 尾数中有 1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="http://kingsleynuaa.github.io/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/"/>
    <id>http://kingsleynuaa.github.io/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/</id>
    <published>2022-06-07T13:51:51.000Z</published>
    <updated>2022-06-08T00:40:40.027Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;为了让您更好地理解问题，以下面的二叉搜索树为例：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;我们希望将这个二叉搜索</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>方阵乘法</title>
    <link href="http://kingsleynuaa.github.io/2022/06/07/leetcode-Square-matrix-multiplication/"/>
    <id>http://kingsleynuaa.github.io/2022/06/07/leetcode-Square-matrix-multiplication/</id>
    <published>2022-06-07T13:49:05.000Z</published>
    <updated>2022-06-07T13:50:29.428Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;描述&lt;br&gt;给定两个 n&lt;em&gt;n 的矩阵 A 和 B ，求 A&lt;/em&gt;B 。&lt;/p&gt;
&lt;p&gt;数据范围：1 \le n \le 1001≤n≤100，-100 \le Matrix_{i,j}\le 100−100≤Matrix&lt;br&gt;i,j&lt;br&gt;​&lt;br&gt;</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="matrix" scheme="http://kingsleynuaa.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>329. 矩阵中的最长递增路径</title>
    <link href="http://kingsleynuaa.github.io/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/"/>
    <id>http://kingsleynuaa.github.io/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/</id>
    <published>2022-06-05T13:45:30.000Z</published>
    <updated>2022-06-07T13:39:03.817Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。&lt;/p&gt;
&lt;p&gt;对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>617. 合并二叉树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/05/leetcode-merge-two-binary-trees/"/>
    <id>http://kingsleynuaa.github.io/2022/06/05/leetcode-merge-two-binary-trees/</id>
    <published>2022-06-05T12:32:24.000Z</published>
    <updated>2022-06-05T13:38:27.384Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你两棵二叉树： root1 和 root2</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>面试题 04.10. 检查子树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-check-subtree-lcci/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-check-subtree-lcci/</id>
    <published>2022-06-04T14:46:06.000Z</published>
    <updated>2022-06-05T12:48:50.483Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。&lt;/p&gt;
&lt;p&gt;如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-partition-array-by-odd-or-even/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-partition-array-by-odd-or-even/</id>
    <published>2022-06-04T14:42:43.000Z</published>
    <updated>2022-06-04T14:44:41.410Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：nums = [1,2,3,4]&lt;br&gt;输出：[1,3,2,4]&lt;br&gt;注：[3,1,2,4]</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>226. 翻转二叉树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-invert-binary-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-invert-binary-tree/</id>
    <published>2022-06-04T14:34:02.000Z</published>
    <updated>2022-06-04T14:35:05.015Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：root = [4,2,7,1,3,6,9]&lt;br&gt;输出：[4,7,2,9,6,3,1]&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：root</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-translate-digit2string/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-translate-digit2string/</id>
    <published>2022-06-04T00:49:10.000Z</published>
    <updated>2022-06-04T14:23:19.267Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>53. 最大子数组和</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-maximum-subarray/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-maximum-subarray/</id>
    <published>2022-06-04T00:31:28.000Z</published>
    <updated>2022-06-04T00:47:08.231Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;子数组 是数组中的一个连续部分。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://kingsleynuaa.github.io/2022/06/03/leetcode-maximum-product-subarray/"/>
    <id>http://kingsleynuaa.github.io/2022/06/03/leetcode-maximum-product-subarray/</id>
    <published>2022-06-03T15:50:27.000Z</published>
    <updated>2022-06-04T00:30:48.960Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
&lt;p&gt;测试用例的答案是一个 32-位 整数。&lt;/p&gt;
&lt;p&gt;子数组 是数组的连续子序列。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/31/leetcode-implement-trie-prefix-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/05/31/leetcode-implement-trie-prefix-tree/</id>
    <published>2022-05-31T14:49:53.000Z</published>
    <updated>2022-06-02T01:07:36.540Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。&lt;/p&gt;
&lt;p&gt;请你实现 Trie 类：&lt;/p&gt;
&lt;p&gt;Trie() 初始化前缀树对象。&lt;br&gt;void</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="trie" scheme="http://kingsleynuaa.github.io/tags/trie/"/>
    
  </entry>
  
</feed>
