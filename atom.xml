<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汇芳书院</title>
  <icon>https://www.gravatar.com/avatar/cf70e0ba3a16055a1a17e5a6ffea823e</icon>
  <subtitle>专注计算机视觉、机器学习、分布式计算等领域, 兼聊投资、写作、生活</subtitle>
  <link href="http://kingsleynuaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://kingsleynuaa.github.io/"/>
  <updated>2022-06-07T13:52:36.963Z</updated>
  <id>http://kingsleynuaa.github.io/</id>
  
  <author>
    <name>Jacob Jin</name>
    <email>kingsleynuaa AT gmail DOT com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="http://kingsleynuaa.github.io/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/"/>
    <id>http://kingsleynuaa.github.io/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/</id>
    <published>2022-06-07T13:51:51.000Z</published>
    <updated>2022-06-07T13:52:36.963Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;为了让您更好地理解问题，以下面的二叉搜索树为例：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;我们希望将这个二叉搜索</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>方阵乘法</title>
    <link href="http://kingsleynuaa.github.io/2022/06/07/leetcode-Square-matrix-multiplication/"/>
    <id>http://kingsleynuaa.github.io/2022/06/07/leetcode-Square-matrix-multiplication/</id>
    <published>2022-06-07T13:49:05.000Z</published>
    <updated>2022-06-07T13:50:29.428Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;描述&lt;br&gt;给定两个 n&lt;em&gt;n 的矩阵 A 和 B ，求 A&lt;/em&gt;B 。&lt;/p&gt;
&lt;p&gt;数据范围：1 \le n \le 1001≤n≤100，-100 \le Matrix_{i,j}\le 100−100≤Matrix&lt;br&gt;i,j&lt;br&gt;​&lt;br&gt;</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="matrix" scheme="http://kingsleynuaa.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>329. 矩阵中的最长递增路径</title>
    <link href="http://kingsleynuaa.github.io/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/"/>
    <id>http://kingsleynuaa.github.io/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/</id>
    <published>2022-06-05T13:45:30.000Z</published>
    <updated>2022-06-07T13:39:03.817Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。&lt;/p&gt;
&lt;p&gt;对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>617. 合并二叉树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/05/leetcode-merge-two-binary-trees/"/>
    <id>http://kingsleynuaa.github.io/2022/06/05/leetcode-merge-two-binary-trees/</id>
    <published>2022-06-05T12:32:24.000Z</published>
    <updated>2022-06-05T13:38:27.384Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你两棵二叉树： root1 和 root2</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>面试题 04.10. 检查子树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-check-subtree-lcci/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-check-subtree-lcci/</id>
    <published>2022-06-04T14:46:06.000Z</published>
    <updated>2022-06-05T12:48:50.483Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。&lt;/p&gt;
&lt;p&gt;如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-partition-array-by-odd-or-even/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-partition-array-by-odd-or-even/</id>
    <published>2022-06-04T14:42:43.000Z</published>
    <updated>2022-06-04T14:44:41.410Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：nums = [1,2,3,4]&lt;br&gt;输出：[1,3,2,4]&lt;br&gt;注：[3,1,2,4]</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>226. 翻转二叉树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-invert-binary-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-invert-binary-tree/</id>
    <published>2022-06-04T14:34:02.000Z</published>
    <updated>2022-06-04T14:35:05.015Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：root = [4,2,7,1,3,6,9]&lt;br&gt;输出：[4,7,2,9,6,3,1]&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：root</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-translate-digit2string/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-translate-digit2string/</id>
    <published>2022-06-04T00:49:10.000Z</published>
    <updated>2022-06-04T14:23:19.267Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>53. 最大子数组和</title>
    <link href="http://kingsleynuaa.github.io/2022/06/04/leetcode-maximum-subarray/"/>
    <id>http://kingsleynuaa.github.io/2022/06/04/leetcode-maximum-subarray/</id>
    <published>2022-06-04T00:31:28.000Z</published>
    <updated>2022-06-04T00:47:08.231Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;子数组 是数组中的一个连续部分。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子数组</title>
    <link href="http://kingsleynuaa.github.io/2022/06/03/leetcode-maximum-product-subarray/"/>
    <id>http://kingsleynuaa.github.io/2022/06/03/leetcode-maximum-product-subarray/</id>
    <published>2022-06-03T15:50:27.000Z</published>
    <updated>2022-06-04T00:30:48.960Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
&lt;p&gt;测试用例的答案是一个 32-位 整数。&lt;/p&gt;
&lt;p&gt;子数组 是数组的连续子序列。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/31/leetcode-implement-trie-prefix-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/05/31/leetcode-implement-trie-prefix-tree/</id>
    <published>2022-05-31T14:49:53.000Z</published>
    <updated>2022-06-02T01:07:36.540Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。&lt;/p&gt;
&lt;p&gt;请你实现 Trie 类：&lt;/p&gt;
&lt;p&gt;Trie() 初始化前缀树对象。&lt;br&gt;void</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="trie" scheme="http://kingsleynuaa.github.io/tags/trie/"/>
    
  </entry>
  
  <entry>
    <title>N皇后(系列)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/27/leetcode-n-queens/"/>
    <id>http://kingsleynuaa.github.io/2022/05/27/leetcode-n-queens/</id>
    <published>2022-05-27T01:37:09.000Z</published>
    <updated>2022-05-31T14:47:51.144Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N 皇后&quot;&gt;&lt;/a&gt;51. N 皇后&lt;/h1&gt;&lt;p&gt;n 皇后问题 研究的是如何将 n 个皇后放置在 n×n</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="backtracking" scheme="http://kingsleynuaa.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>295. 数据流的中位数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/24/leetcode-find-median-from-data-stream/"/>
    <id>http://kingsleynuaa.github.io/2022/05/24/leetcode-find-median-from-data-stream/</id>
    <published>2022-05-24T04:23:52.000Z</published>
    <updated>2022-05-27T01:36:14.064Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>10. 正则表达式匹配&amp;44. 通配符匹配</title>
    <link href="http://kingsleynuaa.github.io/2022/05/23/leetcode-regular-expression-matching/"/>
    <id>http://kingsleynuaa.github.io/2022/05/23/leetcode-regular-expression-matching/</id>
    <published>2022-05-23T11:40:45.000Z</published>
    <updated>2022-05-24T04:22:52.981Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;10. 正则表达式匹配&quot;&gt;&lt;/a&gt;10. 正则表达式匹配&lt;/h1&gt;&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>189. 轮转数组</title>
    <link href="http://kingsleynuaa.github.io/2022/05/22/leetcode-rotate-array/"/>
    <id>http://kingsleynuaa.github.io/2022/05/22/leetcode-rotate-array/</id>
    <published>2022-05-22T04:35:32.000Z</published>
    <updated>2022-05-23T11:41:12.053Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: nums = [1,2,3,4,5,6,7], k = 3&lt;br&gt;输出: [5,6,7,1,2,3,4]&lt;br&gt;解释:&lt;br&gt;向右轮转</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>1277. 统计全为 1 的正方形子矩阵</title>
    <link href="http://kingsleynuaa.github.io/2022/05/20/leetcode-count-square-submatrices-with-all-ones/"/>
    <id>http://kingsleynuaa.github.io/2022/05/20/leetcode-count-square-submatrices-with-all-ones/</id>
    <published>2022-05-20T14:01:23.000Z</published>
    <updated>2022-05-20T14:03:31.528Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：matrix =&lt;br&gt;[&lt;br&gt;  [0,1,1,1],&lt;br&gt; </summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最大正方形和最大矩形</title>
    <link href="http://kingsleynuaa.github.io/2022/05/18/leetcode-maximal-square/"/>
    <id>http://kingsleynuaa.github.io/2022/05/18/leetcode-maximal-square/</id>
    <published>2022-05-18T15:30:39.000Z</published>
    <updated>2022-05-22T04:26:29.986Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;221-最大正方形&quot;&gt;&lt;a href=&quot;#221-最大正方形&quot; class=&quot;headerlink&quot; title=&quot;221. 最大正方形&quot;&gt;&lt;/a&gt;221. 最大正方形&lt;/h1&gt;&lt;p&gt;在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/18/leetcode-number-of-1-bits/"/>
    <id>http://kingsleynuaa.github.io/2022/05/18/leetcode-number-of-1-bits/</id>
    <published>2022-05-18T15:22:11.000Z</published>
    <updated>2022-05-18T15:29:31.093Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;请注意，在某些语言（如</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="bit" scheme="http://kingsleynuaa.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="http://kingsleynuaa.github.io/2022/05/15/leetcode-reversePairs/"/>
    <id>http://kingsleynuaa.github.io/2022/05/15/leetcode-reversePairs/</id>
    <published>2022-05-15T11:14:44.000Z</published>
    <updated>2022-05-18T00:47:32.615Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [7,5,6,4]&lt;br&gt;输出: 5&lt;/p&gt;
&lt;hr&gt;
&lt;h1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>76. 最小覆盖子串</title>
    <link href="http://kingsleynuaa.github.io/2022/05/14/leetcode-minimum-window-substring/"/>
    <id>http://kingsleynuaa.github.io/2022/05/14/leetcode-minimum-window-substring/</id>
    <published>2022-05-14T08:23:54.000Z</published>
    <updated>2022-05-15T10:51:58.696Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
</feed>
