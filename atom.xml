<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汇芳书院</title>
  <icon>https://www.gravatar.com/avatar/cf70e0ba3a16055a1a17e5a6ffea823e</icon>
  <subtitle>专注计算机视觉、机器学习、分布式计算等领域, 兼聊投资、写作、生活</subtitle>
  <link href="http://kingsleynuaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://kingsleynuaa.github.io/"/>
  <updated>2022-05-20T00:28:13.856Z</updated>
  <id>http://kingsleynuaa.github.io/</id>
  
  <author>
    <name>Jacob Jin</name>
    <email>kingsleynuaa AT gmail DOT com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>221. 最大正方形</title>
    <link href="http://kingsleynuaa.github.io/2022/05/18/leetcode-maximal-square/"/>
    <id>http://kingsleynuaa.github.io/2022/05/18/leetcode-maximal-square/</id>
    <published>2022-05-18T15:30:39.000Z</published>
    <updated>2022-05-20T00:28:13.856Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：matrix =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/18/leetcode-number-of-1-bits/"/>
    <id>http://kingsleynuaa.github.io/2022/05/18/leetcode-number-of-1-bits/</id>
    <published>2022-05-18T15:22:11.000Z</published>
    <updated>2022-05-18T15:29:31.093Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;请注意，在某些语言（如</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="bit" scheme="http://kingsleynuaa.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="http://kingsleynuaa.github.io/2022/05/15/leetcode-reversePairs/"/>
    <id>http://kingsleynuaa.github.io/2022/05/15/leetcode-reversePairs/</id>
    <published>2022-05-15T11:14:44.000Z</published>
    <updated>2022-05-18T00:47:32.615Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [7,5,6,4]&lt;br&gt;输出: 5&lt;/p&gt;
&lt;hr&gt;
&lt;h1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>76. 最小覆盖子串</title>
    <link href="http://kingsleynuaa.github.io/2022/05/14/leetcode-minimum-window-substring/"/>
    <id>http://kingsleynuaa.github.io/2022/05/14/leetcode-minimum-window-substring/</id>
    <published>2022-05-14T08:23:54.000Z</published>
    <updated>2022-05-15T10:51:58.696Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>983. 最低票价</title>
    <link href="http://kingsleynuaa.github.io/2022/05/13/leetcode-minimum-cost-for-tickets/"/>
    <id>http://kingsleynuaa.github.io/2022/05/13/leetcode-minimum-cost-for-tickets/</id>
    <published>2022-05-13T00:50:56.000Z</published>
    <updated>2022-05-14T03:12:04.811Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。&lt;/p&gt;
&lt;p&gt;火车票有 三种不同的销售方式 ：&lt;/p&gt;
&lt;p&gt;一张 为期一天</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>322. 零钱兑换</title>
    <link href="http://kingsleynuaa.github.io/2022/05/12/leetcode-coin-change/"/>
    <id>http://kingsleynuaa.github.io/2022/05/12/leetcode-coin-change/</id>
    <published>2022-05-12T10:47:45.000Z</published>
    <updated>2022-05-13T00:49:23.383Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。&lt;/p&gt;
&lt;p&gt;计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>子集(系列)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/10/leetcode-subsets/"/>
    <id>http://kingsleynuaa.github.io/2022/05/10/leetcode-subsets/</id>
    <published>2022-05-10T14:35:22.000Z</published>
    <updated>2022-05-12T10:31:51.347Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;78-子集&quot;&gt;&lt;a href=&quot;#78-子集&quot; class=&quot;headerlink&quot; title=&quot;78. 子集&quot;&gt;&lt;/a&gt;78. 子集&lt;/h1&gt;&lt;p&gt;给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="backtracking" scheme="http://kingsleynuaa.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>大数操作</title>
    <link href="http://kingsleynuaa.github.io/2022/05/09/leetcode/leetcode-multiply-strings/"/>
    <id>http://kingsleynuaa.github.io/2022/05/09/leetcode/leetcode-multiply-strings/</id>
    <published>2022-05-09T14:34:32.000Z</published>
    <updated>2022-05-10T14:34:43.531Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;415-字符串相加&quot;&gt;&lt;a href=&quot;#415-字符串相加&quot; class=&quot;headerlink&quot; title=&quot;415. 字符串相加&quot;&gt;&lt;/a&gt;415. 字符串相加&lt;/h1&gt;&lt;p&gt;给定两个字符串形式的非负整数 num1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="strings" scheme="http://kingsleynuaa.github.io/tags/strings/"/>
    
  </entry>
  
  <entry>
    <title>468. 验证IP地址</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-validate-ip-address/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-validate-ip-address/</id>
    <published>2022-05-08T13:11:49.000Z</published>
    <updated>2022-05-09T14:10:53.747Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。&lt;/p&gt;
&lt;p&gt;有效的IPv4地址 是 “x1.x2.x3.x4”</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>179. 最大数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-largest-number/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-largest-number/</id>
    <published>2022-05-08T12:04:55.000Z</published>
    <updated>2022-05-08T12:58:37.858Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-diameter-of-binary-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-diameter-of-binary-tree/</id>
    <published>2022-05-08T11:35:47.000Z</published>
    <updated>2022-05-08T11:40:48.252Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 :&lt;br&gt;给定二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      1
     / \
    2  </summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫问题-圆圈中最后剩下的数字</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-yosef-problem/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-yosef-problem/</id>
    <published>2022-05-08T05:47:25.000Z</published>
    <updated>2022-05-08T05:54:04.459Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。&lt;/p&gt;
&lt;p&gt;例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="http://kingsleynuaa.github.io/2022/05/07/leetcode/leetcode-longest-consecutive-sequence/"/>
    <id>http://kingsleynuaa.github.io/2022/05/07/leetcode/leetcode-longest-consecutive-sequence/</id>
    <published>2022-05-07T00:42:40.000Z</published>
    <updated>2022-05-08T04:59:08.650Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 O(n) 的算法解决此问题。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第K大节点</title>
    <link href="http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-kthLargest-of-BST/"/>
    <id>http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-kthLargest-of-BST/</id>
    <published>2022-05-04T13:25:42.000Z</published>
    <updated>2022-05-04T13:50:13.093Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一棵二叉搜索树，请找出其中第 k 大的节点的值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: root = [3,1,4,null,2], k = 1&lt;br&gt;   3&lt;br&gt;  / &lt;br&gt; 1   4&lt;br&gt;  &lt;br&gt;   2&lt;br&gt;输出:</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>297. 二叉树的序列化与反序列化</title>
    <link href="http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-serialize-and-deserialize-binary-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-serialize-and-deserialize-binary-tree/</id>
    <published>2022-05-04T04:28:26.000Z</published>
    <updated>2022-05-04T04:42:29.756Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&lt;/p&gt;
&lt;p&gt;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 /</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>887. 鸡蛋掉落</title>
    <link href="http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-super-egg-drop/"/>
    <id>http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-super-egg-drop/</id>
    <published>2022-05-04T01:03:48.000Z</published>
    <updated>2022-05-04T03:43:31.360Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。&lt;/p&gt;
&lt;p&gt;已知存在楼层 f ，满足 0 &amp;lt;= f &amp;lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>二分查找以及多种变形</title>
    <link href="http://kingsleynuaa.github.io/2022/05/03/leetcode/leetcode-binary-search/"/>
    <id>http://kingsleynuaa.github.io/2022/05/03/leetcode/leetcode-binary-search/</id>
    <published>2022-05-03T05:17:59.000Z</published>
    <updated>2022-05-14T08:22:21.011Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;原始题&quot;&gt;&lt;a href=&quot;#原始题&quot; class=&quot;headerlink&quot; title=&quot;原始题&quot;&gt;&lt;/a&gt;原始题&lt;/h1&gt;&lt;p&gt;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="search" scheme="http://kingsleynuaa.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>9. 回文数</title>
    <link href="http://kingsleynuaa.github.io/2022/04/29/leetcode/leetcode-palindrome-number/"/>
    <id>http://kingsleynuaa.github.io/2022/04/29/leetcode/leetcode-palindrome-number/</id>
    <published>2022-04-29T05:16:00.000Z</published>
    <updated>2022-05-03T05:17:33.530Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;例如，121 是回文，而 123 不是。
 &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="http://kingsleynuaa.github.io/2022/04/27/leetcode/leetcode-longest-common-prefix/"/>
    <id>http://kingsleynuaa.github.io/2022/04/27/leetcode/leetcode-longest-common-prefix/</id>
    <published>2022-04-27T00:54:02.000Z</published>
    <updated>2022-05-03T05:15:39.982Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：strs = [“flower”,”flow”,”flight”]&lt;br&gt;输出：”fl”&lt;br&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="http://kingsleynuaa.github.io/2022/04/23/leetcode/leetcode-longest-valid-parentheses/"/>
    <id>http://kingsleynuaa.github.io/2022/04/23/leetcode/leetcode-longest-valid-parentheses/</id>
    <published>2022-04-23T00:00:59.000Z</published>
    <updated>2022-04-27T00:54:30.140Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个只包含 ‘(‘和 ‘)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：s = “(()”&lt;br&gt;输出：2&lt;br&gt;解释：最长有效括号子串是 “()”&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;输入：s =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
</feed>
