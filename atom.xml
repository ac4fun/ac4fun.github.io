<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汇芳书院</title>
  <icon>https://www.gravatar.com/avatar/cf70e0ba3a16055a1a17e5a6ffea823e</icon>
  <subtitle>专注计算机视觉、机器学习、分布式计算等领域, 兼聊投资、写作、生活</subtitle>
  <link href="http://kingsleynuaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://kingsleynuaa.github.io/"/>
  <updated>2022-07-17T12:50:48.575Z</updated>
  <id>http://kingsleynuaa.github.io/</id>
  
  <author>
    <name>Jacob Jin</name>
    <email>kingsleynuaa AT gmail DOT com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>28. 实现 strStr() 字符串匹配</title>
    <link href="http://kingsleynuaa.github.io/2022/07/11/leetcode-implement-strstr/"/>
    <id>http://kingsleynuaa.github.io/2022/07/11/leetcode-implement-strstr/</id>
    <published>2022-07-11T00:32:12.000Z</published>
    <updated>2022-07-17T12:50:48.575Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;实现 strStr() 函数。&lt;/p&gt;
&lt;p&gt;给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>165. 比较版本号</title>
    <link href="http://kingsleynuaa.github.io/2022/07/06/leetcode-compare-version-numbers/"/>
    <id>http://kingsleynuaa.github.io/2022/07/06/leetcode-compare-version-numbers/</id>
    <published>2022-07-05T23:41:20.000Z</published>
    <updated>2022-07-11T00:30:31.259Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你两个版本号 version1 和 version2 ，请你比较它们。&lt;/p&gt;
&lt;p&gt;版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="http://kingsleynuaa.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>分糖果问题(系列)</title>
    <link href="http://kingsleynuaa.github.io/2022/07/03/leetcode-distribute-candies/"/>
    <id>http://kingsleynuaa.github.io/2022/07/03/leetcode-distribute-candies/</id>
    <published>2022-07-03T13:34:22.000Z</published>
    <updated>2022-07-09T07:00:17.189Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;575-分糖果&quot;&gt;&lt;a href=&quot;#575-分糖果&quot; class=&quot;headerlink&quot; title=&quot;575. 分糖果&quot;&gt;&lt;/a&gt;575. 分糖果&lt;/h1&gt;&lt;p&gt;Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>NC125 和为K的连续最大子数组</title>
    <link href="http://kingsleynuaa.github.io/2022/07/03/leetcode-largest-subarray-length-k/"/>
    <id>http://kingsleynuaa.github.io/2022/07/03/leetcode-largest-subarray-length-k/</id>
    <published>2022-07-03T12:39:03.000Z</published>
    <updated>2022-07-03T13:03:19.072Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;NC125-和为K的连续最大子数组&quot;&gt;&lt;a href=&quot;#NC125-和为K的连续最大子数组&quot; class=&quot;headerlink&quot; title=&quot;NC125 和为K的连续最大子数组&quot;&gt;&lt;/a&gt;NC125 和为K的连续最大子数组&lt;/h1&gt;&lt;p&gt;给定一个无序数组</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>560. 和为K的连续子数组</title>
    <link href="http://kingsleynuaa.github.io/2022/07/03/leetcode-subarray-sum-equals-k/"/>
    <id>http://kingsleynuaa.github.io/2022/07/03/leetcode-subarray-sum-equals-k/</id>
    <published>2022-07-03T08:17:37.000Z</published>
    <updated>2022-07-03T12:51:01.447Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;560-和为-K-的子数组&quot;&gt;&lt;a href=&quot;#560-和为-K-的子数组&quot; class=&quot;headerlink&quot; title=&quot;560. 和为 K 的子数组&quot;&gt;&lt;/a&gt;560. 和为 K 的子数组&lt;/h1&gt;&lt;p&gt;给你一个整数数组 nums 和一个整数 k</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>222. 完全二叉树的节点个数</title>
    <link href="http://kingsleynuaa.github.io/2022/07/02/leetcode-count-complete-tree-nodes/"/>
    <id>http://kingsleynuaa.github.io/2022/07/02/leetcode-count-complete-tree-nodes/</id>
    <published>2022-07-02T13:28:03.000Z</published>
    <updated>2022-07-03T03:10:34.024Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。&lt;/p&gt;
&lt;p&gt;完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>丑数(系列)</title>
    <link href="http://kingsleynuaa.github.io/2022/06/27/leetcode-ugly-number/"/>
    <id>http://kingsleynuaa.github.io/2022/06/27/leetcode-ugly-number/</id>
    <published>2022-06-27T15:52:05.000Z</published>
    <updated>2022-07-02T13:17:58.866Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;263-丑数&quot;&gt;&lt;a href=&quot;#263-丑数&quot; class=&quot;headerlink&quot; title=&quot;263. 丑数&quot;&gt;&lt;/a&gt;263. 丑数&lt;/h1&gt;&lt;p&gt;丑数 就是只包含质因数 2、3 和 5 的正整数。&lt;/p&gt;
&lt;p&gt;给你一个整数 n ，请你判断 n</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <link href="http://kingsleynuaa.github.io/2022/06/22/leetcode-firstUniqChar/"/>
    <id>http://kingsleynuaa.github.io/2022/06/22/leetcode-firstUniqChar/</id>
    <published>2022-06-22T01:43:20.000Z</published>
    <updated>2022-06-22T13:51:28.283Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入：s = “abaccdeff”&lt;br&gt;输出：’b’&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入：s = “”&lt;br&gt;输出：’</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="hash" scheme="http://kingsleynuaa.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 61. 扑克牌中的顺子</title>
    <link href="http://kingsleynuaa.github.io/2022/06/21/leetcode-Straight-in-poker/"/>
    <id>http://kingsleynuaa.github.io/2022/06/21/leetcode-Straight-in-poker/</id>
    <published>2022-06-21T14:55:24.000Z</published>
    <updated>2022-06-22T01:34:10.381Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入:</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>36. 有效的数独</title>
    <link href="http://kingsleynuaa.github.io/2022/06/19/leetcode-valid-sudoku/"/>
    <id>http://kingsleynuaa.github.io/2022/06/19/leetcode-valid-sudoku/</id>
    <published>2022-06-19T11:57:36.000Z</published>
    <updated>2022-06-19T13:54:22.918Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>37. 解数独</title>
    <link href="http://kingsleynuaa.github.io/2022/06/19/leetcode-sudoku-solver/"/>
    <id>http://kingsleynuaa.github.io/2022/06/19/leetcode-sudoku-solver/</id>
    <published>2022-06-19T11:52:05.000Z</published>
    <updated>2022-06-21T14:53:16.837Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;数独的解法需</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="backtracking" scheme="http://kingsleynuaa.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <link href="http://kingsleynuaa.github.io/2022/06/13/leetcode-balance-a-binary-search-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/13/leetcode-balance-a-binary-search-tree/</id>
    <published>2022-06-12T23:53:27.000Z</published>
    <updated>2022-06-19T11:44:18.094Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。&lt;/p&gt;
&lt;p&gt;如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/12/leetcode-convert-sorted-array-to-binary-search-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/12/leetcode-convert-sorted-array-to-binary-search-tree/</id>
    <published>2022-06-12T14:35:01.000Z</published>
    <updated>2022-06-12T23:51:25.049Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。&lt;/p&gt;
&lt;p&gt;高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>NC144 懂二进制</title>
    <link href="http://kingsleynuaa.github.io/2022/06/12/leetcode-the-diff-bit-number/"/>
    <id>http://kingsleynuaa.github.io/2022/06/12/leetcode-the-diff-bit-number/</id>
    <published>2022-06-12T14:31:17.000Z</published>
    <updated>2022-06-12T14:33:50.084Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;描述&lt;br&gt;世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？&lt;br&gt;示例1&lt;br&gt;输入：&lt;br&gt;3,5&lt;br&gt;返回值：&lt;br&gt;2&lt;br&gt;说明：&lt;br&gt;3的二进制为11，5的二进制为101，总共有2位不同</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="bit" scheme="http://kingsleynuaa.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>1044. 最长重复子串</title>
    <link href="http://kingsleynuaa.github.io/2022/06/10/leetcode-longest-duplicate-substring/"/>
    <id>http://kingsleynuaa.github.io/2022/06/10/leetcode-longest-duplicate-substring/</id>
    <published>2022-06-10T08:50:44.000Z</published>
    <updated>2022-06-10T08:51:45.423Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。&lt;/p&gt;
&lt;p&gt;返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 “” 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>99. 恢复二叉搜索树</title>
    <link href="http://kingsleynuaa.github.io/2022/06/09/leetcode-recover-binary-search-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/06/09/leetcode-recover-binary-search-tree/</id>
    <published>2022-06-08T17:01:50.000Z</published>
    <updated>2022-06-10T08:48:04.665Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：root =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.05. 阶乘尾数</title>
    <link href="http://kingsleynuaa.github.io/2022/06/08/leetcode-factorial-zeros-lcci/"/>
    <id>http://kingsleynuaa.github.io/2022/06/08/leetcode-factorial-zeros-lcci/</id>
    <published>2022-06-08T00:42:46.000Z</published>
    <updated>2022-06-08T16:53:00.161Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;设计一个算法，算出 n 阶乘有多少个尾随零。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 3&lt;br&gt;输出: 0&lt;br&gt;解释: 3! = 6, 尾数中没有零。&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: 5&lt;br&gt;输出: 1&lt;br&gt;解释: 5! = 120, 尾数中有 1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="http://kingsleynuaa.github.io/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/"/>
    <id>http://kingsleynuaa.github.io/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/</id>
    <published>2022-06-07T13:51:51.000Z</published>
    <updated>2022-06-08T00:40:40.027Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;为了让您更好地理解问题，以下面的二叉搜索树为例：&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;我们希望将这个二叉搜索</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>方阵乘法</title>
    <link href="http://kingsleynuaa.github.io/2022/06/07/leetcode-Square-matrix-multiplication/"/>
    <id>http://kingsleynuaa.github.io/2022/06/07/leetcode-Square-matrix-multiplication/</id>
    <published>2022-06-07T13:49:05.000Z</published>
    <updated>2022-06-07T13:50:29.428Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;描述&lt;br&gt;给定两个 n&lt;em&gt;n 的矩阵 A 和 B ，求 A&lt;/em&gt;B 。&lt;/p&gt;
&lt;p&gt;数据范围：1 \le n \le 1001≤n≤100，-100 \le Matrix_{i,j}\le 100−100≤Matrix&lt;br&gt;i,j&lt;br&gt;​&lt;br&gt;</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="matrix" scheme="http://kingsleynuaa.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>329. 矩阵中的最长递增路径</title>
    <link href="http://kingsleynuaa.github.io/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/"/>
    <id>http://kingsleynuaa.github.io/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/</id>
    <published>2022-06-05T13:45:30.000Z</published>
    <updated>2022-06-07T13:39:03.817Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。&lt;/p&gt;
&lt;p&gt;对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
</feed>
