<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汇芳书院</title>
  <icon>https://www.gravatar.com/avatar/cf70e0ba3a16055a1a17e5a6ffea823e</icon>
  <subtitle>专注计算机视觉、机器学习、分布式计算等领域, 兼聊投资、写作、生活</subtitle>
  <link href="http://kingsleynuaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://kingsleynuaa.github.io/"/>
  <updated>2022-05-31T14:50:46.054Z</updated>
  <id>http://kingsleynuaa.github.io/</id>
  
  <author>
    <name>Jacob Jin</name>
    <email>kingsleynuaa AT gmail DOT com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/31/leetcode-implement-trie-prefix-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/05/31/leetcode-implement-trie-prefix-tree/</id>
    <published>2022-05-31T14:49:53.000Z</published>
    <updated>2022-05-31T14:50:46.054Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。&lt;/p&gt;
&lt;p&gt;请你实现 Trie 类：&lt;/p&gt;
&lt;p&gt;Trie() 初始化前缀树对象。&lt;br&gt;void</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="trie" scheme="http://kingsleynuaa.github.io/tags/trie/"/>
    
  </entry>
  
  <entry>
    <title>N皇后(系列)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/27/leetcode-n-queens/"/>
    <id>http://kingsleynuaa.github.io/2022/05/27/leetcode-n-queens/</id>
    <published>2022-05-27T01:37:09.000Z</published>
    <updated>2022-05-31T14:47:51.144Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; class=&quot;headerlink&quot; title=&quot;51. N 皇后&quot;&gt;&lt;/a&gt;51. N 皇后&lt;/h1&gt;&lt;p&gt;n 皇后问题 研究的是如何将 n 个皇后放置在 n×n</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="backtracking" scheme="http://kingsleynuaa.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>295. 数据流的中位数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/24/leetcode-find-median-from-data-stream/"/>
    <id>http://kingsleynuaa.github.io/2022/05/24/leetcode-find-median-from-data-stream/</id>
    <published>2022-05-24T04:23:52.000Z</published>
    <updated>2022-05-27T01:36:14.064Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;[2,3,4] 的中位数是 3&lt;/p&gt;
&lt;p&gt;[2,3] 的中位数是 (2 + 3) / 2 =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>10. 正则表达式匹配&amp;44. 通配符匹配</title>
    <link href="http://kingsleynuaa.github.io/2022/05/23/leetcode-regular-expression-matching/"/>
    <id>http://kingsleynuaa.github.io/2022/05/23/leetcode-regular-expression-matching/</id>
    <published>2022-05-23T11:40:45.000Z</published>
    <updated>2022-05-24T04:22:52.981Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;10. 正则表达式匹配&quot;&gt;&lt;/a&gt;10. 正则表达式匹配&lt;/h1&gt;&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>189. 轮转数组</title>
    <link href="http://kingsleynuaa.github.io/2022/05/22/leetcode-rotate-array/"/>
    <id>http://kingsleynuaa.github.io/2022/05/22/leetcode-rotate-array/</id>
    <published>2022-05-22T04:35:32.000Z</published>
    <updated>2022-05-23T11:41:12.053Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: nums = [1,2,3,4,5,6,7], k = 3&lt;br&gt;输出: [5,6,7,1,2,3,4]&lt;br&gt;解释:&lt;br&gt;向右轮转</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>1277. 统计全为 1 的正方形子矩阵</title>
    <link href="http://kingsleynuaa.github.io/2022/05/20/leetcode-count-square-submatrices-with-all-ones/"/>
    <id>http://kingsleynuaa.github.io/2022/05/20/leetcode-count-square-submatrices-with-all-ones/</id>
    <published>2022-05-20T14:01:23.000Z</published>
    <updated>2022-05-20T14:03:31.528Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：matrix =&lt;br&gt;[&lt;br&gt;  [0,1,1,1],&lt;br&gt; </summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最大正方形和最大矩形</title>
    <link href="http://kingsleynuaa.github.io/2022/05/18/leetcode-maximal-square/"/>
    <id>http://kingsleynuaa.github.io/2022/05/18/leetcode-maximal-square/</id>
    <published>2022-05-18T15:30:39.000Z</published>
    <updated>2022-05-22T04:26:29.986Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;221-最大正方形&quot;&gt;&lt;a href=&quot;#221-最大正方形&quot; class=&quot;headerlink&quot; title=&quot;221. 最大正方形&quot;&gt;&lt;/a&gt;221. 最大正方形&lt;/h1&gt;&lt;p&gt;在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>191. 位1的个数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/18/leetcode-number-of-1-bits/"/>
    <id>http://kingsleynuaa.github.io/2022/05/18/leetcode-number-of-1-bits/</id>
    <published>2022-05-18T15:22:11.000Z</published>
    <updated>2022-05-18T15:29:31.093Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;请注意，在某些语言（如</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="bit" scheme="http://kingsleynuaa.github.io/tags/bit/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="http://kingsleynuaa.github.io/2022/05/15/leetcode-reversePairs/"/>
    <id>http://kingsleynuaa.github.io/2022/05/15/leetcode-reversePairs/</id>
    <published>2022-05-15T11:14:44.000Z</published>
    <updated>2022-05-18T00:47:32.615Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [7,5,6,4]&lt;br&gt;输出: 5&lt;/p&gt;
&lt;hr&gt;
&lt;h1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>76. 最小覆盖子串</title>
    <link href="http://kingsleynuaa.github.io/2022/05/14/leetcode-minimum-window-substring/"/>
    <id>http://kingsleynuaa.github.io/2022/05/14/leetcode-minimum-window-substring/</id>
    <published>2022-05-14T08:23:54.000Z</published>
    <updated>2022-05-15T10:51:58.696Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>983. 最低票价</title>
    <link href="http://kingsleynuaa.github.io/2022/05/13/leetcode-minimum-cost-for-tickets/"/>
    <id>http://kingsleynuaa.github.io/2022/05/13/leetcode-minimum-cost-for-tickets/</id>
    <published>2022-05-13T00:50:56.000Z</published>
    <updated>2022-05-14T03:12:04.811Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。&lt;/p&gt;
&lt;p&gt;火车票有 三种不同的销售方式 ：&lt;/p&gt;
&lt;p&gt;一张 为期一天</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>322. 零钱兑换</title>
    <link href="http://kingsleynuaa.github.io/2022/05/12/leetcode-coin-change/"/>
    <id>http://kingsleynuaa.github.io/2022/05/12/leetcode-coin-change/</id>
    <published>2022-05-12T10:47:45.000Z</published>
    <updated>2022-05-13T00:49:23.383Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。&lt;/p&gt;
&lt;p&gt;计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="dp" scheme="http://kingsleynuaa.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>子集(系列)</title>
    <link href="http://kingsleynuaa.github.io/2022/05/10/leetcode-subsets/"/>
    <id>http://kingsleynuaa.github.io/2022/05/10/leetcode-subsets/</id>
    <published>2022-05-10T14:35:22.000Z</published>
    <updated>2022-05-12T10:31:51.347Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;78-子集&quot;&gt;&lt;a href=&quot;#78-子集&quot; class=&quot;headerlink&quot; title=&quot;78. 子集&quot;&gt;&lt;/a&gt;78. 子集&lt;/h1&gt;&lt;p&gt;给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="backtracking" scheme="http://kingsleynuaa.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>大数操作</title>
    <link href="http://kingsleynuaa.github.io/2022/05/09/leetcode/leetcode-multiply-strings/"/>
    <id>http://kingsleynuaa.github.io/2022/05/09/leetcode/leetcode-multiply-strings/</id>
    <published>2022-05-09T14:34:32.000Z</published>
    <updated>2022-05-10T14:34:43.531Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;415-字符串相加&quot;&gt;&lt;a href=&quot;#415-字符串相加&quot; class=&quot;headerlink&quot; title=&quot;415. 字符串相加&quot;&gt;&lt;/a&gt;415. 字符串相加&lt;/h1&gt;&lt;p&gt;给定两个字符串形式的非负整数 num1</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="strings" scheme="http://kingsleynuaa.github.io/tags/strings/"/>
    
  </entry>
  
  <entry>
    <title>468. 验证IP地址</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-validate-ip-address/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-validate-ip-address/</id>
    <published>2022-05-08T13:11:49.000Z</published>
    <updated>2022-05-09T14:10:53.747Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。&lt;/p&gt;
&lt;p&gt;有效的IPv4地址 是 “x1.x2.x3.x4”</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="string" scheme="http://kingsleynuaa.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>179. 最大数</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-largest-number/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-largest-number/</id>
    <published>2022-05-08T12:04:55.000Z</published>
    <updated>2022-05-08T12:58:37.858Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="sort" scheme="http://kingsleynuaa.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-diameter-of-binary-tree/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-diameter-of-binary-tree/</id>
    <published>2022-05-08T11:35:47.000Z</published>
    <updated>2022-05-08T11:40:48.252Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 :&lt;br&gt;给定二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      1
     / \
    2  </summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫问题-圆圈中最后剩下的数字</title>
    <link href="http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-yosef-problem/"/>
    <id>http://kingsleynuaa.github.io/2022/05/08/leetcode/leetcode-yosef-problem/</id>
    <published>2022-05-08T05:47:25.000Z</published>
    <updated>2022-05-08T05:54:04.459Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。&lt;/p&gt;
&lt;p&gt;例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="math" scheme="http://kingsleynuaa.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="http://kingsleynuaa.github.io/2022/05/07/leetcode/leetcode-longest-consecutive-sequence/"/>
    <id>http://kingsleynuaa.github.io/2022/05/07/leetcode/leetcode-longest-consecutive-sequence/</id>
    <published>2022-05-07T00:42:40.000Z</published>
    <updated>2022-05-08T04:59:08.650Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 O(n) 的算法解决此问题。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums =</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="array" scheme="http://kingsleynuaa.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的第K大节点</title>
    <link href="http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-kthLargest-of-BST/"/>
    <id>http://kingsleynuaa.github.io/2022/05/04/leetcode/leetcode-kthLargest-of-BST/</id>
    <published>2022-05-04T13:25:42.000Z</published>
    <updated>2022-05-04T13:50:13.093Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;给定一棵二叉搜索树，请找出其中第 k 大的节点的值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: root = [3,1,4,null,2], k = 1&lt;br&gt;   3&lt;br&gt;  / &lt;br&gt; 1   4&lt;br&gt;  &lt;br&gt;   2&lt;br&gt;输出:</summary>
        
      
    
    
    
    <category term="leetcode" scheme="http://kingsleynuaa.github.io/categories/leetcode/"/>
    
    
    <category term="binary-tree" scheme="http://kingsleynuaa.github.io/tags/binary-tree/"/>
    
  </entry>
  
</feed>
