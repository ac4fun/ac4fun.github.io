<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>家训</title>
    <url>/2022/03/08/Jin-s-family-motto/</url>
    <content><![CDATA[<ol>
<li><p>家庭成员之间需要用语言表达感情     2022.2.22</p>
</li>
<li><p>极简生活，不乱买东西, 买东西前思考家庭存货            2022.3.8 </p>
</li>
</ol>
<span id="more"></span>]]></content>
      <categories>
        <category>美好生活</category>
      </categories>
      <tags>
        <tag>家训</tag>
      </tags>
  </entry>
  <entry>
    <title>人生要事</title>
    <url>/2021/11/14/Important-things-in-life/</url>
    <content><![CDATA[<p>人生重要的事情其实不多，说到底可以分为四类:</p>
<ol>
<li>身体的不断成长</li>
<li>精神的不断更新</li>
<li>智力的不断提升</li>
<li>社会关系和情感的维系</li>
</ol>
<h1 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h1><p>身体不仅仅是灵魂的载体，更会影响到一个人的精神。身体好的人往往能更加乐观、积极的面对生活的挑战，更有勇气直面问题。<br>身体是一切的基础，没有这个基础，一切都是0。</p>
<p>想要有好的基础，有三件事需要做好：坚持锻炼、保证营养、充足休息。简单说就是，吃好喝好睡好，然后动起来。</p>
<span id="more"></span>

<h1 id="智力"><a href="#智力" class="headerlink" title="智力"></a>智力</h1><p>智力代表着对世界的认知不断的刷新，代表着处理问题的能力不断加强，代表着工作的效率不断提升。</p>
<p>提升智力也有三种方法：</p>
<p>最佳的方式是阅读，阅读可能是最低成本最便捷有效的获取信息的方式了，读书就像是在和历史上最优秀的人交流，多阅读能让我们能增加我们认识世界的思维模型，避免使用同一把”锤子”去处理世界上的钉子。<br>思维模型的增加让我们处理问题多了更丰富的手段，能让我们站在巨人的肩膀上，再攀高峰。</p>
<p>每个人都应该养成定期阅读优秀作品的习惯。可以先从每个月阅读一本书开始，到每两周阅读一本书，再到每周阅读一本书。”不读书的人跟文盲没什么两样”。</p>
<p>阅读的时候要保持一种谦虚但平等的心态，先接受，再吸收，然后批判。</p>
<p>另一种有效的方式是写作。通过不断的记录自己的经历、心得体会和对事物的认知，我们的逻辑和表达能力会逐步加强，对事物的认识也会更加清晰、明确和完整。</p>
<p>写作的一种高级形式的”教”，比如举办一个培训会，将自己理解的东西讲解给不同的人听，然后倾听反馈，能有助于自己进一步加深对事物的理解。</p>
<p>规划和组织也是磨砺心智的一种很有效的方式。通过设定目标，在大脑中规划目标的达成的关键路径，保障足够的时间，并逐步将目标落地，在目标落地的过程中，能够在关键的节点<br>不断的调整，最终克服困难达成目标。</p>
<h1 id="精神"><a href="#精神" class="headerlink" title="精神"></a>精神</h1><p>精神层面是人的本质、核心和对价值体系的坚持，是非常私人的领域。精神涉及到一个人的信念，良知，力量源泉，价值观，它能调动人体内具有<br>激励和鼓舞作用的资源，把一个人同所有人类的永恒真理紧紧联系在一起。</p>
<p>马丁路德金说”我今天要做的事情太多了，所以我要多花一个小时祷告”。</p>
<p>如果我们能够用心把我生活的方向和生命的真谛，就如同得到了一把遮风挡雨的打伞，源源不断地是我们获得新的力量。如果持之以恒，效果会非常明显。</p>
<p>一旦我们理解了生活的中心和目标，我们就可以不断反思，持之以恒，当生活中碰到困难的时候，就像海中航行的船只，虽然可能我们会暂时偏离航线，但是我们<br>能克服困难，最终回归正轨。</p>
<p>宗教领袖戴维麦凯说”每天人生最重大的战争都在灵魂深处的密室中进行”，如果你能够在这些战争中获胜，将内心的矛盾和冲突平息，就会感到一片祥和，<br>并领悟到生命的真谛。</p>
<p>精神的明确体现，一般是一个人的个人使命宣言。明确的使命宣言犹如黑暗中的灯塔，能不断指引着一个人坚定的前行。</p>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>身体、精神和智力层面的更新属于每个人非常私人但却重要的事情，需要花足够的时间去不断更新，一般建议每个人每天能花1个小时的时间用于更新。</p>
<p>关系层面涉及到情感和社会关系层面，一般不需要花费大量的时间，我们可以在与他人日常交往中完成这项工作，但是我们也需要必要的练习。</p>
<p>上述四个方面会相互影响，需要平衡更新，螺旋式的上升。</p>
<p>当前需要行动起来的有：<br>1.每天运动30min<br>2.每月阅读一本书，制定并执行阅读计划<br>3.制定跳槽能力训练计划：刷题、梳理项目<br>4.继续执行推荐系统学习计划<br>5.制定并缓慢布局财务自由计划</p>
]]></content>
      <categories>
        <category>美好生活</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>1796. 字符串中第二大的数字</title>
    <url>/2022/12/03/leetcode-second-largest-digit-in-a-string/</url>
    <content><![CDATA[<p>给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。</p>
<p>混合字符串 由小写英文字母和数字组成。</p>
<p>示例 1：</p>
<p>输入：s = “dfa12321afd”<br>输出：2<br>解释：出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。<br>示例 2：</p>
<p>输入：s = “abc1111”<br>输出：-1<br>解释：出现在 s 中的数字只包含 [1] 。没有第二大的数字。</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 500<br>s 只包含小写英文字母和（或）数字。</p>
<hr>
<p>看似简单，很久不练习，还真不一定能30min内完成。每日练枪！</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 范围比较法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest1</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">-1</span>,second = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; first)&#123;</span><br><span class="line">                    second = first;</span><br><span class="line">                    first = num;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num &lt; first &amp;&amp; num &gt; second)&#123;</span><br><span class="line">                    second = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用有序集合set</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        std::set&lt;<span class="keyword">int</span>&gt; candidate;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                candidate.<span class="built_in">emplace</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate.<span class="built_in">size</span>() &gt; <span class="number">1</span> ? *<span class="built_in">prev</span>(<span class="built_in">prev</span>(candidate.<span class="built_in">end</span>())) : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>86. 分隔链表</title>
    <url>/2022/08/31/leetcode-partition-list/</url>
    <content><![CDATA[<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p>示例 1：<br>输入：head = [1,4,3,2,5,2], x = 3<br>输出：[1,2,2,4,3,5]</p>
<p>示例 2：<br>输入：head = [2,1], x = 2<br>输出：[1,2]</p>
<hr>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2022/08/26/leetcode-Minimum-Spanning-Tree/</url>
    <content><![CDATA[<p>描述<br>一个有 n 户人家的村庄，有 m 条路相互连接着。村里现在要修路，每条路都有一个成本价格，现在请你帮忙计算下，最少需要花费多少钱，就能让这 n 户人家连接起来。</p>
<p>cost为一个二维数组，每个元素是一个长度为3的一维数组 a ，a[0]和a[1]表示村庄a[0]和村庄a[1]有一条路，修这条路的成本价格为 a[2] .</p>
<p>每户之间可能有多条道路连接，但不可能自己与自己相连</p>
<p>进阶： 时间复杂度 O(n+mlogm)， 空间复杂度 O(n)</p>
<p>示例1<br>输入：<br>3,3,[[1,3,3],[1,2,1],[2,3,1]]<br>返回值：<br>2</p>
<p>示例2<br>输入：<br>2,1,[[1,2,1]]<br>返回值：<br>1</p>
<hr>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>28. 实现 strStr() 字符串匹配</title>
    <url>/2022/07/11/leetcode-implement-strstr/</url>
    <content><![CDATA[<p>实现 strStr() 函数。</p>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p>
<p>说明：</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：haystack = “hello”, needle = “ll”<br>输出：2<br>示例 2：</p>
<p>输入：haystack = “aaaaa”, needle = “bba”<br>输出：-1
 </p>
<p>提示：</p>
<p>1 &lt;= haystack.length, needle.length &lt;= 104<br>haystack 和 needle 仅由小写英文字符组成</p>
<hr>
<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.<span class="built_in">size</span>(), n = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt;= m-n; start++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; n; offset++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[start+offset] == needle[offset]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (offset == n - <span class="number">1</span>) <span class="keyword">return</span> start;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="KMP算法-Knuth-Morris-Pratt算法"><a href="#KMP算法-Knuth-Morris-Pratt算法" class="headerlink" title="KMP算法(Knuth-Morris-Pratt算法)"></a>KMP算法(Knuth-Morris-Pratt算法)</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>165. 比较版本号</title>
    <url>/2022/07/06/leetcode-compare-version-numbers/</url>
    <content><![CDATA[<p>给你两个版本号 version1 和 version2 ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。
 </p>
<p>示例 1：</p>
<p>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br>示例 2：</p>
<p>输入：version1 = “1.0”, version2 = “1.0.0”<br>输出：0<br>解释：version1 没有指定下标为 2 的修订号，即视为 “0”<br>示例 3：</p>
<p>输入：version1 = “0.1”, version2 = “1.1”<br>输出：-1<br>解释：version1 中下标为 0 的修订号是 “0”，version2 中下标为 0 的修订号是 “1” 。0 &lt; 1，所以 version1 &lt; version2
 </p>
<hr>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = version1.<span class="built_in">size</span>(), n = version2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; m &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// version1[i++] - &#x27;0&#x27; + 10 * x 对比 10 * x + version1[i++] - &#x27;0&#x27;, 后者会溢出</span></span><br><span class="line">                x = version1[i++] - <span class="string">&#x27;0&#x27;</span> + <span class="number">10</span> * x;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                y = version2[j++] - <span class="string">&#x27;0&#x27;</span> + <span class="number">10</span> * y;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x != y) <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>分糖果问题(系列)</title>
    <url>/2022/07/03/leetcode-distribute-candies/</url>
    <content><![CDATA[<h1 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="575. 分糖果"></a>575. 分糖果</h1><p>Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p>
<p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p>
<p>给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的 最多 种类数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：candyType = [1,1,2,2,3,3]<br>输出：3<br>解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。<br>示例 2：</p>
<p>输入：candyType = [1,1,2,3]<br>输出：2<br>解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。<br>示例 3：</p>
<p>输入：candyType = [6,6,6,6]<br>输出：1<br>解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。
 </p>
<p>提示：</p>
<p>n == candyType.length<br>2 &lt;= n &lt;= 104<br>n 是一个偶数<br>-105 &lt;= candyType[i] &lt;= 105</p>
<hr>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>能吃的糖果数不大于糖果种类数，也不大于糖果个数的一半。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(unordered_set&lt;<span class="keyword">int</span>&gt;(candyType.<span class="built_in">begin</span>(), candyType.<span class="built_in">end</span>()).<span class="built_in">size</span>(), candyType.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h1><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：ratings = [1,0,2]<br>输出：5<br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。<br>示例 2：</p>
<p>输入：ratings = [1,2,2]<br>输出：4<br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p>
<hr>
<h2 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h2><p>这题和求直方图中水量那题的思路有点类似。</p>
<p>先从左到右遍历，保证得分大的右邻居的糖果数符合要求<br>再从右向左遍历，保证得分大的左邻居的糖果数符合要求</p>
<p>时间复杂度O(n)<br>空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>] &amp;&amp; result[i] &lt;= result[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                result[i] = result[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = result[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; result[i] &lt;= result[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = result[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += result[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以对空间进行一些优化</p>
<p>TODO</p>
<h1 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103. 分糖果 II"></a>1103. 分糖果 II</h1><p>排排坐，分糖果。</p>
<p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：candies = 7, num_people = 4<br>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。<br>示例 2：</p>
<p>输入：candies = 10, num_people = 3<br>输出：[5,2,3]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。
 </p>
<p>提示：</p>
<p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p>
<hr>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num_people, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; candies &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; count &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            ans[i % num_people] += <span class="built_in">min</span>(count, candies);</span><br><span class="line">            candies = candies - <span class="built_in">min</span>(count++, candies);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>NC125 和为K的连续最大子数组</title>
    <url>/2022/07/03/leetcode-largest-subarray-length-k/</url>
    <content><![CDATA[<h1 id="NC125-和为K的连续最大子数组"><a href="#NC125-和为K的连续最大子数组" class="headerlink" title="NC125 和为K的连续最大子数组"></a>NC125 和为K的连续最大子数组</h1><p>给定一个无序数组 arr , 其中元素可正、可负、可0。给定一个整数 k ，求 arr 所有连续子数组中累加和为k的最长连续子数组长度。保证至少存在一个合法的连续子数组。<br>[1,2,3]的连续子数组有[1,2]，[2,3]，[1,2,3] ，但是[1,3]不是</p>
<p>要求：空间复杂度 O(n)， 时间复杂度 O(n)</p>
<p>示例1<br>输入：<br>[1,-2,1,1,1],0<br>返回值：<br>3</p>
<p>示例2<br>输入：<br>[0,1,2,3],3<br>返回值：<br>3</p>
<hr>
<h1 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h1><p>哈希表记录前缀和第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * max length of the subarray sum = k</span></span><br><span class="line"><span class="comment">     * @param arr int整型vector the array</span></span><br><span class="line"><span class="comment">     * @param k int整型 target</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxlenEqualK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            pre += arr[i];</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre-k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i-mp[pre-k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre) == mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                mp[pre] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>560. 和为K的连续子数组</title>
    <url>/2022/07/03/leetcode-subarray-sum-equals-k/</url>
    <content><![CDATA[<h1 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h1><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,1,1], k = 2<br>输出：2<br>示例 2：</p>
<p>输入：nums = [1,2,3], k = 3<br>输出：2
 </p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 2 * 104<br>-1000 &lt;= nums[i] &lt;= 1000<br>-107 &lt;= k &lt;= 107</p>
<hr>
<h2 id="暴力枚举，-无法通过OJ"><a href="#暴力枚举，-无法通过OJ" class="headerlink" title="暴力枚举， 无法通过OJ"></a>暴力枚举， 无法通过OJ</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> end = start; end &lt; n; end++) &#123;</span><br><span class="line">                tmp += nums[end];</span><br><span class="line">                <span class="keyword">if</span> (tmp == k) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h2><p>记录pre[i]为序号为0-i的数组中所有数的和。<br>对于序号为[i, j]的子树组来说，如果pre[j]-pre[i-1] == k, 则其为一个目标答案。</p>
<p>可以考虑用一个哈希表记录所有前缀和出现的次数，遍历一次即可求得答案。</p>
<p>时间复杂度和空间复杂度均为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">            pre += nums[start];</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre-k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans += mp[pre-k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>222. 完全二叉树的节点个数</title>
    <url>/2022/07/02/leetcode-count-complete-tree-nodes/</url>
    <content><![CDATA[<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p>
<p>输入：root = []<br>输出：0<br>示例 3：</p>
<p>输入：root = [1]<br>输出：1
 </p>
<p>提示：</p>
<p>树中节点的数目范围是[0, 5 * 104]<br>0 &lt;= Node.val &lt;= 5 * 104<br>题目数据保证输入的树是 完全二叉树
 </p>
<p>进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p>
<hr>
<h1 id="直接深度优先遍历"><a href="#直接深度优先遍历" class="headerlink" title="直接深度优先遍历"></a>直接深度优先遍历</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>若完全二叉树层数为h，根为0层，最后一层也就是第h层的节点数为1至2^h之间，总的节点数为[2^h, 2&amp;(h+1)-1]<br>可以通过二分法判断。</p>
<p>如果判断最后一层的一个节点是否存在 是核心的问题。可以通过位运算来确定。</p>
<p>整体的时间复杂度为O(log^2n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            h++;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span> &lt;&lt; h, right = (<span class="number">1</span> &lt;&lt; (h+<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;left:&quot; &lt;&lt; left &lt;&lt; &quot; right:&quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exists</span>(root, h, mid)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;left:&quot; &lt;&lt; left &lt;&lt; &quot; right:&quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exists</span><span class="params">(TreeNode *root, <span class="keyword">int</span> level, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">1</span> &lt;&lt; (level<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (bits &gt; <span class="number">0</span> &amp;&amp; root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((bits &amp; k) == <span class="number">0</span>) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数(系列)</title>
    <url>/2022/06/27/leetcode-ugly-number/</url>
    <content><![CDATA[<h1 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h1><p>丑数 就是只包含质因数 2、3 和 5 的正整数。</p>
<p>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 6<br>输出：true<br>解释：6 = 2 × 3<br>示例 2：</p>
<p>输入：n = 1<br>输出：true<br>解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。<br>示例 3：</p>
<p>输入：n = 14<br>输出：false<br>解释：14 不是丑数，因为它包含了另外一个质因数 7 。</p>
<hr>
<p>分别对n反复除以质因子2,3,5, 如果最后剩余的值为1，则OK</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> factors[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % factor == <span class="number">0</span>) n = n/factor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h1><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p>
<p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。<br>示例 2：</p>
<p>输入：n = 1<br>输出：1<br>解释：1 通常被视为丑数。</p>
<hr>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>直接按自然数顺序遍历isUgly, 但是时间复杂度O(nlogn)太高，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isUgly</span>(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> factors[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> factor : factors) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % factor == <span class="number">0</span>) n = n/factor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h2><p>每次从堆顶取出最小值，然后乘以三个因子后的数加入堆，为了避免重复，可以使用集合过滤。</p>
<p>时间复杂度也是O(nlogn), 但是确能通过OJ了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> factors[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        unordered_set&lt;<span class="keyword">long</span>&gt; seen;</span><br><span class="line">        <span class="comment">// 默认大顶堆</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">long</span>, vector&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt;&gt; heap;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        heap.<span class="built_in">push</span>(ans);</span><br><span class="line">        seen.<span class="built_in">insert</span>(ans);</span><br><span class="line">        <span class="keyword">long</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cur = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> factor : factors) &#123;</span><br><span class="line">                <span class="keyword">long</span> next = cur * factor;</span><br><span class="line">                <span class="keyword">if</span> (!seen.<span class="built_in">count</span>(next)) &#123;</span><br><span class="line">                    seen.<span class="built_in">insert</span>(next);</span><br><span class="line">                    heap.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三个数组-或者叫动态规划"><a href="#三个数组-或者叫动态规划" class="headerlink" title="三个数组(或者叫动态规划)"></a>三个数组(或者叫动态规划)</h2><p>dp[i] = min(dp[i-1]*2, dp[i-1]*3, dp[i-1]*5)<br>初始时候dp[1] = 1;<br>后面不断的乘以2，3，5分别可以得到3个数组，就是不知道下一次该选谁，所以有三个指针记录当前走到的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> factors[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>, ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2]*<span class="number">2</span>, num3 = dp[p3]*<span class="number">3</span>, num5 = dp[p5]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(num2, <span class="built_in">min</span>(num3, num5));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num2) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num3) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a>313. 超级丑数</h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p>
<p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p>
<p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 12, primes = [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>示例 2：</p>
<p>输入：n = 1, primes = [2,3,5]<br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。<br> <br>提示：</p>
<p>1 &lt;= n &lt;= 105<br>1 &lt;= primes.length &lt;= 100<br>2 &lt;= primes[i] &lt;= 1000<br>题目数据 保证 primes[i] 是一个质数<br>primes 中的所有值都 互不相同 ，且按 递增顺序 排列</p>
<hr>
<p>思路和普通丑数的处理方式一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prime_size = primes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pointers</span><span class="params">(prime_size, <span class="number">1</span>)</span></span>; <span class="comment">//指针列表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span>&gt; <span class="title">tmp_nums</span><span class="params">(prime_size, <span class="number">1</span>)</span></span>; <span class="comment">//存储每次计算的临时结果</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p_index = <span class="number">0</span>; p_index &lt; prime_size; p_index++) &#123;</span><br><span class="line">                tmp_nums[p_index] = primes[p_index]*dp[pointers[p_index]];</span><br><span class="line">                <span class="keyword">if</span> (tmp_nums[p_index] &lt; dp[i]) dp[i] = tmp_nums[p_index];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p_index = <span class="number">0</span>; p_index &lt; prime_size; p_index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i] == tmp_nums[p_index]) &#123;</span><br><span class="line">                    pointers[p_index]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="1201-丑数-III"><a href="#1201-丑数-III" class="headerlink" title="1201. 丑数 III"></a>1201. 丑数 III</h1><p>给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。</p>
<p>丑数是可以被 a 或 b 或 c 整除的 正整数 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 3, a = 2, b = 3, c = 5<br>输出：4<br>解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10… 其中第 3 个是 4。<br>示例 2：</p>
<p>输入：n = 4, a = 2, b = 3, c = 4<br>输出：6<br>解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12… 其中第 4 个是 6。<br>示例 3：</p>
<p>输入：n = 5, a = 2, b = 11, c = 13<br>输出：10<br>解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13… 其中第 5 个是 10。<br>示例 4：</p>
<p>输入：n = 1000000000, a = 2, b = 217983653, c = 336916467<br>输出：1999999984</p>
<hr>
<p>这题和前面的题，似乎都不太一样，</p>
<h2 id="递推的思路，时间复杂度太高"><a href="#递推的思路，时间复杂度太高" class="headerlink" title="递推的思路，时间复杂度太高"></a>递推的思路，时间复杂度太高</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> factors[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>, ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 这一行的计算和以前不一样</span></span><br><span class="line">            <span class="keyword">int</span> num2 = p2*factors[<span class="number">0</span>], num3 = p3*factors[<span class="number">1</span>], num5 = p5*factors[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;p2,p3,p5: &quot; &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; p3 &lt;&lt; &quot; &quot; &lt;&lt; p5 &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;num2,num3,num5: &quot; &lt;&lt; num2 &lt;&lt; &quot;,&quot; &lt;&lt; num3 &lt;&lt; &#x27;,&#x27; &lt;&lt; num5;</span></span><br><span class="line"></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(num2, <span class="built_in">min</span>(num3, num5));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num2) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num3) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num5) p5++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <url>/2022/06/22/leetcode-firstUniqChar/</url>
    <content><![CDATA[<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例 1:</p>
<p>输入：s = “abaccdeff”<br>输出：’b’<br>示例 2:</p>
<p>输入：s = “”<br>输出：’ ‘</p>
<hr>
<h1 id="哈希表一次遍历"><a href="#哈希表一次遍历" class="headerlink" title="哈希表一次遍历"></a>哈希表一次遍历</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            freq[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="使用队列-哈希表"><a href="#使用队列-哈希表" class="headerlink" title="使用队列+哈希表"></a>使用队列+哈希表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果一个字符非第一次出现</span></span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 将队列头部的非第一次出现的字符弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列为空，说明没有只出现一次的字符；否则队首即为结果</span></span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="string">&#x27; &#x27;</span> : q.<span class="built_in">front</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 61. 扑克牌中的顺子</title>
    <url>/2022/06/21/leetcode-Straight-in-poker/</url>
    <content><![CDATA[<p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5]<br>输出: True
 </p>
<p>示例 2:</p>
<p>输入: [0,0,1,2,5]<br>输出: True
 </p>
<p>限制：</p>
<p>数组长度为 5 </p>
<p>数组的数取值为 [0, 13] .</p>
<hr>
<h1 id="一次遍历-哈希表"><a href="#一次遍历-哈希表" class="headerlink" title="一次遍历+哈希表"></a>一次遍历+哈希表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_num = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> num_table[<span class="number">14</span>];</span><br><span class="line">        <span class="built_in">memset</span>(num_table, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num_table));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            num_table[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="keyword">continue</span>;     <span class="comment">//0不参与最大最小值的计算</span></span><br><span class="line">            <span class="keyword">if</span> (num_table[nums[i]] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//如果有非0的重复数，直接返回false</span></span><br><span class="line">            min_num = <span class="built_in">min</span>(nums[i], min_num);</span><br><span class="line">            max_num = <span class="built_in">max</span>(nums[i], max_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = min_num; i &lt;= max_num; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     num_table[i]--; </span></span><br><span class="line">        <span class="comment">//     if (num_table[i] == -1 &amp;&amp; num_table[0] &gt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//         num_table[i]++;</span></span><br><span class="line">        <span class="comment">//         num_table[0]--;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     if (num_table[i] != 0) return false; </span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 只要最大最小值差异小于5即说明可组成顺子</span></span><br><span class="line">        <span class="keyword">return</span> max_num - min_num &lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="排序-一次遍历"><a href="#排序-一次遍历" class="headerlink" title="排序+一次遍历"></a>排序+一次遍历</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> min_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                min_index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; min_index &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (min_index == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 只要最大最小值差异小于5即说明可组成顺子</span></span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>] - nums[min_index] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>36. 有效的数独</title>
    <url>/2022/06/19/leetcode-valid-sudoku/</url>
    <content><![CDATA[<p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 </p>
<p>注意：</p>
<p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 ‘.’ 表示。
 </p>
<hr>
<h1 id="一趟遍历"><a href="#一趟遍历" class="headerlink" title="一趟遍历"></a>一趟遍历</h1><p>分别用二维数组记录每一行和每一列中1-9出现的个数，用三维数组记录每一个小方格中1-9的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// rows记录每一行中1-9出现的个数, 当前由于是逐行扫描的，可以考虑使用一维数组，不过每行遍历初始需要归零</span></span><br><span class="line">        <span class="comment">// columns记录每一列中1-9出现的个数</span></span><br><span class="line">        <span class="comment">// subboxes记录每一个3*3小方格中1-9出现的个数</span></span><br><span class="line">        <span class="keyword">int</span> rows[n][NUM], columns[n][NUM], subboxes[n/<span class="number">3</span>][n/<span class="number">3</span>][NUM];</span><br><span class="line">        <span class="built_in">memset</span>(rows, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rows));</span><br><span class="line">        <span class="built_in">memset</span>(columns, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(columns));</span><br><span class="line">        <span class="built_in">memset</span>(subboxes, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(subboxes));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    rows[i][num]++;</span><br><span class="line">                    columns[j][num]++;</span><br><span class="line">                    subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][num]++;</span><br><span class="line">                    <span class="keyword">if</span> (rows[i][num] &gt; <span class="number">1</span> || columns[j][num] &gt; <span class="number">1</span> || subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][num] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>37. 解数独</title>
    <url>/2022/06/19/leetcode-sudoku-solver/</url>
    <content><![CDATA[<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<hr>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>先遍历一次board，找到需要填数的位置，然后依次遍历填写，如果填写完成就结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> rows[<span class="number">9</span>][<span class="number">9</span>], columns[<span class="number">9</span>][<span class="number">9</span>], subboxes[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span> valid;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; spaces;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;index:&quot; &lt;&lt; index &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (index == spaces.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [row, column] = spaces[index];</span><br><span class="line">        <span class="comment">// 题目保证了仅有一个唯一解, 当所有的数都填完以后，即结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> &amp;&amp; !valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rows[row][i] == <span class="number">0</span> &amp;&amp; columns[column][i] == <span class="number">0</span> &amp;&amp; subboxes[row/<span class="number">3</span>][column/<span class="number">3</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                board[row][column] = i + <span class="number">1</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                rows[row][i]++;</span><br><span class="line">                columns[column][i]++;</span><br><span class="line">                subboxes[row/<span class="number">3</span>][column/<span class="number">3</span>][i]++;</span><br><span class="line">                <span class="built_in">backtrack</span>(board, index+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// board[row][column] = &#x27;.&#x27;;</span></span><br><span class="line">                rows[row][i]--;</span><br><span class="line">                columns[column][i]--;</span><br><span class="line">                subboxes[row/<span class="number">3</span>][column/<span class="number">3</span>][i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(rows, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rows));</span><br><span class="line">        <span class="built_in">memset</span>(columns, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(columns));</span><br><span class="line">        <span class="built_in">memset</span>(subboxes, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(subboxes));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    rows[i][num]++;</span><br><span class="line">                    columns[j][num]++;</span><br><span class="line">                    subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][num]++;</span><br><span class="line">                    <span class="keyword">if</span> (rows[i][num] &gt; <span class="number">1</span> || columns[j][num] &gt; <span class="number">1</span> || subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][num] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    spaces.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtrack</span>(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <url>/2022/06/13/leetcode-balance-a-binary-search-tree/</url>
    <content><![CDATA[<p>给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>
<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,null,3,null,4,null,null]<br>输出：[2,1,3,null,null,null,4]<br>解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。<br>示例 2：</p>
<p>输入: root = [2,1,3]<br>输出: [2,1,3]</p>
<hr>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>可以利用 二叉搜索树中序遍历的结果是有序数组的特点，先得到有序数组，然后在构建平衡二叉搜索树</p>
<p>时间空间复杂度均为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, nums);</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildBST</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildBST</span>(nums, left, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildBST</span>(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; inOrderNums;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, inOrderNums);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildBST</span>(inOrderNums, <span class="number">0</span>, inOrderNums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="插入时旋转"><a href="#插入时旋转" class="headerlink" title="插入时旋转"></a>插入时旋转</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2022/06/12/leetcode-convert-sorted-array-to-binary-search-tree/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p>示例 2：</p>
<p>输入：nums = [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p>
<hr>
<p>升序数组转化为平衡二叉树，可以有很多种；</p>
<p>转化为高度平衡的二叉树，却只有有限的几种，核心在于选择跟节点的方式：</p>
<ul>
<li>总是选择中间数的左边一个数</li>
<li>总是选择中间数的右边一个数</li>
<li>选择中间数的左或右的一个数</li>
</ul>
<p>时间复杂度：O(n), 数组中每个数遍历一次即可<br>空间复杂度：O(logn), 主要是递归调用的深度，高度平衡二叉树，高度为logn</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">createBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里有多种写法，对应不同的结果</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">createBST</span>(nums, left, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">createBST</span>(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createBST</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>NC144 懂二进制</title>
    <url>/2022/06/12/leetcode-the-diff-bit-number/</url>
    <content><![CDATA[<p>描述<br>世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？<br>示例1<br>输入：<br>3,5<br>返回值：<br>2<br>说明：<br>3的二进制为11，5的二进制为101，总共有2位不同 </p>
<p>示例2<br>输入：<br>1999,2299<br>复制<br>返回值：<br>7</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param m int整型 </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBitDiff</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按位异或，不同的位变为1</span></span><br><span class="line">        <span class="keyword">int</span> tmp = m ^ n;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            tmp &amp;= (tmp<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bit</tag>
      </tags>
  </entry>
  <entry>
    <title>1044. 最长重复子串</title>
    <url>/2022/06/10/leetcode-longest-duplicate-substring/</url>
    <content><![CDATA[<p>给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。</p>
<p>返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 “” 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “banana”<br>输出：”ana”<br>示例 2：</p>
<p>输入：s = “abcd”<br>输出：””
 </p>
<p>提示：</p>
<p>2 &lt;= s.length &lt;= 3 * 104<br>s 由小写英文字母组成</p>
<hr>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>99. 恢复二叉搜索树</title>
    <url>/2022/06/09/leetcode-recover-binary-search-tree/</url>
    <content><![CDATA[<p>给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。<br>示例 2：</p>
<p>输入：root = [3,1,4,null,null,2]<br>输出：[2,1,4,null,null,3]<br>解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。
 </p>
<p>提示：</p>
<p>树上节点的数目在范围 [2, 1000] 内<br>-231 &lt;= Node.val &lt;= 231 - 1
 </p>
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用 O(1) 空间的解决方案吗？</p>
<hr>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><ol>
<li>先中序遍历拿到遍历结果值</li>
<li>然后找到异常的2个数。分是否相邻两种情况</li>
<li>遍历二叉树修复这两个数</li>
</ol>
<p>时间复杂度: O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, nums);</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果交换的是两个相邻的数，则只能找到一个异常点；</span></span><br><span class="line">    <span class="comment">// 如果交换的不是相邻的数，则能找到2个异常点</span></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">findTwo</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                index2 = i+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// index1再次出现 说明找到了第二个异常的数</span></span><br><span class="line">                <span class="keyword">if</span> (index1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                    index1 = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;nums[index1], nums[index2]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == x || root-&gt;val == y) &#123;</span><br><span class="line">            root-&gt;val = root-&gt;val == x ? y : x;</span><br><span class="line">            <span class="keyword">if</span> (--count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recover</span>(root-&gt;left, x, y, count);</span><br><span class="line">        <span class="built_in">recover</span>(root-&gt;right, x, y, count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; treeNums;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, treeNums);</span><br><span class="line">        <span class="keyword">auto</span> two = <span class="built_in">findTwo</span>(treeNums);</span><br><span class="line">        <span class="built_in">recover</span>(root, two.first, two.second, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实没必要真正返回一个数组存储中序遍历的结果，可以在中序遍历的过程中直接找到异常的数，然后交换。</p>
<p>一次遍历二叉树得到，时间复杂度为O(n)<br>空间复杂度主要来自于递归调用深度，为二叉树高度，最坏情况下为单链表，O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 注意，指针也需要是引用类型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, TreeNode* &amp;pre, TreeNode* &amp;index1, TreeNode* &amp;index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, pre, index1, index2);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">            index2 = root;</span><br><span class="line">            <span class="keyword">if</span> (index1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                index1 = pre;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, pre, index1, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>, *index1 = <span class="literal">nullptr</span>, *index2 = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, pre, index1, index2);</span><br><span class="line">        <span class="keyword">if</span> (index1 != <span class="literal">nullptr</span> &amp;&amp; index2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; index1-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; index2-&gt;val;</span></span><br><span class="line">            <span class="keyword">int</span> tmp = index1-&gt;val;</span><br><span class="line">            index1-&gt;val = index2-&gt;val;</span><br><span class="line">            index2-&gt;val = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Morris-中序遍历"><a href="#Morris-中序遍历" class="headerlink" title="Morris 中序遍历"></a>Morris 中序遍历</h1><p>TODO </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 16.05. 阶乘尾数</title>
    <url>/2022/06/08/leetcode-factorial-zeros-lcci/</url>
    <content><![CDATA[<p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<p>示例 1:</p>
<p>输入: 3<br>输出: 0<br>解释: 3! = 6, 尾数中没有零。<br>示例 2:</p>
<p>输入: 5<br>输出: 1<br>解释: 5! = 120, 尾数中有 1 个零.<br>说明: 你算法的时间复杂度应为 O(log n) 。</p>
<hr>
<h1 id="分析质因子"><a href="#分析质因子" class="headerlink" title="分析质因子"></a>分析质因子</h1><p>考虑到因子2和5才有可能贡献尾数0，由于2一定比5多，只需考虑因子5的个数。</p>
<p>比如30，有30，25，20，15，10，5共6个数贡献7个因子5(25贡献了两个5)</p>
<p>一般通用情况下，考虑[1,n]中质因子p的个数。</p>
<p>[1, n]中p的倍数有n1=[n/p]个，即至少能贡献n1个质因子；</p>
<p>[1, n]中p^2的倍数有n2=[n/(p^2)]个，即至少能贡献n2个质因子；</p>
<p>举个例子，比如n=30, p=5, n1=[30/5]=6,也就是一阶5可以有6个贡献，即5<em>1，5</em>2，5<em>3，5</em>4，5<em>5，5</em>6<br>n2=[30/25]=1, 也就是二阶5有1个贡献，即25*1。</p>
<p>需要说明的是这里25虽然被计算了两次，但是却没有算重复，累积贡献2个5，其中一阶5和二阶5分别贡献了一次5。</p>
<p>由于5^3=125已经大于30了，所以就不用考虑三阶的5了。</p>
<p>推而广之，[1, n]中质因子的个数是<br>[n/p] + [n/(p^2)] + [n/(p^3)] + …</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n = n/<span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <url>/2022/06/07/leetcode-convert-binary-search-tree-to-sorted-doubly-linked-list/</url>
    <content><![CDATA[<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p> </p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p> </p>
<p> </p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p> </p>
<p> </p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<hr>
<h1 id="中序遍历的思路-递归实现"><a href="#中序遍历的思路-递归实现" class="headerlink" title="中序遍历的思路-递归实现"></a>中序遍历的思路-递归实现</h1><p>时间复杂度：二叉树每个节点遍历一次，O(n)<br>空间复杂度：递归调用深度为树的高度，二叉树高度最差情况下会退化为单链表，为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    Node* pre, *head;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 前一个节点的右节点指向当前节点，当前节点的左节点指向前一个节点。</span></span><br><span class="line">        <span class="comment">// 如果前一个节点为空，说明当前节点即为头节点(第一个节点)</span></span><br><span class="line">        <span class="comment">// 完成后，将当前节点设置为下轮遍历的 前一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        pre = <span class="literal">nullptr</span>;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">        <span class="comment">// 对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</span></span><br><span class="line">        <span class="comment">// 中序遍历完成时，head只有right已定义，pre只有left已定义，不构成完整的 双向循环</span></span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="中序遍历-栈的实现"><a href="#中序遍历-栈的实现" class="headerlink" title="中序遍历  栈的实现"></a>中序遍历  栈的实现</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>方阵乘法</title>
    <url>/2022/06/07/leetcode-Square-matrix-multiplication/</url>
    <content><![CDATA[<p>描述<br>给定两个 n<em>n 的矩阵 A 和 B ，求 A</em>B 。</p>
<p>数据范围：1 \le n \le 1001≤n≤100，-100 \le Matrix_{i,j}\le 100−100≤Matrix<br>i,j<br>​<br> ≤100</p>
<p>要求：空间复杂度 O(n^2)O(n<br>2<br> ) ， 时间复杂度 O(n^3 )O(n<br>3<br> )<br>进阶：本题也有空间复杂度 O(n^2)O(n<br>2<br> )，时间复杂度 O(n^{log7})O(n<br>log7<br> )的解法<br>PS：更优时间复杂度的算法这里并不考察<br>示例1<br>输入：<br>[[1,2],[3,2]],[[3,4],[2,1]]<br>返回值：<br>[[7,6],[13,14]]</p>
<p>示例2<br>输入：<br>[[1]],[[1]]<br>返回值：<br>[[1]]</p>
<hr>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>329. 矩阵中的最长递增路径</title>
    <url>/2022/06/05/leetcode-longest-increasing-path-in-a-matrix/</url>
    <content><![CDATA[<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]<br>输出：4<br>解释：最长递增路径为 [1, 2, 6, 9]。<br>示例 2：</p>
<p>输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]<br>输出：4<br>解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。<br>示例 3：</p>
<p>输入：matrix = [[1]]<br>输出：1
 </p>
<hr>
<h1 id="深度优先搜索-递归"><a href="#深度优先搜索-递归" class="headerlink" title="深度优先搜索-递归"></a>深度优先搜索-递归</h1><p>对于每一个位置，其上下左右四个方向中，比当前位置值大的值与当前值必然组成长度不小于2的段。<br>求得每个位置的最长递增路径长度后，遍历每个位置的值，即可求得答案。</p>
<p>当然，为了避免重复计算，使用数组记录已经求得的值。所以也叫 记忆化深度优先搜索。</p>
<p>时间复杂度: O(m<em>n),其中m和n为矩阵的长和宽。考虑矩阵为无向图，深度优先遍历的时间复杂度为O(V+E), 其中V、E分别为无向图的顶点和边。在矩阵中，O(V) = O(m</em>n), O(E) = O(4mn) = O(mn)<br>空间复杂度：O(m<em>n), 空间主要是缓存memo和递归调用的深度，memo为m</em>n, 递归调用深度最坏是把所有矩阵元素连起来，长度不会超过m*n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上下左右四个方向</span></span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[row][column] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数字长度为1</span></span><br><span class="line">        ++memo[row][column];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + dirs[i][<span class="number">0</span>], newColumn = column + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newRow&gt;=<span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn&gt;=<span class="number">0</span> &amp;&amp; newColumn&lt;columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">                memo[row][column] = <span class="built_in">max</span>(memo[row][column], <span class="built_in">dfs</span>(matrix, memo, newRow, newColumn, rows, columns) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][column];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; columns; column++) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(matrix, memo, row, column, rows, columns));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>如果是动态规划，则是先计算值较大节点的路径长度，然后递推</p>
<p>可以考虑使用优先级队列对矩阵中元素进行排序，然后从大到小计算以元素i,j结尾的最大序列的长度：dp[i][j]<br>记录整个过程中最大的dp[i][j]值即为答案</p>
<p>dp[i][j]表示以元素(i, j)为开始节点的最大路径长度</p>
<p>时间和空间复杂度依然是O(m*n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上下左右四个方向</span></span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 使用优先级队列排序, 默认是大顶堆，优先队列里面每个元素是元组</span></span><br><span class="line">        priority_queue&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// priority_queue&lt;tuple&lt;int, int, int&gt;, vector&lt;tuple&lt;int, int, int&gt;&gt;, greater&lt;tuple&lt;int, int, int&gt;&gt;&gt; q;</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; columns; column++) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;matrix[row][column], row, column&#125;);</span><br><span class="line">                <span class="comment">// q.push(make_tuple(matrix[row][column], row, column));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 依次弹出栈顶元素, 也就是最大的数，计算该节点的dp值后再计算更小的，这里面最大的dp值即为答案</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cell = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> row = get&lt;<span class="number">1</span>&gt;(cell), column = get&lt;<span class="number">2</span>&gt;(cell);</span><br><span class="line">            <span class="comment">// 单独一个数也能成为长度为1的路径</span></span><br><span class="line">            ++dp[row][column];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> direction = <span class="number">0</span>; direction &lt; <span class="number">4</span>; direction++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newRow = row + dirs[direction][<span class="number">0</span>], newColumn = column + dirs[direction][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newRow&gt;=<span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn&gt;=<span class="number">0</span> &amp;&amp; newColumn&lt;columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">                    dp[row][column] = <span class="built_in">max</span>(dp[row][column], dp[newRow][newColumn]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[row][column]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="广度优先搜索-队列-拓扑排序"><a href="#广度优先搜索-队列-拓扑排序" class="headerlink" title="广度优先搜索-队列-拓扑排序"></a>广度优先搜索-队列-拓扑排序</h1><p>将矩阵看作是一个有向图，计算每个单元格对应的出度，即有多少条边从该节点出发，也就是相邻的四个顶点有几个点比该点大。</p>
<p>边界条件是出度为0的点，若为路径，必为路径结尾。</p>
<p>基于出度的概念，可以使用拓扑排序求解，从所有出度为0的单元格开始广度优先搜索，每一轮都会遍历当前队列中的所有节点，然后更新周围的节点，<br>并将出度为0的节点加入下一层。这样，分别遍历出度为0，相邻且出度为1，相邻且出度为2…的节点，当遍历结束时，搜索的总层数即为答案。</p>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上下左右四个方向</span></span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 存储出度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">outdegrees</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>));</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 先更新每个点的出度, 并将更新后出度仍为0的点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; columns; column++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> direction = <span class="number">0</span>; direction &lt; <span class="number">4</span>; direction++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row + dirs[direction][<span class="number">0</span>], newColumn = column + dirs[direction][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow&gt;=<span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn&gt;=<span class="number">0</span> &amp;&amp; newColumn&lt;columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">                        ++outdegrees[row][column];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; outdegrees[row][column] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (outdegrees[row][column] == <span class="number">0</span>) q.<span class="built_in">push</span>(&#123;row, column&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始分层遍历，并记录层数。</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cell = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> row = cell.first, column = cell.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> direction = <span class="number">0</span>; direction &lt; <span class="number">4</span>; direction++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row + dirs[direction][<span class="number">0</span>], newColumn = column + dirs[direction][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow&gt;=<span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn&gt;=<span class="number">0</span> &amp;&amp; newColumn&lt;columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                        --outdegrees[newRow][newColumn];</span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) q.<span class="built_in">push</span>(&#123;newRow, newColumn&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>617. 合并二叉树</title>
    <url>/2022/06/05/leetcode-merge-two-binary-trees/</url>
    <content><![CDATA[<p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<br>示例 2：</p>
<p>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]</p>
<hr>
<h1 id="深度优先搜索-递归"><a href="#深度优先搜索-递归" class="headerlink" title="深度优先搜索-递归"></a>深度优先搜索-递归</h1><p>面试时候，需要和面试官确认，是否可以修改原有的两棵树。还有合并后的二叉树是否可以和原树共用空间。</p>
<p>递归真是解决二叉树的问题的一个利器。</p>
<p>时间复杂度：O(min(m, n)), 其中m和n分别是两个二叉树的节点个数, 只有二叉树中均不为空的节点才需要合并，需要合并的节点数不超过二者中节点数较小者的2倍<br>空间复杂度:O(min(m, n)), 空间复杂度取决于递归调用的层数，二叉树递归的层数不超过二叉树的深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);</span><br><span class="line">        ans-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        ans-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="广度优先搜索-队列"><a href="#广度优先搜索-队列" class="headerlink" title="广度优先搜索-队列"></a>广度优先搜索-队列</h1><p>层序遍历的思路，使用三个队列分别存储原始两个树和新树中需要合并的节点。</p>
<p>不需要合并的节点，直接复用既有的节点。(这一点需要和面试官达成一致)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        TreeNode* ans = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q, q1, q2;</span><br><span class="line">        q.<span class="built_in">emplace</span>(ans);</span><br><span class="line">        q1.<span class="built_in">emplace</span>(root1);</span><br><span class="line">        q2.<span class="built_in">emplace</span>(root2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* node1 = q1.<span class="built_in">front</span>(); q1.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* node2 = q2.<span class="built_in">front</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 若左子树不全为空</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;left || node2-&gt;left) &#123;</span><br><span class="line">                <span class="comment">// 若左右子树均存在，则需要新建节点并用合并后的值更新</span></span><br><span class="line">                <span class="keyword">if</span> (node1-&gt;left &amp;&amp; node2-&gt;left) &#123;</span><br><span class="line">                    q1.<span class="built_in">emplace</span>(node1-&gt;left);</span><br><span class="line">                    q2.<span class="built_in">emplace</span>(node2-&gt;left);</span><br><span class="line">                    TreeNode* tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(node1-&gt;left-&gt;val + node2-&gt;left-&gt;val);</span><br><span class="line">                    q.<span class="built_in">emplace</span>(tmp);</span><br><span class="line">                    node-&gt;left = tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node1-&gt;left) &#123;</span><br><span class="line">                    <span class="comment">// 若要求不允许复用原树中的节点，则此处也需要新建节点</span></span><br><span class="line">                    node-&gt;left = node1-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node-&gt;left = node2-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右节点同理</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;right || node2-&gt;right) &#123;</span><br><span class="line">                <span class="comment">// 若左右子树均存在，则需要新建节点并用合并后的值更新</span></span><br><span class="line">                <span class="keyword">if</span> (node1-&gt;right &amp;&amp; node2-&gt;right) &#123;</span><br><span class="line">                    q1.<span class="built_in">emplace</span>(node1-&gt;right);</span><br><span class="line">                    q2.<span class="built_in">emplace</span>(node2-&gt;right);</span><br><span class="line">                    TreeNode* tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(node1-&gt;right-&gt;val + node2-&gt;right-&gt;val);</span><br><span class="line">                    q.<span class="built_in">emplace</span>(tmp);</span><br><span class="line">                    node-&gt;right = tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node1-&gt;right) &#123;</span><br><span class="line">                    <span class="comment">// 若要求不允许复用原树中的节点，则此处也需要新建节点</span></span><br><span class="line">                    node-&gt;right = node1-&gt;right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node-&gt;right = node2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 04.10. 检查子树</title>
    <url>/2022/06/04/leetcode-check-subtree-lcci/</url>
    <content><![CDATA[<p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>
<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<p>注意：此题相对书上原题略有改动。</p>
<p>示例1:</p>
<p> 输入：t1 = [1, 2, 3], t2 = [2]<br> 输出：true<br>示例2:</p>
<p> 输入：t1 = [1, null, 2, 4], t2 = [3, 2]<br> 输出：false</p>
<hr>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>如果一个树是另一个树的子树，则其根节点必然是相等,左右子树也是分别是子树。</p>
<p>如果t2为空，则必然是子树<br>如果t1为空，但是t2不为空，那必不是子树。<br>如果t1和t2的值相等，再看其左右子树是不是都相等或存在子树。<br>如果左子树不为空，看t2是否在左子树中<br>如果右子树不为空，看t2是否在右子树中</p>
<p>时间复杂度: O(m*n)<br>空间复杂度：O(m+n), 递归调用深度为二叉树深度, 二叉树深度最坏为节点数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span> &amp;&amp; t2 != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;val == t2-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkSubTree</span>(t1-&gt;left, t2-&gt;left) &amp;&amp; <span class="built_in">checkSubTree</span>(t1-&gt;right, t2-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkSubTree</span>(t1-&gt;left, t2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkSubTree</span>(t1-&gt;right, t2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>中序遍历等得到二叉树唯一的串，并且子树的树会紧挨着。</p>
<p>时间复杂度: O(m<em>n), 因为中序二叉树中每个元素均遍历一次为O(m+n)，但是find函数却是O(m</em>n)<br>空间复杂度：O(logm+logn), 递归调用深度为二叉树深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">string <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) ans += <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">        ans += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) ans += <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        string a1 = <span class="built_in">inOrder</span>(t1);</span><br><span class="line">        string a2 = <span class="built_in">inOrder</span>(t2);</span><br><span class="line">        <span class="keyword">if</span> (a1.<span class="built_in">size</span>() &lt; a2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a1.<span class="built_in">find</span>(a2) != a1.npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <url>/2022/06/04/leetcode-partition-array-by-odd-or-even/</url>
    <content><![CDATA[<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p> </p>
<p>示例：</p>
<p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。
 </p>
<hr>
<h1 id="一趟遍历划分"><a href="#一趟遍历划分" class="headerlink" title="一趟遍历划分"></a>一趟遍历划分</h1><p>借用快速排序划分的思想，将数组分为两个部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// index记录新奇数可以存放的第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[index++], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>226. 翻转二叉树</title>
    <url>/2022/06/04/leetcode-invert-binary-tree/</url>
    <content><![CDATA[<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]<br>示例 2：</p>
<p>输入：root = [2,1,3]<br>输出：[2,3,1]<br>示例 3：</p>
<p>输入：root = []<br>输出：[]
 </p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <url>/2022/06/04/leetcode-translate-digit2string/</url>
    <content><![CDATA[<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”
 </p>
<p>提示：</p>
<p>0 &lt;= num &lt; 231</p>
<hr>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记录dp[i]是以第i个数结尾的子数字串所能得到的翻译个数，则最后这个数对整体的贡献可以有两种：<br>要么单独一个数字成为一个翻译，要么和前一个数字共同成为一个翻译。</p>
<p>当前两个数字的翻译方案需要组成的数字合法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        string numStr = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="keyword">int</span> n = numStr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// dp[i] = dp[i-1] + dp[i-2];</span></span><br><span class="line">        <span class="comment">// dp的序号表示第几个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> str = numStr.<span class="built_in">substr</span>(i<span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (str &gt;= <span class="string">&quot;10&quot;</span> &amp;&amp; str &lt;= <span class="string">&quot;25&quot;</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i] + dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用滚动数组优化空间复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        string numStr = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>, q = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numStr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> str = numStr.<span class="built_in">substr</span>(i<span class="number">-1</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (str &gt;= <span class="string">&quot;10&quot;</span> &amp;&amp; str &lt;= <span class="string">&quot;25&quot;</span>) &#123;</span><br><span class="line">                r = p + q;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = q;</span><br><span class="line">            &#125;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子数组和</title>
    <url>/2022/06/04/leetcode-maximum-subarray/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums = [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums = [5,4,-1,7,8]<br>输出：23
 </p>
<hr>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>记录dp[i] 为以第i个数结尾的 连续子数组的最大和。<br>那么dp[i]等于dp[i-1]+nums[i]或nums[i]中的较大者，即每次遍历数组，看是否该数是单独贡献，还是可以加到前序子数组中。</p>
<p>最终的结果为dp中的最大值。</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>], pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            pre = <span class="built_in">max</span>(pre+nums[i], nums[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(pre, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>线段树的思路需要专题梳理</p>
<p>TODO 20220504</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>152. 乘积最大子数组</title>
    <url>/2022/06/03/leetcode-maximum-product-subarray/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums = [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: nums = [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
 </p>
<p>提示:</p>
<p>1 &lt;= nums.length &lt;= 2 * 104<br>-10 &lt;= nums[i] &lt;= 10<br>nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数</p>
<hr>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>记录dp_max[i]是以第i个数结尾的乘积最大子数组的积，则<br>dp_max[i] = max(dp_max[i-1]*nums[i], nums[i])</p>
<p>但是这样只能解决数组中所有数全部非负或全部非正的情形。</p>
<p>考虑负负得正的情形，我们新加一个dp_min, 表示最小的积，</p>
<p>则：</p>
<p>dp_max[i] = max(dp_max[i-1]*nums[i], dp_min[i-1]*nums[i], nums[i])</p>
<p>dp_min[i] = min(dp_max[i-1]*nums[i], dp_min[i-1]*nums[i], nums[i])</p>
<p>由于第i个状态只和i-1状态有关，所以可以考虑使用滚动数组的思想节省空间。</p>
<p>最终时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre_max = nums[<span class="number">0</span>], pre_min = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="comment">// 注意：pre_max和pre_min要并行计算，所以需要用临时变量先存一下</span></span><br><span class="line">            <span class="keyword">int</span> last_max = pre_max, last_min = pre_min;</span><br><span class="line">            pre_max = <span class="built_in">max</span>(num, <span class="built_in">max</span>(num*last_max, num*last_min));</span><br><span class="line">            pre_min = <span class="built_in">min</span>(num, <span class="built_in">min</span>(num*last_max, num*last_min));</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre_max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <url>/2022/05/31/leetcode-implement-trie-prefix-tree/</url>
    <content><![CDATA[<p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
 </p>
<p>示例：</p>
<p>输入<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>输出<br>[null, null, true, false, true, null, true]</p>
<p>解释<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 True<br>trie.search(“app”);     // 返回 False<br>trie.startsWith(“app”); // 返回 True<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 True
 </p>
<p>提示：</p>
<p>1 &lt;= word.length, prefix.length &lt;= 2000<br>word 和 prefix 仅由小写英文字母组成<br>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</p>
<hr>
<h1 id="26叉树"><a href="#26叉树" class="headerlink" title="26叉树"></a>26叉树</h1><p>Trie 前缀树，实际就是多叉树，如果只考虑小写字母那就是26叉树。</p>
<p>定义每个节点有一个子节点数组和一个是否结束标记。</p>
<p>初始化：子节点数组长度定义为26，是否结束标记定义为false<br>插入：将字符串中的每个字符挨个插入到树中，如果字符已存在，则看下一层，字符不存在则创建一个节点，注意：最后一个字符的节点标记为结束<br>查找前缀：按字符依次查找，如果返回空则未找到，全部找到为找到<br>查找字符串：类似查找前缀，但是结束时需要判定结束标记。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    vector&lt;Trie*&gt; chidren;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : word) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;chidren[index] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;chidren[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">chidren</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : word) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;chidren[index] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;chidren[index] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;chidren[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="built_in">searchPrefix</span>(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后(系列)</title>
    <url>/2022/05/27/leetcode-n-queens/</url>
    <content><![CDATA[<h1 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h1><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p> </p>
<p>示例 1：<br>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p>示例 2：<br>输入：n = 1<br>输出：[[“Q”]]
 </p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 9</p>
<h2 id="回溯穷举"><a href="#回溯穷举" class="headerlink" title="回溯穷举"></a>回溯穷举</h2><p>逐行尝试选择皇后放置的列，放置之前先检查可以放置在哪一列。当所有行都判断完后，可以将答案放置在答案数组中</p>
<p>一个皇后可以放置的位置，需要满足：<br>1.同列上方无皇后<br>2.左右斜对角延伸的上方每一行无皇后</p>
<h3 id="python3代码"><a href="#python3代码" class="headerlink" title="python3代码"></a>python3代码</h3><p>2020.07.25 15:37:13年的代码</p>
<p>printN负责打印结果数组</p>
<p>cal8queens通过递归穷举每一行</p>
<p>is_valid判断指定行和列是否OK</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printN</span>():</span></span><br><span class="line">            solution = []</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                tmp = [<span class="string">&#x27;.&#x27;</span>]*n</span><br><span class="line">                tmp[result[row]] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                tmp = <span class="string">&#x27;&#x27;</span>.join(tmp)</span><br><span class="line">                solution.append(tmp)</span><br><span class="line">            ans.append(solution)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal8queens</span>(<span class="params">row</span>):</span></span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                printN()</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> is_valid(row, column, n, result):</span><br><span class="line">                    result[row] = column</span><br><span class="line">                    cal8queens(row+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span>(<span class="params">row, column, n, result</span>):</span></span><br><span class="line">            leftup = column - <span class="number">1</span></span><br><span class="line">            righttop = column + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> result[i] == column:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> leftup &gt;= <span class="number">0</span> <span class="keyword">and</span> result[i] == leftup:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> righttop &lt; n <span class="keyword">and</span> result[i] == righttop:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                leftup -= <span class="number">1</span></span><br><span class="line">                righttop += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># result记录  第i行的皇后放在第几列</span></span><br><span class="line">        result = [-<span class="number">1</span>]*n</span><br><span class="line">        ans = []</span><br><span class="line">        cal8queens(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="C-的代码"><a href="#C-的代码" class="headerlink" title="C++的代码"></a>C++的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; chess;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(chess);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; column++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(row, column, n)) &#123;</span><br><span class="line">                chess[row][column] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="comment">// print();</span></span><br><span class="line">                <span class="built_in">backtrack</span>(row+<span class="number">1</span>, n);</span><br><span class="line">                chess[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = column - <span class="number">1</span>, right = column + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chess[i][column] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= <span class="number">0</span> &amp;&amp; chess[i][left] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp; chess[i][right] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            cout &lt;&lt; chess[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        chess.<span class="built_in">resize</span>(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="基于集合的回溯"><a href="#基于集合的回溯" class="headerlink" title="基于集合的回溯"></a>基于集合的回溯</h2><p>前一种方法中，check函数的时间复杂度为O(n)，导致整体的时间复杂度较高为O(n*n!)<br>可以使用集合将check的时间复杂度降低到O(1)</p>
<p>通过分析，我们可以发现：</p>
<ul>
<li><ol>
<li>左上方斜线上的元素，横纵坐标之差相等</li>
</ol>
</li>
<li><ol start="2">
<li>右上方斜线上的元素，横纵坐标之和相等</li>
</ol>
</li>
<li><ol start="3">
<li>纵向方向的元素，纵坐标相等。</li>
</ol>
</li>
</ul>
<p>所以可以用三个集合存储上述的数，用空间换时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; chess;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="comment">// 分别记录左上方、右上方、垂直方向三条线的值</span></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; leftup;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; rightup;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; columns;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(chess);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; column++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftup.<span class="built_in">find</span>(row-column) != leftup.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (rightup.<span class="built_in">find</span>(row+column) != rightup.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (columns.<span class="built_in">find</span>(column) != columns.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            chess[row][column] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            leftup.<span class="built_in">insert</span>(row-column);</span><br><span class="line">            rightup.<span class="built_in">insert</span>(row+column);</span><br><span class="line">            columns.<span class="built_in">insert</span>(column);</span><br><span class="line">            <span class="built_in">backtrack</span>(row+<span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">//还原现场</span></span><br><span class="line">            chess[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            leftup.<span class="built_in">erase</span>(row-column);</span><br><span class="line">            rightup.<span class="built_in">erase</span>(row+column);</span><br><span class="line">            columns.<span class="built_in">erase</span>(column);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        chess.<span class="built_in">resize</span>(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="基于位运算的回溯"><a href="#基于位运算的回溯" class="headerlink" title="基于位运算的回溯"></a>基于位运算的回溯</h2><p>前一种使用集合来记录三个方向是否可以放置皇后，这里用三个数通过位运算来表示，<br>可以将判断是否能放皇后的空间复杂度从O(N)降低为O(1)</p>
<p>TODO </p>
<h1 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a>52. N皇后 II</h1><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 4<br>输出：2<br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br>示例 2：</p>
<p>输入：n = 1<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 9</p>
<h2 id="基于集合的回溯-1"><a href="#基于集合的回溯-1" class="headerlink" title="基于集合的回溯"></a>基于集合的回溯</h2><p>思路同上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="comment">// 分别记录左上方、右上方、垂直方向三条线的值</span></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; leftup;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; rightup;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; columns;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; column++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftup.<span class="built_in">find</span>(row-column) != leftup.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (rightup.<span class="built_in">find</span>(row+column) != rightup.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (columns.<span class="built_in">find</span>(column) != columns.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            leftup.<span class="built_in">insert</span>(row-column);</span><br><span class="line">            rightup.<span class="built_in">insert</span>(row+column);</span><br><span class="line">            columns.<span class="built_in">insert</span>(column);</span><br><span class="line">            <span class="built_in">backtrack</span>(row+<span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">//还原现场</span></span><br><span class="line">            leftup.<span class="built_in">erase</span>(row-column);</span><br><span class="line">            rightup.<span class="built_in">erase</span>(row+column);</span><br><span class="line">            columns.<span class="built_in">erase</span>(column);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>295. 数据流的中位数</title>
    <url>/2022/05/24/leetcode-find-median-from-data-stream/</url>
    <content><![CDATA[<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例：</p>
<p>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2<br>进阶:</p>
<p>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p>
<hr>
<h1 id="两个堆"><a href="#两个堆" class="headerlink" title="两个堆"></a>两个堆</h1><p>时间复杂度主要是优先队列调整的时间O(logn)<br>空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    <span class="comment">// 建立一个大顶堆 一个小顶堆，大顶堆存储小于中位数的数，小顶堆存储大于中位数的数</span></span><br><span class="line">    <span class="comment">// 如 bigHeap存储1-100，smallHeap存储101-200</span></span><br><span class="line">    <span class="comment">// 保证大顶堆的数比小顶堆的数多的不超过1</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; bigHeap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; smallHeap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            bigHeap.<span class="built_in">emplace</span>(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= bigHeap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            smallHeap.<span class="built_in">emplace</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (smallHeap.<span class="built_in">size</span>() &gt; bigHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                bigHeap.<span class="built_in">emplace</span>(smallHeap.<span class="built_in">top</span>());</span><br><span class="line">                smallHeap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            bigHeap.<span class="built_in">emplace</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (bigHeap.<span class="built_in">size</span>() &gt; smallHeap.<span class="built_in">size</span>()+<span class="number">1</span>)&#123;</span><br><span class="line">                smallHeap.<span class="built_in">emplace</span>(bigHeap.<span class="built_in">top</span>());</span><br><span class="line">                bigHeap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右堆的大小一样，即数的个数为偶数</span></span><br><span class="line">        <span class="keyword">if</span> (bigHeap.<span class="built_in">size</span>() == smallHeap.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> bigHeap.<span class="built_in">top</span>() + (smallHeap.<span class="built_in">top</span>()-bigHeap.<span class="built_in">top</span>())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bigHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h1 id="有序集合-双指针"><a href="#有序集合-双指针" class="headerlink" title="有序集合+双指针"></a>有序集合+双指针</h1><p>时间复杂度同样是O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator left, right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() : <span class="built_in">left</span>(nums.<span class="built_in">end</span>()), <span class="built_in">right</span>(nums.<span class="built_in">end</span>()) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            left = right = nums.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n&amp;<span class="number">1</span>) &#123;     <span class="comment">//集合元素个数原本为奇数</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt;= *right)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;      <span class="comment">//原本为偶数，这时再加一个数，则left和right会指向中间同一个数</span></span><br><span class="line">            <span class="comment">// 有序集合的特点是，如果数相等，新数会在旧数的右边</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt;= *right)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*left+*right)/<span class="number">2.0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<p>进阶 11<br>如果数据流中所有整数都在 00 到 100100 范围内，那么我们可以利用计数排序统计每一类数的数量，并使用双指针维护中位数。</p>
<p>进阶 22<br>如果数据流中 99%99% 的整数都在 00 到 100100 范围内，那么我们依然利用计数排序统计每一类数的数量，并使用双指针维护中位数。对于超出范围的数，我们可以单独进行处理，建立两个数组，分别记录小于 00 的部分的数的数量和大于 100100 的部分的数的数量即可。当小部分时间，中位数不落在区间 [0,100][0,100] 中时，我们在对应的数组中暴力检查即可。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 正则表达式匹配&amp;44. 通配符匹配</title>
    <url>/2022/05/23/leetcode-regular-expression-matching/</url>
    <content><![CDATA[<h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p> <br>示例 1：</p>
<p>输入：s = “aa”, p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入：s = “aa”, p = “a*”<br>输出：true<br>解释：因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3：</p>
<p>输入：s = “ab”, p = “.<em>“<br>输出：true<br>解释：”.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）</p>
<hr>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>dp[i][j]表示s的前i个字符和p的前j个字符是否匹配。<br>若p[j-1] != ‘<em>‘, 则看对应字符是否相等；<br>若p[j-1] == ‘</em>‘, 则需要考虑2种情况：</p>
<ul>
<li>p[j-2] == s[i-1], 也就是*前一个字符是否和s对应字符匹配，若匹配则可以匹配1次或多次。其中匹配1次，可以被多次+0次合并。</li>
<li>p[j-2] != s[i-2], 不匹配，则<em>只能表示匹配0次，消去</em>前一个字符，再比较。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断s中第i个字符和p中第j个字符是否匹配</span></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="comment">// s的第0个字符不存在，s为空字符串，j不为空，肯定无法匹配</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 若p[j-2]与s[i-1]不等，可考虑将p[j-2]去掉</span></span><br><span class="line">                    dp[i][j] |= dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="comment">// 若相等，则可以用*替换多次</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j<span class="number">-1</span>)) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j)) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a>44. 通配符匹配</h1><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “<em>“<br>输出: true<br>解释: ‘</em>‘ 可以匹配任意字符串。<br>示例 3:</p>
<p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。<br>示例 4:</p>
<p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.<br>示例 5:</p>
<p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输出: false</p>
<hr>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>dp[i][j]表示s的前i个字符和p的前j个字符是否匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 均为空串时为true</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// s为空串时，*只能匹配空串，所以只有p为任意个*时才为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// *可以匹配s中的一个字符，也可以不匹配(空串)</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] | dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// p为万能符号？或二者对应字符相等</span></span><br><span class="line">                    <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">&#x27;?&#x27;</span> || p[j<span class="number">-1</span>] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>189. 轮转数组</title>
    <url>/2022/05/22/leetcode-rotate-array/</url>
    <content><![CDATA[<p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入：nums = [-1,-100,3,99], k = 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 105<br>-231 &lt;= nums[i] &lt;= 231 - 1<br>0 &lt;= k &lt;= 105
 </p>
<p>进阶：</p>
<p>尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p>
<hr>
<h1 id="三次翻转数组"><a href="#三次翻转数组" class="headerlink" title="三次翻转数组"></a>三次翻转数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line">            k = k % n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="使用额外的临时数组"><a href="#使用额外的临时数组" class="headerlink" title="使用额外的临时数组"></a>使用额外的临时数组</h1><p>但是空间复杂度为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line">            k = k % n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[(i+k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="环形数组"><a href="#环形数组" class="headerlink" title="环形数组"></a>环形数组</h1><p>不使用额外数组，一个个的将每一个数依次放到最终的位置。需要移动n次<br>时间复杂度O(n), 空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line">            k = k % n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % n;</span><br><span class="line">                <span class="built_in">swap</span>(nums[current], nums[start]);</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(current != start);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以通过最大公约数控制循环结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line">            k = k % n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//count为轮次，gcd表示两个数的最大公约数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="built_in">gcd</span>(n,k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; count; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % n;</span><br><span class="line">                <span class="built_in">swap</span>(nums[current], nums[start]);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125;<span class="keyword">while</span>(current != start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>1277. 统计全为 1 的正方形子矩阵</title>
    <url>/2022/05/20/leetcode-count-square-submatrices-with-all-ones/</url>
    <content><![CDATA[<p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix =<br>[<br>  [0,1,1,1],<br>  [1,1,1,1],<br>  [0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。<br>正方形的总数 = 10 + 4 + 1 = 15.<br>示例 2：</p>
<p>输入：matrix =<br>[<br>  [1,0,1],<br>  [1,1,0],<br>  [1,1,0]<br>]<br>输出：7<br>解释：<br>边长为 1 的正方形有 6 个。<br>边长为 2 的正方形有 1 个。<br>正方形的总数 = 6 + 1 = 7.</p>
<hr>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>记录dp[i][j]为以右下角为(i,j)的矩形的最大边长，则dp[i][j]也表示以右下角为(i,j)的矩形的个数</p>
<p>遍历每个dp值，并求和即为所有正方形的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正方形和最大矩形</title>
    <url>/2022/05/18/leetcode-maximal-square/</url>
    <content><![CDATA[<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h1><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<p>示例 1：<br>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p>
<p>示例 2：<br>输入：matrix = [[“0”,”1”],[“1”,”0”]]<br>输出：1</p>
<p>示例 3：<br>输入：matrix = [[“0”]]<br>输出：0</p>
<hr>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>时间复杂度O(m<em>n</em>min(m,n)^2), 时间超限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> current = <span class="built_in">min</span>(rows-i, columns-j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; current; k++) &#123;</span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i+k][j+k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i+k][j+m] == <span class="string">&#x27;0&#x27;</span> || matrix[i+m][j+k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, k+<span class="number">1</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>考虑记录dp[i][j]以(i,j)为右下角且只包含1的正方形的边长大小，则：</p>
<ol>
<li>当i==0或j==0即边界时，dp[i][j] = 1, </li>
<li>dp[i][j]与左边，上边，左上角三个位置的dp有关</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>示例 1:<br>输入：heights = [2,1,5,6,2,3]<br>输出：10<br>解释：最大的矩形为图中红色区域，面积为 10</p>
<p>示例 2：<br>输入： heights = [2,4]<br>输出： 4</p>
<hr>
<h2 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h2><p>矩形面积等于 底*高，程序计算的时候，需要固定一个然后遍历另一个。<br>我们固定高的思路：<br>对于每一个柱形i，从i向两边遍历，直到严格小于该柱形的边界，则中间部分为底边。</p>
<p>但是无法通过OJ</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="keyword">int</span> left = i<span class="number">-1</span>, right = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i])&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; heights[right] &gt;= heights[i]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; heights[i] &lt;&lt; endl;</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right-left<span class="number">-1</span>)*heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>维持高度值严格单调递增的栈，方便寻找每个柱子的左边界和右边界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; mono_stack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找每个柱子左侧第一次低于这个柱子的序号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i])&#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>();</span><br><span class="line">            mono_stack.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找每个柱子右侧第一次低于这个柱子的序号</span></span><br><span class="line">        mono_stack = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i])&#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = mono_stack.<span class="built_in">empty</span>() ? n : mono_stack.<span class="built_in">top</span>();</span><br><span class="line">            mono_stack.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i]-left[i]<span class="number">-1</span>)*heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>做一些常数项的优化，将寻找右边界合并。<br>注意初始化right默认值为n，因为有可能部分值最后未出栈，右边界为n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; mono_stack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找每个柱子左侧第一次低于这个柱子的序号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i])&#123;</span><br><span class="line">                <span class="comment">// 一个数被弹出时，说明刚好待进栈的数小于栈顶元素。如果存在相同高度，此时边界可能会有差异，但不影响最终值</span></span><br><span class="line">                right[mono_stack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>();</span><br><span class="line">            mono_stack.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i]-left[i]<span class="number">-1</span>)*heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h1><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：6<br>解释：最大矩形如上图所示。<br>示例 2：</p>
<p>输入：matrix = []<br>输出：0<br>示例 3：</p>
<p>输入：matrix = [[“0”]]<br>输出：0<br>示例 4：</p>
<p>输入：matrix = [[“1”]]<br>输出：1<br>示例 5：</p>
<p>输入：matrix = [[“0”,”0”]]<br>输出：0</p>
<hr>
<h1 id="转化为柱形图"><a href="#转化为柱形图" class="headerlink" title="转化为柱形图"></a>转化为柱形图</h1><p>借鉴【柱状图中最大矩形】的思路，将矩形转化为柱状图，然后计算，可得到解。<br>时间复杂度为O(m<em>n</em>min(m, n))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">height</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 构建柱状图，当然也可以横着构建</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    height[i][j] = i == <span class="number">0</span> ?  <span class="number">1</span> : height[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="comment">// 一行一行的遍历柱状图，固定h，两边搜索最大矩形的左和右边界。</span></span><br><span class="line">                <span class="keyword">int</span> left = j<span class="number">-1</span>, right = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> h = height[i][j];</span><br><span class="line">                <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; height[i][left] &gt;= h) &#123;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; columns &amp;&amp; height[i][right] &gt;= h) &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; h &lt;&lt; endl;</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right-left<span class="number">-1</span>)*h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="柱状图-单调栈"><a href="#柱状图-单调栈" class="headerlink" title="柱状图+单调栈"></a>柱状图+单调栈</h1><p>与上一题类似，寻找左右边界的过程可以使用单调栈优化，空间换时间</p>
<p>时间复杂度O(m*n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">height</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    height[i][j] = i == <span class="number">0</span> ?  <span class="number">1</span> : height[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(columns, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(columns, columns)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; height[i][mono_stack.<span class="built_in">top</span>()] &gt;= height[i][j]) &#123;</span><br><span class="line">                    right[mono_stack.<span class="built_in">top</span>()] = j;</span><br><span class="line">                    mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>();</span><br><span class="line">                mono_stack.<span class="built_in">emplace</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right[j]-left[j]<span class="number">-1</span>)*height[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意每一行计算后初始化中间变量</span></span><br><span class="line">            mono_stack = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            left = vector&lt;<span class="keyword">int</span>&gt;(columns, <span class="number">0</span>);</span><br><span class="line">            right = vector&lt;<span class="keyword">int</span>&gt;(columns, columns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/2022/05/18/leetcode-number-of-1-bits/</url>
    <content><![CDATA[<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<p> </p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
 </p>
<p>示例 1：</p>
<p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p>
<p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p>
<p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
<hr>
<h1 id="位运算顺序判断每一个二进制位"><a href="#位运算顺序判断每一个二进制位" class="headerlink" title="位运算顺序判断每一个二进制位"></a>位运算顺序判断每一个二进制位</h1><p>时间复杂度O(K)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="利用n-amp-n-1-运算的特点"><a href="#利用n-amp-n-1-运算的特点" class="headerlink" title="利用n&amp;(n-1)运算的特点"></a>利用n&amp;(n-1)运算的特点</h1><p>时间复杂度O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 运算n&amp;(n-1)的结果就是把n的二进制位中的最后一个1变为0</span></span><br><span class="line">            n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bit</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <url>/2022/05/15/leetcode-reversePairs/</url>
    <content><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [7,5,6,4]<br>输出: 5</p>
<hr>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>时间复杂度O(n^2), 无法通过OJ</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>两个有序数组merge的时候, 当将要选右边数组合并到新数组时，被选中的这个数比左半数组中的数都要小，<br>此时逆序对数增加为左边数组中的长度。</p>
<p>时间复杂度O(nlogn)<br>空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//如果拆分后的两部分已经有序，则不用merge</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">merge</span>(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[left, mid], [mid+1, right]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += mid-i+<span class="number">1</span>;</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            tmp.<span class="built_in">emplace_back</span>(nums[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j=<span class="number">0</span>; i &lt;= right; i++,j++) &#123;</span><br><span class="line">            nums[i] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>临时数组仅申请一次，降低中间申请销毁的时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//如果拆分后的两部分已经有序，则不用merge</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">merge</span>(nums, tmp, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[left, mid], [mid+1, right]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k=left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += mid-i+<span class="number">1</span>;</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>()+left, tmp.<span class="built_in">begin</span>()+right+<span class="number">1</span>, nums.<span class="built_in">begin</span>()+left);</span><br><span class="line">        <span class="comment">// for (int i = left,k=left; i &lt;= right; i++,k++) &#123;</span></span><br><span class="line">        <span class="comment">//     nums[i] = tmp[k];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="离散化树状数组"><a href="#离散化树状数组" class="headerlink" title="离散化树状数组"></a>离散化树状数组</h1><p>TODO </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>76. 最小覆盖子串</title>
    <url>/2022/05/14/leetcode-minimum-window-substring/</url>
    <content><![CDATA[<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p> </p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。
 </p>
<p>示例 1：</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：</p>
<p>输入：s = “a”, t = “a”<br>输出：”a”<br>示例 3:</p>
<p>输入: s = “a”, t = “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p>
<hr>
<h1 id="双指针方案"><a href="#双指针方案" class="headerlink" title="双指针方案"></a>双指针方案</h1><p>核心问题是判断窗口内的子串是否覆盖了目标串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mapT, mapS;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || sLen &lt; tLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : t) &#123;</span><br><span class="line">            ++mapT[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>,count=sLen+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// distance记录滑动窗口内部包含的t中的元素的个数, 若窗口中某个字符个数超过t中该元素的个数，distance不增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; sLen) &#123;</span><br><span class="line">            <span class="comment">// 右指针右移，如果字符不在t中，则指针继续右移，直到碰到t中的字符。</span></span><br><span class="line">            <span class="keyword">if</span> (mapT[s[right]] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个字符在滑动窗口内的个数小于需要的个数，则表明此时右移对结果有帮助，distance加1</span></span><br><span class="line">            <span class="keyword">if</span> (mapS[s[right]] &lt; mapT[s[right]]) &#123;</span><br><span class="line">                distance++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新窗口中字符的个数，然后右指针继续右移</span></span><br><span class="line">            ++mapS[s[right]];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当distance和t的长度一致，说明碰到了一个可能的解</span></span><br><span class="line">            <span class="keyword">while</span> (distance == tLen) &#123;</span><br><span class="line">                <span class="comment">// 判断是否是最优解并更新</span></span><br><span class="line">                <span class="keyword">if</span> (right-left &lt; count) &#123;</span><br><span class="line">                    begin = left;</span><br><span class="line">                    count = right-left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果左指针对应字符不是需要的元素，则指针右移</span></span><br><span class="line">                <span class="keyword">if</span> (mapT[s[left]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左指针右移的时候，窗口中字符个数在减少，当字符为需要字符且个数不多时，左指针继续右移会让距离减1</span></span><br><span class="line">                <span class="keyword">if</span> (mapS[s[left]] == mapT[s[left]]) &#123;</span><br><span class="line">                    distance--;</span><br><span class="line">                &#125;</span><br><span class="line">                --mapS[s[left]];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; count;</span></span><br><span class="line">        <span class="comment">// 若count未更新</span></span><br><span class="line">        <span class="keyword">if</span> (count == sLen+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>983. 最低票价</title>
    <url>/2022/05/13/leetcode-minimum-cost-for-tickets/</url>
    <content><![CDATA[<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有 三种不同的销售方式 ：</p>
<p>一张 为期一天 的通行证售价为 costs[0] 美元；<br>一张 为期七天 的通行证售价为 costs[1] 美元；<br>一张 为期三十天 的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：days = [1,4,6,7,8,20], costs = [2,7,15]<br>输出：11<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。<br>在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, …, 9 天生效。<br>在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。<br>你总共花了 $11，并完成了你计划的每一天旅行。<br>示例 2：</p>
<p>输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]<br>输出：17<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, …, 30 天生效。<br>在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。<br>你总共花了 $17，并完成了你计划的每一天旅行。
 </p>
<p>提示：</p>
<p>1 &lt;= days.length &lt;= 365<br>1 &lt;= days[i] &lt;= 365<br>days 按顺序严格递增<br>costs.length == 3<br>1 &lt;= costs[i] &lt;= 1000</p>
<hr>
<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>需要从第1天开始遍历到第365天，时间复杂度为O(M)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; daySet;</span><br><span class="line">    <span class="comment">// dp[i]表示从第i天的这一年开始旅行需要的总开销</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, vector&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">365</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (daySet.<span class="built_in">count</span>(i) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(<span class="built_in">dp</span>(i+<span class="number">1</span>, costs)+costs[<span class="number">0</span>], <span class="built_in">dp</span>(i+<span class="number">7</span>, costs)+costs[<span class="number">1</span>]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dp</span>(i+<span class="number">30</span>, costs)+costs[<span class="number">2</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="built_in">dp</span>(i+<span class="number">1</span>, costs);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; days, vector&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        memo = vector&lt;<span class="keyword">int</span>&gt;(<span class="number">366</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> day : days) &#123;</span><br><span class="line">            daySet.<span class="built_in">insert</span>(day);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(<span class="number">1</span>, costs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="优化的记忆化搜索"><a href="#优化的记忆化搜索" class="headerlink" title="优化的记忆化搜索"></a>优化的记忆化搜索</h1><p>其实没必要从1遍历到365，只需要遍历必须出行的那些天，即days数组的长度<br>时间复杂度为O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; costs;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; days;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; durations = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; daySet;</span><br><span class="line">    <span class="comment">// dp[i]表示从第days[i]天开始的这一年开始旅行需要的总开销</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= days.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; durations.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; days.<span class="built_in">size</span>() &amp;&amp; days[j] &lt; days[i] + durations[k]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">dp</span>(j)+costs[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; days, vector&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        memo = vector&lt;<span class="keyword">int</span>&gt;(days.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;costs = costs;</span><br><span class="line">        <span class="keyword">this</span>-&gt;days = days;</span><br><span class="line">        <span class="comment">// 此时要从days中的第0个数据开始处理。</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">dp</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>322. 零钱兑换</title>
    <url>/2022/05/12/leetcode-coin-change/</url>
    <content><![CDATA[<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins = [1], amount = 0<br>输出：0</p>
<hr>
<p>回溯算法时间复杂度为 O(S^n)会超时，需要更加高效的算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> index, <span class="keyword">int</span> count, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; ans) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; coins.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">backtrack</span>(coins, i, count, target-coins[i]);</span><br><span class="line">            count--;</span><br><span class="line">            <span class="built_in">backtrack</span>(coins, i+<span class="number">1</span>, count, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">backtrack</span>(coins, <span class="number">0</span>, <span class="number">0</span>, amount);</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>记录F(S)：组成金额 S 所需的最少硬币数量<br>最后一枚硬币面值为C，则F(S)=F(S−C)+1, C需要遍历并选择最小的F(S-C)</p>
<p>我们一共需要计算 S 个状态的答案，且每个状态 F(S) 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要枚举 n 个面额值，所以一共需要 O(Sn) 的时间复杂度。</p>
<p>自底向上计算叫动态规划，自顶向下叫记忆化搜索？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从0到amount共amount+1个数, 最大硬币个数不会超过amount/1=amount(硬币大小为1),</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>, amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>子集(系列)</title>
    <url>/2022/05/10/leetcode-subsets/</url>
    <content><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p>
<p>输入：nums = [0]<br>输出：[[],[0]]</p>
<hr>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>时间复杂度O(n*2^n), 2^n种状态，每种状态均需遍历一次数组<br>空间复杂度O(n), 存储临时变量数组path</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>假设有n位数，则每位选或不选用二进制数表示，刚好有2^n种选择。从0到2^n-1.<br>遍历每种选择，然后分别看这n个数是否该选进去，用按位或运算的方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; state; mask++) &#123;</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h1><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]<br>示例 2：</p>
<p>输入：nums = [0]<br>输出：[[],[0]]
 </p>
<h2 id="回溯法-1"><a href="#回溯法-1" class="headerlink" title="回溯法"></a>回溯法</h2><p>一般需要去重的时候，都需要先排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">bool</span> visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 若没有选上一个数，且当前数与上一个相等，则当前数也不能选</span></span><br><span class="line">        <span class="keyword">if</span> (!visited &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i+<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于，回溯，有两种写法，都可以，值得专题揣摩</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是全排列，则需要遍历完nums；此处是子集，每一次遍历结果都是子集</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 若上一个元素相同，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>大数操作</title>
    <url>/2022/05/09/leetcode/leetcode-multiply-strings/</url>
    <content><![CDATA[<h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：num1 = “11”, num2 = “123”<br>输出：”134”<br>示例 2：</p>
<p>输入：num1 = “456”, num2 = “77”<br>输出：”533”<br>示例 3：</p>
<p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = a + b + carry;</span><br><span class="line">            <span class="comment">// 余数保留，大于10进位</span></span><br><span class="line">            ans = <span class="built_in">to_string</span>(result % <span class="number">10</span>) + ans;</span><br><span class="line">            carry = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;i,j,carry&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; carry &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br>示例 2:</p>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">string <span class="title">add</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = a + b + carry;</span><br><span class="line">            ans = <span class="built_in">to_string</span>(result%<span class="number">10</span>) + ans;</span><br><span class="line">            carry = result/<span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = num1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> count = m - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                tmp += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> b = num2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> result = a * b + carry;</span><br><span class="line">                tmp = <span class="built_in">to_string</span>(result%<span class="number">10</span>) + tmp;</span><br><span class="line">                carry = result/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                tmp = <span class="built_in">to_string</span>(carry%<span class="number">10</span>) + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">            ans = <span class="built_in">add</span>(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种直接计算的方法</p>
<p>乘法的时候，长度为m、n的两个数相乘，结果最大为m+n+1位，两个位为i,j的数乘积所在的位置为i+j+1,进位在i+j</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = num1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ansArray</span><span class="params">(m+n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = num2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> result = a * b + ansArray[i+j+<span class="number">1</span>];</span><br><span class="line">                ansArray[i+j+<span class="number">1</span>] = (result % <span class="number">10</span>);</span><br><span class="line">                ansArray[i+j] += (result / <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansArray.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ansArray[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans += <span class="built_in">to_string</span>(ansArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>468. 验证IP地址</title>
    <url>/2022/05/08/leetcode/leetcode-validate-ip-address/</url>
    <content><![CDATA[<p>给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。</p>
<p>有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 &lt;= xi &lt;= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “<a href="mailto:&#49;&#57;&#x32;&#46;&#x31;&#54;&#56;&#64;&#49;&#46;&#x31;">&#49;&#57;&#x32;&#46;&#x31;&#54;&#56;&#64;&#49;&#46;&#x31;</a>” 为无效IPv4地址。</p>
<p>一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:</p>
<p>1 &lt;= xi.length &lt;= 4<br>xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( ‘a’ 到 ‘f’ )和大写英文字母( ‘A’ 到 ‘F’ )。<br>在 xi 中允许前导零。<br>例如 “2001:0db8:85a3:0000:0000:8a2e:0370:7334” 和 “2001:db8:85a3:0:0:8A2E:0370:7334” 是有效的 IPv6 地址，而 “2001:0db8:85a3::8A2E:037j:7334” 和 “02001:0db8:85a3:0000:0000:8a2e:0370:7334” 是无效的 IPv6 地址。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：queryIP = “172.16.254.1”<br>输出：”IPv4”<br>解释：有效的 IPv4 地址，返回 “IPv4”<br>示例 2：</p>
<p>输入：queryIP = “2001:0db8:85a3:0:0:8A2E:0370:7334”<br>输出：”IPv6”<br>解释：有效的 IPv6 地址，返回 “IPv6”<br>示例 3：</p>
<p>输入：queryIP = “256.256.256.256”<br>输出：”Neither”<br>解释：既不是 IPv4 地址，又不是 IPv6 地址</p>
<hr>
<p>非常好的细节题</p>
<p>IPv4:<br>1.用.切分后，需要有四部分<br>2.每个部分不为空、开头不为0、不超过3位数<br>3.每个部分的每个字符均为数字<br>4.每个部分的范围在0-255</p>
<p>IPv6:</p>
<ol>
<li>用:切分后，需要有8部分</li>
<li>每个部分的长度不为空且不超过4</li>
<li>每个部分的每个字符在0-9、a-f、A-F之间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void split(string&amp; s, vector&lt;string&gt;&amp; items, char ch) &#123;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        string tmp;</span><br><span class="line">        while (ss.good())&#123;</span><br><span class="line">            getline(ss, tmp, ch);</span><br><span class="line">            items.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool validIPv4(string queryIP) &#123;</span><br><span class="line">        vector&lt;string&gt; parts;</span><br><span class="line">        split(queryIP, parts, &#x27;.&#x27;);</span><br><span class="line">        if (parts.size() != 4) return false;</span><br><span class="line">        for (auto &amp;part : parts)&#123;</span><br><span class="line">            if (part.size() == 0 || (part.size()&gt;1 &amp;&amp; part[0] == &#x27;0&#x27;) || part.size() &gt; 3) return false;</span><br><span class="line">            for(char c:part)&#123;</span><br><span class="line">                if(!isdigit(c))return false;</span><br><span class="line">            &#125;</span><br><span class="line">            int partNum = stoi(part);</span><br><span class="line">            if (partNum &lt; 0 || partNum &gt; 255)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool validIPv6(string queryIP) &#123;</span><br><span class="line">        vector&lt;string&gt; parts;</span><br><span class="line">        split(queryIP, parts, &#x27;:&#x27;);</span><br><span class="line">        if (parts.size() != 8) return false;</span><br><span class="line">        for (string &amp;part : parts)&#123;</span><br><span class="line">            if (part.size() == 0 || part.size() &gt; 4) return false;</span><br><span class="line">            for (auto &amp;ch : part)&#123;</span><br><span class="line">                if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) continue;</span><br><span class="line">                else if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;f&#x27;) continue;</span><br><span class="line">                else if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;F&#x27;) continue;</span><br><span class="line">                else return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    string validIPAddress(string queryIP) &#123;</span><br><span class="line">        if (validIPv4(queryIP)) return &quot;IPv4&quot;;</span><br><span class="line">        else if (validIPv6(queryIP)) return &quot;IPv6&quot;;</span><br><span class="line">        else return &quot;Neither&quot;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>179. 最大数</title>
    <url>/2022/05/08/leetcode/leetcode-largest-number/</url>
    <content><![CDATA[<p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [10,2]<br>输出：”210”<br>示例 2：</p>
<p>输入：nums = [3,30,34,5,9]<br>输出：”9534330”</p>
<h1 id="排序后直接拼接"><a href="#排序后直接拼接" class="headerlink" title="排序后直接拼接"></a>排序后直接拼接</h1><p>核心在于需要重新定义排序的比较函数。也可以转换为字符串后比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)&#123;</span><br><span class="line">            <span class="comment">// 注意fx、fy为long int</span></span><br><span class="line">            <span class="keyword">long</span> fx = <span class="number">10</span>, fy = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span> (fx &lt;= x)&#123;</span><br><span class="line">                fx *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (fy &lt;= y)&#123;</span><br><span class="line">                fy *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fy * x + y &gt; fx * y + x;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums)&#123;</span><br><span class="line">            ans += <span class="built_in">to_string</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>543. 二叉树的直径</title>
    <url>/2022/05/08/leetcode/leetcode-diameter-of-binary-tree/</url>
    <content><![CDATA[<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p> </p>
<p>示例 :<br>给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<hr>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>直径就是两个节点路径长度的最大值。</p>
<p>每个路径长度可以拆解为左子树和右子树的深度两部分之和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">depth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">depth</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, l + r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="NC99-多叉树的直径"><a href="#NC99-多叉树的直径" class="headerlink" title="NC99 多叉树的直径"></a>NC99 多叉树的直径</h1><p>如果换成多叉树，该如何处理呢？</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题-圆圈中最后剩下的数字</title>
    <url>/2022/05/08/leetcode/leetcode-yosef-problem/</url>
    <content><![CDATA[<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: n = 5, m = 3<br>输出: 3<br>示例 2：</p>
<p>输入: n = 10, m = 17<br>输出: 2</p>
<p>这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个</p>
<hr>
<p>真是一个有趣的故事</p>
<p>首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。<br>那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p>
<p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。<br>当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 f(n, m) = (m % n + x) % n = (m + x) % n。</p>
<p>假设初始只有1个人，序号为0，则只能选0。<br>假设第n-1次选中x，则第n次会选中(x+m)%n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n; i++)&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i-1 &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">            x = (x + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>128. 最长连续序列</title>
    <url>/2022/05/07/leetcode/leetcode-longest-consecutive-sequence/</url>
    <content><![CDATA[<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。<br>示例 2：</p>
<p>输入：nums = [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p>
<hr>
<p>直观想法是分别遍历每个数x，然后看x+1, x+2, …等数是否在数组中，若在则连续序列长度加1。</p>
<p>使用哈希表提高查找效率，同时，若x-1已经做过判断，则x无需再判断。</p>
<p>这样，平均每个元素只会访问一次，时间复杂度O(n)<br>空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;num : nums)&#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : num_set)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.<span class="built_in">count</span>(num<span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = num; num_set.<span class="built_in">count</span>(i); i++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的第K大节点</title>
    <url>/2022/05/04/leetcode/leetcode-kthLargest-of-BST/</url>
    <content><![CDATA[<p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 4<br>示例 2:</p>
<p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 4</p>
<hr>
<h1 id="中序遍历然后取倒数第k个数"><a href="#中序遍历然后取倒数第k个数" class="headerlink" title="中序遍历然后取倒数第k个数"></a>中序遍历然后取倒数第k个数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, ans);</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, result);</span><br><span class="line">        <span class="keyword">int</span> n = result.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>略微优化, 直接一次遍历搞定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (--left == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        left = k;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>297. 二叉树的序列化与反序列化</title>
    <url>/2022/05/04/leetcode/leetcode-serialize-and-deserialize-binary-tree/</url>
    <content><![CDATA[<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<hr>
<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>可以深度优先或广度优先</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">realSerialize</span><span class="params">(TreeNode* root, string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            str += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            <span class="built_in">realSerialize</span>(root-&gt;left, str);</span><br><span class="line">            <span class="built_in">realSerialize</span>(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">realSerialize</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">realDeserialize</span><span class="params">(list&lt;string&gt;&amp; dataArray)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataArray.<span class="built_in">front</span>() == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">            dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(dataArray.<span class="built_in">front</span>()));</span><br><span class="line">        dataArray.<span class="built_in">erase</span>(dataArray.<span class="built_in">begin</span>());</span><br><span class="line">        root-&gt;left = <span class="built_in">realDeserialize</span>(dataArray);</span><br><span class="line">        root-&gt;right = <span class="built_in">realDeserialize</span>(dataArray);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        list&lt;string&gt; dataArray;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : data)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                dataArray.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            dataArray.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">realDeserialize</span>(dataArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h1 id="方法二：括号表示编码-递归下降解码"><a href="#方法二：括号表示编码-递归下降解码" class="headerlink" title="方法二：括号表示编码 + 递归下降解码"></a>方法二：括号表示编码 + 递归下降解码</h1><p>TODO </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>887. 鸡蛋掉落</title>
    <url>/2022/05/04/leetcode/leetcode-super-egg-drop/</url>
    <content><![CDATA[<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p>
<p> <br>示例 1：</p>
<p>输入：k = 1, n = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。<br>如果它没碎，那么肯定能得出 f = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。<br>示例 2：</p>
<p>输入：k = 2, n = 6<br>输出：3<br>示例 3：</p>
<p>输入：k = 3, n = 14<br>输出：4</p>
<hr>
<p>听说是原谷歌经典面试题, </p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>考虑特殊情况：</p>
<ul>
<li>有任意个鸡蛋，直接用二分法</li>
<li>有1个鸡蛋，只能从低到高一层楼一层楼的遍历</li>
<li>有2个鸡蛋，100层楼，可以考虑分10层，这样最大需要19次，也可以考虑让第一个鸡蛋和第二个鸡蛋最大尝试次数之和均匀一点，</li>
<li>有k个鸡蛋，n层楼，dp[k, n]。选择任意扔鸡蛋的位置为x，则有两种情况且：<ul>
<li>鸡蛋碎了，则消耗一个鸡蛋，答案在x层下方的x-1楼层中。t1 = dp[k-1, x-1]</li>
<li>鸡蛋没碎，则消耗0个鸡蛋，答案在x层上方剩下的n-x楼层中。t2 = dp[k, n-x]</li>
</ul>
</li>
</ul>
<p>接下来就是寻找x的位置，然后计算每个x的取值情况下的最小值。</p>
<p>关于x的函数t1和t2, t1单调递增，t2单调递减，二者分段函数的最小值在交点处，考虑离散函数特点，选交点左右两个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(n*<span class="number">100</span>+k) == memo.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">                ans = n;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                ans = n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">                <span class="keyword">while</span> (low + <span class="number">1</span> &lt; high)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = <span class="built_in">dp</span>(k<span class="number">-1</span>, mid<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = <span class="built_in">dp</span>(k, n-mid);</span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2)&#123;</span><br><span class="line">                        low = mid;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 &gt; t2)&#123;</span><br><span class="line">                        high = mid;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        low = high = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;low-high:&quot; &lt;&lt; low &lt;&lt; &quot; &quot; &lt;&lt; high &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// 抛鸡蛋的最佳点在low或high中之一</span></span><br><span class="line">                ans = <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">dp</span>(k<span class="number">-1</span>, low<span class="number">-1</span>), <span class="built_in">dp</span>(k, n-low)), <span class="built_in">max</span>(<span class="built_in">dp</span>(k<span class="number">-1</span>, high<span class="number">-1</span>), <span class="built_in">dp</span>(k, n-high)));</span><br><span class="line">            &#125;</span><br><span class="line">            memo[n*<span class="number">100</span>+k] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n*<span class="number">100</span>+k];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(k, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="方法二：决策单调性"><a href="#方法二：决策单调性" class="headerlink" title="方法二：决策单调性"></a>方法二：决策单调性</h1><h1 id="方法三：数学法"><a href="#方法三：数学法" class="headerlink" title="方法三：数学法"></a>方法三：数学法</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找以及多种变形</title>
    <url>/2022/05/03/leetcode/leetcode-binary-search/</url>
    <content><![CDATA[<h1 id="原始题"><a href="#原始题" class="headerlink" title="原始题"></a>原始题</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:<br>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:<br>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1
 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) /<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span> </span><br><span class="line">        right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
 </p>
<p>示例 1：</p>
<p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums = [], target = 0<br>输出：[-1,-1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">-1</span>, end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;begin,end&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                begin = mid;</span><br><span class="line">                end = mid;</span><br><span class="line">                <span class="keyword">while</span> (begin &gt;= <span class="number">0</span> &amp;&amp; nums[begin] == target)&#123;</span><br><span class="line">                    begin = begin - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (end &lt; n &amp;&amp; nums[end] == target)&#123;</span><br><span class="line">                    end = end + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;begin+<span class="number">1</span>,end<span class="number">-1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums = [1,3,5,6], target = 7<br>输出: 4</p>
<hr>
<p>寻找第一个大于等于目标值的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; low &lt;&lt; &quot; &quot; &lt;&lt; high &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 最终low == high + 1</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p> <br>示例 1：</p>
<p>输入：n = 5, bad = 4<br>输出：4<br>解释：<br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br>所以，4 是第一个错误的版本。<br>示例 2：</p>
<p>输入：n = 1, bad = 1<br>输出：1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid))&#123;</span><br><span class="line">                <span class="keyword">while</span> (mid &gt;=<span class="number">0</span> &amp;&amp; <span class="built_in">isBadVersion</span>(mid))&#123;</span><br><span class="line">                    mid = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>寻找第一个错误的版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid))&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终low = high + 1</span></span><br><span class="line">        <span class="keyword">return</span> high+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a>374. 猜数字大小</h1><p>猜数字游戏的规则如下：</p>
<p>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。<br>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>
<p>-1：我选出的数字比你猜的数字小 pick &lt; num<br>1：我选出的数字比你猜的数字大 pick &gt; num<br>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num<br>返回我选出的数字。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 10, pick = 6<br>输出：6<br>示例 2：</p>
<p>输入：n = 1, pick = 1<br>输出：1<br>示例 3：</p>
<p>输入：n = 2, pick = 1<br>输出：1<br>示例 4：</p>
<p>输入：n = 2, pick = 2<br>输出：2</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * @param  num   your guess</span></span><br><span class="line"><span class="comment"> * @return 	     -1 if num is lower than the guess number</span></span><br><span class="line"><span class="comment"> *			      1 if num is higher than the guess number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> guess_tmp = <span class="built_in">guess</span>(mid);</span><br><span class="line">            <span class="keyword">if</span> (guess_tmp == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (guess_tmp == <span class="number">-1</span>)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="658-找到-K-个最接近的元素"><a href="#658-找到-K-个最接近的元素" class="headerlink" title="658. 找到 K 个最接近的元素"></a>658. 找到 K 个最接近的元素</h1><p>给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。</p>
<p>整数 a 比整数 b 更接近 x 需要满足：</p>
<p>|a - x| &lt; |b - x| 或者<br>|a - x| == |b - x| 且 a &lt; b
 </p>
<p>示例 1：</p>
<p>输入：arr = [1,2,3,4,5], k = 4, x = 3<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：arr = [1,2,3,4,5], k = 4, x = -1<br>输出：[1,2,3,4]
 </p>
<p>提示：</p>
<p>1 &lt;= k &lt;= arr.length<br>1 &lt;= arr.length &lt;= 104<br>arr 按 升序 排列<br>-104 &lt;= arr[i], x &lt;= 104</p>
<hr>
<p>二分然后双指针<br>时间复杂度O(logn + k)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= arr.<span class="built_in">front</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>()+k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= arr.<span class="built_in">back</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(arr.<span class="built_in">end</span>()-k, arr.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= arr[mid])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; low &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 结果必然在[low-k-1, low+k-1]之间</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="built_in">max</span>(<span class="number">0</span>, low<span class="number">-1</span>-k);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in">min</span>(low+k<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (end - begin + <span class="number">1</span> &gt; k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[begin]-x) &lt;= <span class="built_in">abs</span>(arr[end]-x))&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(arr.<span class="built_in">begin</span>()+begin, arr.<span class="built_in">begin</span>()+end+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p>
<p>输入：nums = [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="keyword">int</span> i) -&gt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">-1</span> || i == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">1</span>, nums[i]&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; low &lt;&lt; &quot; &quot; &lt;&lt; high &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(mid<span class="number">-1</span>) &lt; <span class="built_in">get</span>(mid) &amp;&amp; <span class="built_in">get</span>(mid) &gt; <span class="built_in">get</span>(mid+<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(mid) &lt; <span class="built_in">get</span>(mid+<span class="number">1</span>)) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852. 山脉数组的峰顶索引"></a>852. 山脉数组的峰顶索引</h1><p>符合下列属性的数组 arr 称为 山脉数组 ：<br>arr.length &gt;= 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]<br>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]<br>给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：arr = [0,1,0]<br>输出：1<br>示例 2：</p>
<p>输入：arr = [0,2,1,0]<br>输出：1<br>示例 3：</p>
<p>输入：arr = [0,10,5,2]<br>输出：1<br>示例 4：</p>
<p>输入：arr = [3,4,5,1]<br>输出：2<br>示例 5：</p>
<p>输入：arr = [24,69,100,99,79,78,67,36,26,19]<br>输出：2</p>
<hr>
<p>此题与寻找峰值一题比较相似，但是此题只存在一个解。</p>
<p>上一题的答案可以直接用，并且可以无需考虑边界问题了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; low &lt;&lt; &quot; &quot; &lt;&lt; high &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid<span class="number">-1</span>] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>9. 回文数</title>
    <url>/2022/04/29/leetcode/leetcode-palindrome-number/</url>
    <content><![CDATA[<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>例如，121 是回文，而 123 不是。
 </p>
<p>示例 1：</p>
<p>输入：x = 121<br>输出：true<br>示例 2：</p>
<p>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3：</p>
<p>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。</p>
<h1 id="翻转一半的数"><a href="#翻转一半的数" class="headerlink" title="翻转一半的数"></a>翻转一半的数</h1><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int <span class="meta">x</span>) &#123;</span><br><span class="line">        <span class="meta">if</span> (<span class="meta">x</span> == 0)&#123;</span><br><span class="line">            <span class="meta">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">if</span> (<span class="meta">x</span> &lt; 0 || <span class="meta">x</span> % 10 == 0)&#123;</span><br><span class="line">            <span class="meta">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">        int revertedNum = 0;</span><br><span class="line">        <span class="meta">while</span> (<span class="meta">x</span> &gt; revertedNum)&#123;</span><br><span class="line">            revertedNum = revertedNum <span class="comment">* 10 + x % 10;</span></span><br><span class="line">            <span class="meta">x</span> = <span class="meta">x</span>/10;</span><br><span class="line">        &#125;</span><br><span class="line">        // cout &lt;&lt; <span class="meta">x</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; revertedNum &lt;&lt; endl;</span><br><span class="line">        <span class="meta">return</span> <span class="meta">x</span> == revertedNum || <span class="meta">x</span> == revertedNum/10;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 最长公共前缀</title>
    <url>/2022/04/27/leetcode/leetcode-longest-common-prefix/</url>
    <content><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：</p>
<p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。
 </p>
<hr>
<h1 id="每两个字符串合并"><a href="#每两个字符串合并" class="headerlink" title="每两个字符串合并"></a>每两个字符串合并</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            ans  = <span class="built_in">helper</span>(ans, strs[i]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">helper</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">min</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>()), index = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1[index] == str2[index])&#123;</span><br><span class="line">                index += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;---&quot; &lt;&lt; index &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].<span class="built_in">size</span>() || ch != strs[j][i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>32. 最长有效括号</title>
    <url>/2022/04/23/leetcode/leetcode-longest-valid-parentheses/</url>
    <content><![CDATA[<p>给你一个只包含 ‘(‘和 ‘)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p>示例 1：<br>输入：s = “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”</p>
<p>示例 2：<br>输入：s = “)()())”</p>
<p>输出：4<br>解释：最长有效括号子串是 “()()”</p>
<p>示例 3：<br>输入：s = “”<br>输出：0</p>
<hr>
<p>先做一个热身题</p>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s = “()”<br>输出：true<br>示例 2：</p>
<p>输入：s = “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s = “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s = “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s = “{[]}”<br>输出：true
 </p>
<h2 id="使用栈的方法"><a href="#使用栈的方法" class="headerlink" title="使用栈的方法"></a>使用栈的方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        pair = &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> pair.keys():</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">            <span class="keyword">elif</span> s[i] <span class="keyword">in</span> pair.values():</span><br><span class="line">                <span class="comment"># 可能只有右括号</span></span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    p = stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> pair[p] != s[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果还有多余的左括号，表示不合规</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; pair = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pair[ch])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记dp[i]为以序号i结尾的最长有效括号的长度。则有以下几种情况：</p>
<ul>
<li>以(结尾的串肯定不合法，直接赋0</li>
<li>以)结尾的串，分两种情况：<ul>
<li>如果s[i-1]为(, 则dp[i] = dp[i-2] + 2</li>
<li>如果s[i-1]为), 且dp[i-1]是一个有效的括号段，且这个括号段前一个元素是(, 则dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2</li>
</ul>
</li>
</ul>
<p>时间复杂度和空间复杂度均为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = (i &gt; <span class="number">2</span> ? dp[i<span class="number">-2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &gt; dp[i<span class="number">-1</span>] &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> part1 = i-dp[i<span class="number">-1</span>] &gt; <span class="number">2</span> ? dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] : <span class="number">0</span>;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + part1 + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto i : dp)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="栈的方法"><a href="#栈的方法" class="headerlink" title="栈的方法"></a>栈的方法</h1><p>保持栈顶元素为当前最后一个没有被匹配的右括号的下标。</p>
<p>若为左括号，则将其序号入栈<br>若为右括号，则先弹出栈顶元素，然后判断：</p>
<ul>
<li>若栈为空，则将当前i入栈</li>
<li>不为空，计算i-s.top()则为以该右括号结尾的最大有效括号的长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i-stk.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="两趟遍历"><a href="#两趟遍历" class="headerlink" title="两趟遍历"></a>两趟遍历</h1><p>不是很好理解，或者说有点巧妙</p>
<p>用两个计数器left和right分别记录左括号和右括号的个数。两次扫描</p>
<ol>
<li>先从左到右扫描，<ul>
<li>如果left与right相等, 记录差值</li>
<li>如果left &lt; right, 计数器清零</li>
</ul>
</li>
<li>从右到左扫描，<ul>
<li>如果left与right相等, 记录差值</li>
<li>如果left &gt; right, 计数器清零</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s.size() &lt;&lt; &quot; &quot; &lt;&lt; s.length() &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">                right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, right*<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">                right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, right*<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>组合(系列)</title>
    <url>/2022/04/18/leetcode/leetcode-combinations/</url>
    <content><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。</p>
<p>示例 1：<br>输入：n = 4, k = 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<p>示例 2：<br>输入：n = 1, k = 1<br>输出：[[1]]</p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝很关键</span></span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() + n-index+<span class="number">1</span> &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选当前数字</span></span><br><span class="line">        cur.<span class="built_in">emplace_back</span>(index);</span><br><span class="line">        <span class="built_in">backtrack</span>(index+<span class="number">1</span>, n, k);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 不选当前数字</span></span><br><span class="line">        <span class="built_in">backtrack</span>(index+<span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字典序方法"><a href="#字典序方法" class="headerlink" title="字典序方法"></a>字典序方法</h2><p>TODO</p>
<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给你一个 无重复元素 的整数数组candidates 和一个目标整数target，找出candidates中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。<br>示例 2：</p>
<p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>示例 3：</p>
<p>输入: candidates = [2], target = 1<br>输出: []</p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index, vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;index:&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (index == candidates.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选当前数字</span></span><br><span class="line">        <span class="built_in">backtrack</span>(index+<span class="number">1</span>, candidates, target);</span><br><span class="line">        <span class="comment">// 选当前数字</span></span><br><span class="line">        <span class="keyword">if</span> (target-candidates[index] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(candidates[index]);</span><br><span class="line">            <span class="comment">// 关键点：由于可以无限制使用一个树，所以此处index不用+1</span></span><br><span class="line">            <span class="built_in">backtrack</span>(index, candidates, target-candidates[index]);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>换一种写法，用循环构建多个分支。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index, vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;index:&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (index == candidates.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;index:&quot; &lt;&lt; index &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// 下一轮循环其实就是不选前一轮index的值</span></span><br><span class="line">            <span class="keyword">if</span> (target-candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 关键点：由于可以无限制使用一个树，所以此处index不用+1</span></span><br><span class="line">            <span class="built_in">backtrack</span>(i, candidates, target-candidates[i]);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h1><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p> </p>
<p>示例 1:</p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br>示例 2:</p>
<p>输入: candidates = [2,5,2,1,2], target = 5,<br>输出:<br>[<br>[1,2,2],<br>[5]<br>]</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index, vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;index:&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;index:&quot; &lt;&lt; index &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// i&gt;index防越界，还为了跳过同层重复分支</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i<span class="number">-1</span>] == candidates[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// 不选当前数字。这里 同层的不同分支，其实就是不选前面数字得到的</span></span><br><span class="line">            <span class="comment">// backtrack(i+1, candidates, target);</span></span><br><span class="line">            <span class="comment">// 选当前数字</span></span><br><span class="line">            <span class="keyword">if</span> (target-candidates[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                cur.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">                <span class="built_in">backtrack</span>(i+<span class="number">1</span>, candidates, target-candidates[i]);</span><br><span class="line">                cur.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>239. 滑动窗口最大值</title>
    <url>/2022/04/17/leetcode/leetcode-sliding-window-maximum/</url>
    <content><![CDATA[<p>给你一个整数数组 nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br>示例 2：</p>
<p>输入：nums = [1], k = 1<br>输出：[1]</p>
<hr>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>时间复杂度O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; window;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            window.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(window.<span class="built_in">top</span>().first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 窗口左边界的序号为i-k+1, 左边界左边的值都需要删除。</span></span><br><span class="line">            <span class="keyword">while</span> (!window.<span class="built_in">empty</span>() &amp;&amp; window.<span class="built_in">top</span>().second &lt; i-k+<span class="number">1</span>)&#123;</span><br><span class="line">                window.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            </span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(window.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="双端队列构建单调递减队列"><a href="#双端队列构建单调递减队列" class="headerlink" title="双端队列构建单调递减队列"></a>双端队列构建单调递减队列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!window.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[window.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                window.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(nums[window.<span class="built_in">front</span>()]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 窗口左边界的序号为i-k+1, 左边界左边的值都需要删除。</span></span><br><span class="line">            <span class="keyword">while</span> (!window.<span class="built_in">empty</span>() &amp;&amp; window.<span class="built_in">front</span>() &lt; i - k+<span class="number">1</span>)&#123;</span><br><span class="line">                window.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!window.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[window.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                window.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">push_back</span>(i);</span><br><span class="line">            </span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(nums[window.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>143. 重排链表</title>
    <url>/2022/04/17/leetcode/leetcode-reorder-list/</url>
    <content><![CDATA[<p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1：<br>输入：head = [1,2,3,4]<br>输出：[1,4,2,3]</p>
<p>示例 2：<br>输入：head = [1,2,3,4,5]<br>输出：[1,5,2,4,3]</p>
<hr>
<h1 id="链表中点-反转链表-合并链表"><a href="#链表中点-反转链表-合并链表" class="headerlink" title="链表中点+反转链表+合并链表"></a>链表中点+反转链表+合并链表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">midNode</span>(head);</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="built_in">mergeList</span>(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找链表的中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* l1_tmp;</span><br><span class="line">        ListNode* l2_tmp;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l1_tmp = l1-&gt;next;</span><br><span class="line">            l2_tmp = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l1 = l1_tmp;</span><br><span class="line"></span><br><span class="line">            l2-&gt;next = l1;</span><br><span class="line">            l2 = l2_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>460. LFU 缓存</title>
    <url>/2022/04/15/leetcode/leetcode-lfu-cache/</url>
    <content><![CDATA[<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>
<p>实现 LFUCache 类：</p>
<p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。 void put(int key,<br>int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity<br>时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器<br>。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p> </p>
<p>示例：</p>
<p>输入：<br>[“LFUCache”, “put”, “put”, “get”, “put”, “get”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]<br>输出：<br>[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</p>
<p>解释：<br>// cnt(x) = 键 x 的使用计数 </p>
<p>// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的） LFUCache lfu = new LFUCache(2); lfu.put(1, 1); //<br>cache=[1,_], cnt(1)=1 lfu.put(2, 2); </p>
<p>// cache=[2,1], cnt(2)=1, cnt(1)=1 lfu.get(1); </p>
<p>// 返回 1 </p>
<p>// cache=[1,2], cnt(2)=1, cnt(1)=2 lfu.put(3, 3); </p>
<p>// 去除键 2 ，因为 cnt(2)=1 ，使用计数最小 </p>
<p>// cache=[3,1], cnt(3)=1, cnt(1)=2 lfu.get(2); </p>
<p>// 返回 -1（未找到）<br>lfu.get(3); </p>
<p>// 返回 3 </p>
<p>// cache=[3,1], cnt(3)=2, cnt(1)=2 lfu.put(4, 4); </p>
<p>// 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用 </p>
<p>// cache=[4,3],<br>cnt(4)=1, cnt(3)=2 lfu.get(1); </p>
<p>// 返回 -1（未找到） lfu.get(3); </p>
<p>// 返回 3 </p>
<p>// cache=[3,4], cnt(4)=1, cnt(3)=3 lfu.get(4); </p>
<p>// 返回 4</p>
<p>// cache=[3,4], cnt(4)=2, cnt(3)=3</p>
<p>提示：</p>
<p>0 &lt;= capacity &lt;= 104 0 &lt;= key &lt;= 105 0 &lt;= value &lt;= 109 最多调用 2 * 105 次 get 和 put 方法</p>
<hr>
<h1 id="使用哈希表-平衡二叉树"><a href="#使用哈希表-平衡二叉树" class="headerlink" title="使用哈希表+平衡二叉树"></a>使用哈希表+平衡二叉树</h1><p>最好使用堆，但是堆支持动态更新非头节点，使用平衡二叉树替代</p>
<p>时间复杂度O(logn)<br>空间复杂度O(capacity)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value, time, cnt;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value, <span class="keyword">int</span> _time, <span class="keyword">int</span> _cnt):<span class="built_in">key</span>(_key),<span class="built_in">value</span>(_value),<span class="built_in">time</span>(_time),<span class="built_in">cnt</span>(_cnt)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt == node.cnt ? time &lt; node.time : cnt &lt; node.cnt; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="comment">// cache容量和时间戳</span></span><br><span class="line">    <span class="keyword">int</span> capacity, timestamp;</span><br><span class="line">    <span class="comment">// 平衡二叉查找树，红黑树</span></span><br><span class="line">    set&lt;Node&gt; S;</span><br><span class="line">    <span class="comment">// 无序map</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, Node&gt; hash_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">        hash_table.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 当前时间戳初始化为0</span></span><br><span class="line">        timestamp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = hash_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == hash_table.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node cache = it-&gt;second;</span><br><span class="line">        S.<span class="built_in">erase</span>(cache);</span><br><span class="line">        cache.time = ++timestamp;</span><br><span class="line">        cache.cnt += <span class="number">1</span>;</span><br><span class="line">        S.<span class="built_in">insert</span>(cache);</span><br><span class="line">        it-&gt;second = cache;</span><br><span class="line">        <span class="keyword">return</span> cache.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">auto</span> it = hash_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// 未找到相同元素，新增</span></span><br><span class="line">        <span class="keyword">if</span> (it == hash_table.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 存储已满，需要剔除频次最小，时间最久的一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (hash_table.<span class="built_in">size</span>() == capacity)&#123;</span><br><span class="line">                hash_table.<span class="built_in">erase</span>(S.<span class="built_in">begin</span>()-&gt;key);</span><br><span class="line">                S.<span class="built_in">erase</span>(S.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            Node cache = <span class="built_in">Node</span>(key, value, ++timestamp, <span class="number">1</span>);</span><br><span class="line">            S.<span class="built_in">insert</span>(cache);</span><br><span class="line">            hash_table.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, cache));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//更新</span></span><br><span class="line">            Node cache = it-&gt;second;</span><br><span class="line">            S.<span class="built_in">erase</span>(cache);</span><br><span class="line">            cache.time = ++timestamp;</span><br><span class="line">            cache.cnt += <span class="number">1</span>;</span><br><span class="line">            cache.value = value;</span><br><span class="line">            S.<span class="built_in">insert</span>(cache);</span><br><span class="line">            it-&gt;second = cache;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="两个哈希表"><a href="#两个哈希表" class="headerlink" title="两个哈希表"></a>两个哈希表</h1><p>一个哈希表frequency_table存储频率和对应频率下的节点，使用双向链表解决冲突，<br>队头的节点是最近的节点，队尾的节点是较久的节点。<br>每个节点存储，key，value，freq</p>
<p>一个哈希表key_table存储key和对应缓存在双向链表中的地址。</p>
<p>时间复杂度变为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value, freq;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value, <span class="keyword">int</span> _freq):<span class="built_in">key</span>(_key),<span class="built_in">value</span>(_value),<span class="built_in">freq</span>(_freq)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minfreq, capacity;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt; freq_table;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        list&lt;Node&gt;::iterator node = it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> freq = node-&gt;freq;</span><br><span class="line">        <span class="keyword">int</span> value = node-&gt;value;</span><br><span class="line">        <span class="comment">//需要更新频率</span></span><br><span class="line">        freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="keyword">if</span> (freq == minfreq) minfreq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        freq_table[freq+<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq+<span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// 未找到相同元素，新增</span></span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 存储已满，需要剔除频次最小，时间最久的一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity)&#123;</span><br><span class="line">                <span class="comment">// back返回的是最后一个元素的引用</span></span><br><span class="line">                <span class="keyword">auto</span> it2 = freq_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">                key_table.<span class="built_in">erase</span>(it2.key);</span><br><span class="line">                freq_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                    freq_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//更新</span></span><br><span class="line">            <span class="comment">// iterator相当于指针，也表示内存地址，*node则为一个Node对象。访问对象成员变量用, 指针访问变量用-&gt;</span></span><br><span class="line">            list&lt;Node&gt;::iterator node = it-&gt;second;</span><br><span class="line">            <span class="keyword">int</span> freq = node-&gt;freq;</span><br><span class="line">            freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">                <span class="keyword">if</span> (freq == minfreq) minfreq+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq+<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq+<span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>93. 复原 IP 地址</title>
    <url>/2022/04/12/leetcode/leetcode-restore-ip-addresses/</url>
    <content><![CDATA[<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#64;&#x31;&#46;&#49;">&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#64;&#x31;&#46;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>示例 1：<br>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]</p>
<p>示例 2：<br>输入：s = “0000”<br>输出：[“0.0.0.0”]</p>
<p>示例 3：<br>输入：s = “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p>
<p>提示：<br>1 &lt;= s.length &lt;= 20<br>s 仅由数字组成</p>
<hr>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">index, part_count</span>):</span></span><br><span class="line">            <span class="comment"># 如果获取到四个部分，表明应该结束了，如果刚好字符串也遍历完成，则可以获得一个答案</span></span><br><span class="line">            <span class="keyword">if</span> part_count == COUNT:</span><br><span class="line">                <span class="keyword">if</span> index == n:</span><br><span class="line">                    ans.append(<span class="string">&#x27;.&#x27;</span>.join([<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> parts]))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 如果字符串遍历结束，但是还没有获得四个part，则返回</span></span><br><span class="line">            <span class="keyword">if</span> index == n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s[index] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                parts[part_count] = <span class="number">0</span></span><br><span class="line">                dfs(index+<span class="number">1</span>, part_count+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            part = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n):</span><br><span class="line">                part = <span class="number">10</span>*part + (<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; part &lt;= <span class="number">0xFF</span>:</span><br><span class="line">                    parts[part_count] = part</span><br><span class="line">                    dfs(i+<span class="number">1</span>, part_count+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ip地址最多有4个部分组成</span></span><br><span class="line">        COUNT = <span class="number">4</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        parts = [<span class="number">0</span>]*COUNT</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 旋转图像</title>
    <url>/2022/04/12/leetcode/leetcode-rotate-image/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<hr>
<h1 id="对角翻转-镜像翻转"><a href="#对角翻转-镜像翻转" class="headerlink" title="对角翻转+镜像翻转"></a>对角翻转+镜像翻转</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 也可以将j改为range(i)</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line"></span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(mid):</span><br><span class="line">                matrix[row][column], matrix[row][n-column-<span class="number">1</span>] = matrix[row][n-column-<span class="number">1</span>], matrix[row][column]</span><br></pre></td></tr></table></figure>

<h1 id="直接翻转"><a href="#直接翻转" class="headerlink" title="直接翻转"></a>直接翻转</h1><p>每次翻转会引起四个数的改变。</p>
<p>四个数的坐标比较难定。</p>
<p>关键规律：<br>对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。<br>对应公式：row, col = col, n-row-1</p>
<p>推导得到四个坐标，实际循环的时候，要先将最后一个数放到第一个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">                <span class="comment"># print(&#x27;i,j&#x27;, i, j)</span></span><br><span class="line">                <span class="comment"># print(&quot;(&quot;,i, j, &quot;)&quot;,&quot; (&quot;,n-j-1, i, &quot;)&quot;,&quot; (&quot;,n-i-1, n-j-1,&quot;) &quot;,&quot; (&quot;, j, n-i-1,&quot;)&quot;)</span></span><br><span class="line">                temp = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n-j-<span class="number">1</span>][i]</span><br><span class="line">                matrix[n-j-<span class="number">1</span>][i] = matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>]</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>] = matrix[j][n-i-<span class="number">1</span>]</span><br><span class="line">                matrix[j][n-i-<span class="number">1</span>] = temp</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>22. 括号生成</title>
    <url>/2022/04/12/leetcode/leetcode-generate-parentheses/</url>
    <content><![CDATA[<p>数字 n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>示例 2：<br>输入：n = 1<br>输出：[“()”]</p>
<p>提示：<br>1 &lt;= n &lt;= 8</p>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>左右括号从 n 开始递减<br>剩余左括号总数要小于等于右括号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">result, left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(result))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                result.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                helper(result, left-<span class="number">1</span>, right)</span><br><span class="line">                result.pop()</span><br><span class="line">            <span class="keyword">elif</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                    result.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    helper(result, left-<span class="number">1</span>, right)</span><br><span class="line">                    result.pop()</span><br><span class="line">                result.append(<span class="string">&#x27;)&#x27;</span>),</span><br><span class="line">                helper(result, left, right-<span class="number">1</span>)</span><br><span class="line">                result.pop()</span><br><span class="line">        ans = []</span><br><span class="line">        result = []</span><br><span class="line">        helper(result, n, n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>101. 对称二叉树</title>
    <url>/2022/04/12/leetcode/leetcode-symmetric-tree/</url>
    <content><![CDATA[<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>示例 1：<br>输入：root = [1,2,2,3,4,4,3]<br>输出：true </p>
<p>示例 2：<br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
<p>提示：<br>树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100</p>
<p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<hr>
<h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">p, q</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> helper(p.left, q.right) <span class="keyword">and</span> helper(p.right, q.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right)</span><br></pre></td></tr></table></figure>

<h1 id="广度优先遍历-队列"><a href="#广度优先遍历-队列" class="headerlink" title="广度优先遍历-队列"></a>广度优先遍历-队列</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">import</span> queue</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        q = queue.Queue()</span><br><span class="line">        q.put(root.left)</span><br><span class="line">        q.put(root.right)</span><br><span class="line">        <span class="keyword">while</span> q.qsize():</span><br><span class="line">            l = q.get()</span><br><span class="line">            r = q.get()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> l.val != r.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            q.put(l.left)</span><br><span class="line">            q.put(r.right)</span><br><span class="line">            q.put(l.right)</span><br><span class="line">            q.put(r.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>328. 奇偶链表</title>
    <url>/2022/04/12/leetcode/leetcode-odd-even-linked-list/</url>
    <content><![CDATA[<p>给定单链表的头节点head，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
<p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为偶数 ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在O(1)的额外空间复杂度和O(n)的时间复杂度下解决这个问题。</p>
<p>示例 1:<br>输入: head = [1,2,3,4,5]<br>输出: [1,3,5,2,4]</p>
<p>示例 2:<br>输入: head = [2,1,3,5,6,4,7]<br>输出: [2,3,6,7,1,5,4]</p>
<hr>
<h1 id="直接一次遍历"><a href="#直接一次遍历" class="headerlink" title="直接一次遍历"></a>直接一次遍历</h1><p>将偶数节点放到新链表，结束后链接到旧链表之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        odd_dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        even_dummy = ListNode()</span><br><span class="line">        even_tail = even_dummy</span><br><span class="line">        p = head</span><br><span class="line">        pre = odd_dummy</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                pre = p</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                even_tail.<span class="built_in">next</span> = p</span><br><span class="line">                even_tail = p</span><br><span class="line">                pre.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        even_tail.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        pre.<span class="built_in">next</span> = even_dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> odd_dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>41. 缺失的第一个正数</title>
    <url>/2022/04/10/leetcode/leetcode-first-missing-positive/</url>
    <content><![CDATA[<p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,0]<br>输出：3<br>示例 2：</p>
<p>输入：nums = [3,4,-1,1]<br>输出：2<br>示例 3：</p>
<p>输入：nums = [7,8,9,11,12]<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 5 * 105<br>-231 &lt;= nums[i] &lt;= 231 - 1</p>
<hr>
<h1 id="直观的思路：哈希表"><a href="#直观的思路：哈希表" class="headerlink" title="直观的思路：哈希表"></a>直观的思路：哈希表</h1><p>但是时间空间复杂度都是O(n)，空间复杂度不满足题目的要求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        exists = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            exists[nums[i]] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> exists[i+<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="改造当前数组为哈希表"><a href="#改造当前数组为哈希表" class="headerlink" title="改造当前数组为哈希表"></a>改造当前数组为哈希表</h1><p>数组长度为n，则数组中的数，如果存储的是[1,n], 则第一个缺失的数是n+1<br>否则缺失的数一定在[1,n]中的某一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 把非正数都改为一个特殊的数，注意0也要修改</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span>:</span><br><span class="line">                nums[i] = n + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 数有可能已经被前序循环修改为负数了</span></span><br><span class="line">            num = <span class="built_in">abs</span>(nums[i])</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n:</span><br><span class="line">                <span class="comment"># print(num, nums)</span></span><br><span class="line">                <span class="comment"># 可能有重复的数</span></span><br><span class="line">                nums[num-<span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">nums, i, j</span>):</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 多次交换, 注意死循环</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;  nums[i] &lt;= n:</span><br><span class="line">                index = nums[i] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[index] == nums[i]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    swap(nums, i, index)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>排序矩阵查找(系列)</title>
    <url>/2022/04/10/leetcode/leetcode-sorted-matrix-search-lcci/</url>
    <content><![CDATA[<h1 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h1><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>
<hr>
<p>看到这题，最简单的就是直接一次遍历所有元素，时间复杂度是O(m*n)。<br>当然，看到升序，也比较容易想到二分查找，可以按行遍历m次，每次使用二分查找。</p>
<p>但是，还有没有其他更好的办法呢？</p>
<h2 id="倒三角线遍历"><a href="#倒三角线遍历" class="headerlink" title="倒三角线遍历"></a>倒三角线遍历</h2><p>观察发现，如果从右上角开始遍历，直到左下角结束，假设当前元素为cur，可以发现：</p>
<ol>
<li>如果cur&lt;target, 由于cur是这一行中最大的数，则可以舍弃这一行，cur下移</li>
<li>如果cur&gt;target, 由于cur是这一列中最小的数，则可以舍弃这一列，cur左移</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        column = n-<span class="number">1</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> row &lt; m <span class="keyword">and</span> column &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[row][column] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][column] &lt; target:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                column = column - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>           </span><br></pre></td></tr></table></figure>
<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span> (tmp == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; target) &#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然, 从左下角走到右上角也是OK的, 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        row = m-<span class="number">1</span></span><br><span class="line">        column = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> row &gt;=<span class="number">0</span> <span class="keyword">and</span> column &lt; n:</span><br><span class="line">            <span class="keyword">if</span> matrix[row][column] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][column] &lt; target:</span><br><span class="line">                column += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row = row - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>           </span><br></pre></td></tr></table></figure>

<h2 id="正三角遍历"><a href="#正三角遍历" class="headerlink" title="正三角遍历"></a>正三角遍历</h2><p>将矩阵划分为四块：左上、右上、左下、右下，每次可以排除其中一块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">matrix, x1, y1, x2, y2, x_max, y_max, target</span>):</span></span><br><span class="line">            <span class="comment"># 越界</span></span><br><span class="line">            <span class="keyword">if</span> x1 &gt; x_max <span class="keyword">or</span> y1 &gt; y_max:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果只有一个元素了</span></span><br><span class="line">            <span class="keyword">if</span> x1 == x2 <span class="keyword">and</span> y1 == y2:</span><br><span class="line">                <span class="keyword">return</span> matrix[x1][y1] == target</span><br><span class="line">            </span><br><span class="line">            mid_x = x1 + (x2-x1)//<span class="number">2</span></span><br><span class="line">            mid_y = y1 + (y2-y1)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid_x][mid_y] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[mid_x][mid_y] &lt; target:</span><br><span class="line">                right_up_result = helper(matrix, x1, mid_y+<span class="number">1</span>, mid_x, y2, x2, y2,target) </span><br><span class="line">                left_down_result = helper(matrix, mid_x+<span class="number">1</span>, y1, x2, mid_y, x2, y2,target)</span><br><span class="line">                right_down_result = helper(matrix, mid_x+<span class="number">1</span>, mid_y+<span class="number">1</span>, x2, y2, x2, y2,target)</span><br><span class="line">                <span class="keyword">return</span> right_up_result <span class="keyword">or</span> left_down_result <span class="keyword">or</span> right_down_result</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_up_result = helper(matrix, x1, mid_y+<span class="number">1</span>, mid_x, y2, x2, y2,target) </span><br><span class="line">                left_down_result = helper(matrix, mid_x+<span class="number">1</span>, y1, x2, mid_y, x2, y2,target)</span><br><span class="line">                left_up_result = helper(matrix, x1, y1, mid_x, mid_y, x2, y2,target)</span><br><span class="line">                <span class="keyword">return</span> right_up_result <span class="keyword">or</span> left_down_result <span class="keyword">or</span> left_up_result</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(matrix, <span class="number">0</span>, <span class="number">0</span>, m-<span class="number">1</span>, n-<span class="number">1</span>, m-<span class="number">1</span>, n-<span class="number">1</span>, target)</span><br></pre></td></tr></table></figure>


<h1 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h1><p>编写一个高效的算法来判断m x n矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
<h2 id="两次二分查找"><a href="#两次二分查找" class="headerlink" title="两次二分查找"></a>两次二分查找</h2><p>可以先按第一列二分查找确定所在的行，然后再对行做一次二分</p>
<h2 id="一次二分"><a href="#一次二分" class="headerlink" title="一次二分"></a>一次二分</h2><p>将整个矩形视作一个一维数组，直接一次二分完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        total = m * n</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = total-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 考虑二者相等的情况</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">            x = matrix[mid//n][mid%n]</span><br><span class="line">            <span class="comment"># print(&quot;left, right, mid, m, n, x&quot;, left, right, mid, m, n, x)</span></span><br><span class="line">            <span class="keyword">if</span> x == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> x &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(&#x27;left, right&#x27;, left, right)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = rows*columns<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[mid/columns][mid%columns];</span><br><span class="line">            <span class="keyword">if</span> (tmp == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素(系列)</title>
    <url>/2022/04/10/leetcode/leetcode-remove-duplicates-from-sorted-list/</url>
    <content><![CDATA[<h1 id="删除重复元素，保留一个"><a href="#删除重复元素，保留一个" class="headerlink" title="删除重复元素，保留一个"></a>删除重复元素，保留一个</h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = head</span><br><span class="line">        q = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q.val == p.val:</span><br><span class="line">                r = q.<span class="built_in">next</span></span><br><span class="line">                p.<span class="built_in">next</span> = r</span><br><span class="line">                <span class="keyword">del</span> q</span><br><span class="line">                q = r</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = q</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="删除所有重复的元素"><a href="#删除所有重复的元素" class="headerlink" title="删除所有重复的元素"></a>删除所有重复的元素</h1><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。<br>返回 已排序的链表 。</p>
<p>细节题, 关键点是有可能删除第一个元素，为了方便，一般需要添加一个dummy节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        p = dummy</span><br><span class="line">        q = dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> q.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> q.val == q.<span class="built_in">next</span>.val:</span><br><span class="line">                last_deleted = q.val</span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> q.val == last_deleted:</span><br><span class="line">                    r = q.<span class="built_in">next</span></span><br><span class="line">                    p.<span class="built_in">next</span> = r</span><br><span class="line">                    <span class="keyword">del</span> q</span><br><span class="line">                    q = r</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = q</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的合法性判断(系列)</title>
    <url>/2022/04/09/leetcode/leetcode-validate-binary-tree/</url>
    <content><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<h2 id="直接递归判断"><a href="#直接递归判断" class="headerlink" title="直接递归判断"></a>直接递归判断</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, pre_val, next_val</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> root.val &gt;= next_val <span class="keyword">or</span> root.val &lt;= pre_val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> helper(root.left, pre_val, root.val) <span class="keyword">and</span> helper(root.right, root.val, next_val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历的思路"><a href="#中序遍历的思路" class="headerlink" title="中序遍历的思路"></a>中序遍历的思路</h2><p>中序遍历得到的数组必然是从小到大有序排列的。</p>
<h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>时间复杂度和空间复杂度均为O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            ans += inOrder(root.left)</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            ans += inOrder(root.right)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        ans = inOrder(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ans)):</span><br><span class="line">            <span class="keyword">if</span> ans[i-<span class="number">1</span>] &gt;= ans[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        pre_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> p.val &lt;= pre_val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre_val = p.val</span><br><span class="line">            p = p.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>用C++重写一遍加深记忆，这个时候就体现出Python写代码的方便性了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">long</span> preval = (<span class="keyword">long</span>)INT_MIN<span class="number">-1</span>;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 后面被访问的数要严格大于前一个数</span></span><br><span class="line">            <span class="comment">// 由于int最小可能为INT_MIN, 所以preval初始化值比INT_MIN小1</span></span><br><span class="line">            <span class="comment">// 或者对于边界值单独处理</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt;= preval)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            preval = p-&gt;val;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的完全性检验"><a href="#二叉树的完全性检验" class="headerlink" title="二叉树的完全性检验"></a>二叉树的完全性检验</h1><p>给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。</p>
<p>在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，<br>并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 1 到 2^h 节点之间的最后一级 h 。</p>
<h2 id="层序遍历的思路"><a href="#层序遍历的思路" class="headerlink" title="层序遍历的思路"></a>层序遍历的思路</h2><p>如果将完全二叉数用数组存储，那么它的节点序号是顺序的。<br>如果有n个节点，则最后一个节点的序号应该是n-1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        queue = collections.deque([(root, <span class="number">0</span>)])</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                p, p_index = queue.popleft()</span><br><span class="line">                <span class="comment"># 完全二叉树的序号是顺序的</span></span><br><span class="line">                <span class="keyword">if</span> count != p_index:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> p.left:</span><br><span class="line">                    queue.append((p.left, p_index*<span class="number">2</span>+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> p.right:</span><br><span class="line">                    queue.append((p.right, p_index*<span class="number">2</span>+<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找两个正序数组的中位数</title>
    <url>/2022/04/06/leetcode/leetcode-median-of-two-sorted-arrays/</url>
    <content><![CDATA[<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="双指针法直接查找中位数"><a href="#双指针法直接查找中位数" class="headerlink" title="双指针法直接查找中位数"></a>双指针法直接查找中位数</h1><p>正常的解法是将两个数组合并，然后得到中位数，但是其实不用存储新数组，可以直接用双指针分别遍历，<br>分别取两个数组中较小的数，累积遍历(m+n)//2+1次即可。<br>考虑到奇数和偶数的差异，需要记录两个结果值。这里用left和right记录。<br>同时，还需要考虑如果有一个数组遍历完的情况</p>
<p>为了注重代码可读性，调整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        left = -<span class="number">1</span></span><br><span class="line">        right = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= (m+n)//<span class="number">2</span> <span class="keyword">and</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            left = right</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                right = nums1[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = nums2[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> count &lt;= (m+n)//<span class="number">2</span> <span class="keyword">and</span> i &lt; m:</span><br><span class="line">            left = right</span><br><span class="line">            right = nums1[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> count &lt;= (m+n)//<span class="number">2</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            left = right</span><br><span class="line">            right = nums2[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># if i &lt; m and (j &gt;= n or nums1[i] &lt; nums2[j]):</span></span><br><span class="line">            <span class="comment">#     right = nums1[i]</span></span><br><span class="line">            <span class="comment">#     i += 1</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     right = nums2[j]</span></span><br><span class="line">            <span class="comment">#     j += 1</span></span><br><span class="line">            <span class="comment"># count += 1</span></span><br><span class="line">        <span class="keyword">if</span> (m+n) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            ans = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二分查找法-划分数组"><a href="#二分查找法-划分数组" class="headerlink" title="二分查找法-划分数组"></a>二分查找法-划分数组</h1><p>时间复杂度：O(log min(m,n))<br>空间复杂度：O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 关键点1：让m始终比n小，可以使得我们以第一个数组为基准二分查找时，第二个数组分割线两侧一定有元素，也就是下标j不会越界</span></span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 1. 数组数量不等，A数组左边无元素</span></span><br><span class="line">        <span class="comment">// 2. 数组数量不等，A数组右边无元素</span></span><br><span class="line">        <span class="comment">// 3. 数组数量相等，A数组左边无元素，B数组右边无元素</span></span><br><span class="line">        <span class="comment">// 4. 数组数量相等，A数组右边无元素，B数组左边无元素</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键点2: 左半部分元素的个数</span></span><br><span class="line">        <span class="comment">// 如果是偶数，向下取整，正好一半；如果是奇数，让左边比右边多一个元素</span></span><br><span class="line">        <span class="comment">// 二分查找的时候，可以只调整第一个数组中的分割线位置，然后根据总长度控制第二个数组中的分割线位置</span></span><br><span class="line">        <span class="keyword">int</span> leftPartTotal = (m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个数组至少有1个元素，才会进入while循环</span></span><br><span class="line">        <span class="comment">// left == right时退出循环</span></span><br><span class="line">        <span class="comment">// 初始化循环, 也就是i的范围：[0, m]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 关键点3</span></span><br><span class="line">            <span class="comment">// i = (left + right + 1)/2 为了避免两个整数相加溢出，改为起点+增量计算中点的方式</span></span><br><span class="line">            <span class="comment">// i是第一个数组中分割线右边的第一个元素</span></span><br><span class="line">            <span class="comment">// j是第二个数组中分割线右边的第一个元素</span></span><br><span class="line">            <span class="comment">// 即，i,j所在的位置分别是分割线右边的第一个元素</span></span><br><span class="line">            <span class="keyword">int</span> i = left + (right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = leftPartTotal - i;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                <span class="comment">// 下一轮循环[left, i-1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 下一轮循环[i, right]</span></span><br><span class="line">                <span class="comment">// 考虑只有两个元素的时候，需要让上面取中位数的地方上取整，避免进入死循环</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = left;</span><br><span class="line">        j = leftPartTotal - i;</span><br><span class="line">        <span class="keyword">int</span> firstLeft =  i == <span class="number">0</span> ? INT_MIN : nums1[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> firstRight = i == m ? INT_MAX : nums1[i];</span><br><span class="line">        <span class="keyword">int</span> secondLeft = j == <span class="number">0</span> ? INT_MIN : nums2[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> secondRight = j== n ? INT_MAX : nums2[j];     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="built_in">max</span>(firstLeft, secondLeft);</span><br><span class="line">        <span class="keyword">if</span> ((m+n) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rightMin = <span class="built_in">min</span>(firstRight, secondRight);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in"><span class="keyword">float</span></span>(leftMax + rightMin)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>python3重写一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            <span class="keyword">return</span> self.findMedianSortedArrays(nums2, nums1)</span><br><span class="line">        </span><br><span class="line">        total_left = (m+n+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = m</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            i = left + (right - left + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            j = total_left - i</span><br><span class="line">            <span class="comment"># i的范围是[1, m], 所以i-1不会越界</span></span><br><span class="line">            <span class="keyword">if</span> nums1[i-<span class="number">1</span>] &gt; nums2[j]:</span><br><span class="line">                <span class="comment"># A数组左边大，说明分割线太靠右了，需要左移</span></span><br><span class="line">                right = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = i</span><br><span class="line">        </span><br><span class="line">        i = left</span><br><span class="line">        j = total_left - i</span><br><span class="line">        first_left = nums1[i-<span class="number">1</span>] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        first_right = nums1[i] <span class="keyword">if</span> i &lt; m <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        second_left = nums2[j-<span class="number">1</span>] <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        second_right = nums2[j] <span class="keyword">if</span> j &lt; n <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        left_max = <span class="built_in">max</span>(first_left, second_left)</span><br><span class="line">        right_min = <span class="built_in">min</span>(first_right, second_right)</span><br><span class="line">        <span class="keyword">return</span> left_max <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> (left_max+right_min)/<span class="number">2</span></span><br></pre></td></tr></table></figure>


<h1 id="二分查找法-查找第k大的数"><a href="#二分查找法-查找第k大的数" class="headerlink" title="二分查找法-查找第k大的数"></a>二分查找法-查找第k大的数</h1><p>时间复杂度O(log(m+n))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">if</span> (m+n) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 偶数个数的时候，需要找两个数，然后求平均</span></span><br><span class="line">            target1 = self.getKthElement(nums1,nums2,(m+n) // <span class="number">2</span>)</span><br><span class="line">            target2 = self.getKthElement(nums1,nums2,(m+n) // <span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> (target1+target2)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getKthElement(nums1,nums2,(m+n)//<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthElement</span>(<span class="params">self, nums1, nums2, k</span>):</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        index2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> index1 == m:</span><br><span class="line">                <span class="comment"># k已经发生改变，不能使用m-k+1做索引</span></span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> index2 == n:</span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">            new_index1 = <span class="built_in">min</span>(index1 + k//<span class="number">2</span> - <span class="number">1</span>, m-<span class="number">1</span>)</span><br><span class="line">            new_index2 = <span class="built_in">min</span>(index2 + k//<span class="number">2</span> - <span class="number">1</span>, n-<span class="number">1</span>)</span><br><span class="line">            pivot1 = nums1[new_index1]</span><br><span class="line">            pivot2 = nums2[new_index2]</span><br><span class="line">            <span class="comment"># 每次排除k//2 - 1个数，直到寻找最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span> pivot1 &lt; pivot2:</span><br><span class="line">                k = k - (new_index1 - index1 + <span class="number">1</span>)</span><br><span class="line">                index1 = new_index1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = k - (new_index2 - index2 + <span class="number">1</span>)</span><br><span class="line">                index2 = new_index2 + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 合并区间</title>
    <url>/2022/04/05/leetcode/leetcode-merge-intervals/</url>
    <content><![CDATA[<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals = [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<hr>
<h1 id="排序后一次遍历"><a href="#排序后一次遍历" class="headerlink" title="排序后一次遍历"></a>排序后一次遍历</h1><p>此题咋一看，还挺难，掌握思路后其实还蛮简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        ans = [intervals[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> interval[<span class="number">0</span>] &gt; ans[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                ans.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(interval[<span class="number">1</span>], ans[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言经典库函数</title>
    <url>/2022/04/04/leetcode/leetcode-C-op/</url>
    <content><![CDATA[<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。<br>注意：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
 </p>
<p>示例 1：<br>输入：s = “42”<br>输出：42<br>解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 1 步：”42”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”42”（读入 “42”）<br>           ^<br>解析得到整数 42 。<br>由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。</p>
<p>示例 2：<br>输入：s = “   -42”<br>输出：-42<br>解释：<br>第 1 步：”   -42”（读入前导空格，但忽视掉）<br>            ^<br>第 2 步：”   -42”（读入 ‘-‘ 字符，所以结果应该是负数）<br>             ^<br>第 3 步：”   -42”（读入 “42”）<br>               ^<br>解析得到整数 -42 。<br>由于 “-42” 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</p>
<p>示例 3：<br>输入：s = “4193 with words”<br>输出：4193<br>解释：<br>第 1 步：”4193 with words”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”4193 with words”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”4193 with words”（读入 “4193”；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 4193 。<br>由于 “4193” 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
 </p>
<p>提示：<br>0 &lt;= s.length &lt;= 200<br>s 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成</p>
<h2 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h2><p>注意扣细节。</p>
<ol>
<li>前序空白字符直接过滤</li>
<li>空白字符之后只允许至多紧跟一个+或者-</li>
<li>符号之后必须是连续数字</li>
<li>数字部分简单看就是按数位求和。特别需要注意是否溢出，两种情况可能溢出：乘10的时候和累加当前数字的时候</li>
<li>累加当前数字的时候需要区分当前的符号位，因为正数和负数的绝对值相差1<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; INT_MAX &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序空白符号后，紧跟着的只能是一个+或-，如果有多个+、-则判定非法，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 符号之后的一定要是数字，如果为字符则非法。忽略数字最后的其他字符</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; digit &lt;&lt; &quot; ans:&quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT_MAX / <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> flag &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans == INT_MAX / <span class="number">10</span> &amp;&amp; flag &gt; <span class="number">0</span> &amp;&amp; digit &gt;= INT_MAX % <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MAX_MIN -2147483648  MAX_MAX 2147483647, 负数绝对值比正数大，此处应为&gt;=, 否则边界情况，会溢出</span></span><br><span class="line">            <span class="keyword">if</span> (ans == INT_MAX / <span class="number">10</span> &amp;&amp; flag &lt; <span class="number">0</span> &amp;&amp; digit &gt;= flag * (INT_MIN % <span class="number">10</span>))&#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; digit &lt;&lt; INT_MIN % 10;</span></span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="number">10</span> * ans + digit;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="方法二：有限状态机"><a href="#方法二：有限状态机" class="headerlink" title="方法二：有限状态机"></a>方法二：有限状态机</h2><p>一种很好的思路，可以将逻辑判断变得比较清晰，不容易出错。<br>但是实际上，也新增了一些麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automation</span>&#123;</span></span><br><span class="line">    <span class="comment">// 初始状态为start</span></span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    <span class="comment">// 状态转移表，4种状态，4类输入(空白符、符号、数字、其他)</span></span><br><span class="line">    <span class="comment">// 在每种状态下，每个字符会引起一种状态转移</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getColumn</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">getColumn</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)&#123;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT_MAX / <span class="number">10</span>)&#123;</span><br><span class="line">                ans = sign &gt; <span class="number">0</span> ? INT_MAX : INT_MIN;</span><br><span class="line">                state = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ans == INT_MAX / <span class="number">10</span> &amp;&amp; sign &gt; <span class="number">0</span> &amp;&amp; digit &gt;= INT_MAX % <span class="number">10</span>)&#123;</span><br><span class="line">                ans = INT_MAX;</span><br><span class="line">                state = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ans == INT_MAX / <span class="number">10</span> &amp;&amp; sign &lt; <span class="number">0</span> &amp;&amp; digit &gt;= (INT_MIN % <span class="number">10</span>)*sign)&#123;</span><br><span class="line">                ans = INT_MIN;</span><br><span class="line">                state = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = <span class="number">10</span> * ans + digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        Automation automation;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s)&#123;</span><br><span class="line">            automation.<span class="built_in">Get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 边界case：-2147483647</span></span><br><span class="line">        <span class="keyword">if</span> ((automation.ans == INT_MAX &amp;&amp; automation.sign == <span class="number">1</span>) || automation.ans == INT_MIN)&#123;</span><br><span class="line">            <span class="keyword">return</span> automation.ans;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> automation.ans * automation.sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-整数反转-reverse-integer"><a href="#7-整数反转-reverse-integer" class="headerlink" title="7. 整数反转 reverse-integer"></a>7. 整数反转 reverse-integer</h1><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; INT_MAX &lt;&lt; &quot; &quot; &lt;&lt; INT_MIN &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                digit = digit * sign;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; INT_MAX / <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans == INT_MAX / <span class="number">10</span> &amp;&amp; sign &gt; <span class="number">0</span> &amp;&amp; digit &gt; INT_MAX % <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans == INT_MAX / <span class="number">10</span> &amp;&amp; sign &lt; <span class="number">0</span> &amp;&amp; digit &gt; (INT_MIN % <span class="number">10</span>)*sign)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + digit;</span><br><span class="line">                x = x / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组的不同路径</title>
    <url>/2022/04/04/leetcode/leetcode-unique-paths/</url>
    <content><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>总共要走m+n-n步，其中向下m-1步，向右n-1步，一个方向的选择确定后，另一个方向也就固定了。<br>所以其实是一个组合问题，从m+n-2个数中选择m-1个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> comb(m+n-<span class="number">2</span>, m-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>最终走到终点有两种选择，从上到下或者从左到右。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>滚动数组优化</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的路径问题(系列)</title>
    <url>/2022/04/04/leetcode/leetcode-path-sum-ii/</url>
    <content><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h1><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br>叶子节点 是指没有子节点的节点。</p>
<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val == targetSum</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum-root.val)</span><br></pre></td></tr></table></figure>

<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        node_queue = collections.deque([root])</span><br><span class="line">        num_queue = collections.deque([root.val])</span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.popleft()</span><br><span class="line">            num = num_queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> num == targetSum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node_queue.append(node.left)</span><br><span class="line">                    num_queue.append(num+node.left.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node_queue.append(node.right)</span><br><span class="line">                    num_queue.append(num+node.right.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a>113. 路径总和 II</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<hr>
<h2 id="深度优先遍历-1"><a href="#深度优先遍历-1" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>重点在弹出的动作，方便下次遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, path, ans, targetSum</span>):</span></span><br><span class="line">            <span class="comment"># print(targetSum)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">if</span> targetSum == root.val:</span><br><span class="line">                    ans.append(<span class="built_in">list</span>(path))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    dfs(root.left, path, ans, targetSum-root.val)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    dfs(root.right, path, ans, targetSum-root.val)</span><br><span class="line">            <span class="comment"># 有点回溯的思路了，需要将加入的根节点弹出</span></span><br><span class="line">            path.pop()</span><br><span class="line">        path = []</span><br><span class="line">        ans = []</span><br><span class="line">        dfs(root, path, ans, targetSum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>


<h2 id="广度优先遍历-1"><a href="#广度优先遍历-1" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>在找到和相等的节点时，需要反查到根节点。为此，需要有一个dict记录节点的父节点</p>
<p>理解起来相对更容易一点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        parents = <span class="built_in">dict</span>()</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPath</span>(<span class="params">node</span>):</span></span><br><span class="line">            path = collections.deque()</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                path.appendleft(node.val)</span><br><span class="line">                node = parents[node]</span><br><span class="line">            ans.append(<span class="built_in">list</span>(path))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        parents[root] = <span class="literal">None</span></span><br><span class="line">        node_queue = collections.deque([root])</span><br><span class="line">        num_queue = collections.deque([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.popleft()</span><br><span class="line">            num = num_queue.popleft()</span><br><span class="line">            total = num + node.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># print(node.val,total,targetSum)</span></span><br><span class="line">                <span class="keyword">if</span> total == targetSum:</span><br><span class="line">                    getPath(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    parents[node.left] = node</span><br><span class="line">                    node_queue.append(node.left)</span><br><span class="line">                    num_queue.append(total)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    parents[node.right] = node</span><br><span class="line">                    node_queue.append(node.right)</span><br><span class="line">                    num_queue.append(total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h1><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。<br>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<h2 id="深度优先遍历-2"><a href="#深度优先遍历-2" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>定义rootSum为从root节点开始往下得到的路径和为目标值的路径个数<br>则原问题等于三个子问题的和：<br>根节点往下路径和为目标值的个数<br>左子树的解<br>右子树的解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rootSum</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> root.val == targetSum:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans += rootSum(root.left, targetSum-root.val)</span><br><span class="line">            ans += rootSum(root.right, targetSum-root.val)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> rootSum(root, targetSum) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="前缀路径和"><a href="#前缀路径和" class="headerlink" title="前缀路径和"></a>前缀路径和</h2><p>【经典方法】<br>用dict记录从根节点到当前节点的路径(不含当前节点)上每个节点的路径和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        prefix_sum = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        prefix_sum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, cur</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">            cur += root.val</span><br><span class="line">            ans += prefix_sum[cur-targetSum]</span><br><span class="line"></span><br><span class="line">            prefix_sum[cur] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                ans += dfs(root.left, cur)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                ans += dfs(root.right, cur)</span><br><span class="line">            <span class="comment"># 我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</span></span><br><span class="line">            prefix_sum[cur] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>




<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h1><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<h2 id="深度优先遍历-3"><a href="#深度优先遍历-3" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>题目要返回的是字符串形式的路径，表示无语</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, ans, path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            path.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                ans.append(<span class="string">&quot;-&gt;&quot;</span>.join(path))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    dfs(root.left, ans, path)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    dfs(root.right, ans, path)</span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        dfs(root, ans, path)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="广度优先遍历-2"><a href="#广度优先遍历-2" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPath</span>(<span class="params">node</span>):</span></span><br><span class="line">            path = collections.deque()</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                path.appendleft(<span class="built_in">str</span>(node.val))</span><br><span class="line">                node = parents[node]</span><br><span class="line">            ans.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(path))</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        parents = <span class="built_in">dict</span>()</span><br><span class="line">        parents[root] = <span class="literal">None</span></span><br><span class="line">        node_queue = collections.deque([root])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                getPath(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    parents[node.left] = node</span><br><span class="line">                    node_queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    parents[node.right] = node</span><br><span class="line">                    node_queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h1><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ans = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># maxGain计算以该节点为起点的一条路径，使得该路径上的节点值之和最大的贡献值</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxGain</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            left = <span class="built_in">max</span>(maxGain(root.left), <span class="number">0</span>)</span><br><span class="line">            right = <span class="built_in">max</span>(maxGain(root.right), <span class="number">0</span>)</span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, left+right+root.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root.val</span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>求根节点到叶节点数字之和</title>
    <url>/2022/04/04/leetcode/leetcode-sum-root-to-leaf-numbers/</url>
    <content><![CDATA[<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>
<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>
<p>叶节点 是指没有子节点的节点。</p>
<hr>
<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, pre_total</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            total = pre_total*<span class="number">10</span> + root.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> total</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> helper(root.left, total) + helper(root.right, total)</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        node_queue = collections.deque([root])</span><br><span class="line">        num_queue = collections.deque([root.val])</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.popleft()</span><br><span class="line">            num = num_queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                total += num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node_queue.append(node.left)</span><br><span class="line">                    num_queue.append(num*<span class="number">10</span>+node.left.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node_queue.append(node.right)</span><br><span class="line">                    num_queue.append(num*<span class="number">10</span>+node.right.val)</span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离</title>
    <url>/2022/04/04/leetcode/leetcode-edit-distance/</url>
    <content><![CDATA[<p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符
 </p>
<p>示例 1：<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：</p>
<p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>对于两个串A和B，编辑动作可以归纳为三类：</p>
<ol>
<li>A后添加一个数字</li>
<li>B后添加一个数字</li>
<li>A修改一个数字</li>
</ol>
<p>dp[i][j]表示A的前i个字符和B的前j个字符的编辑距离。<br>可以拆解为三个子问题：</p>
<ol>
<li>dp[i-1][j], A的前i-1个字符和B的前j个字符, 可以通过A后添加一个数字得到目标问题</li>
<li>dp[i][i-1], 同理，可以在B后添加一个数字得到目标问题</li>
<li>dp[i-1][j-1], A的前i-1个字符和B的前j-1个字符, 我们可以修改A的第i个字符使之和B的第j个字符一致得到目标问题。<br>如果二者原本相同，则不需要修改，否则编辑距离+1。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> n = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (m * n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> m + n;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n+<span class="number">1</span>; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> top = dp[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left = dp[i][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left_top = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">// 注意，字符串序号与dp序号差1</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] != word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    left_top += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(top, <span class="built_in">min</span>(left, left_top));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2022/04/03/leetcode/leetcode-palindrome-linked-list/</url>
    <content><![CDATA[<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br>示例 1：<br>输入：head = [1,2,2,1]<br>输出：true</p>
<p>示例 2：<br>输入：head = [1,2]<br>输出：false</p>
<p>提示：<br>链表中节点数目在范围[1, 10^5] 内<br>0 &lt;= Node.val &lt;= 9</p>
<p>进阶：你能否用O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<hr>
<h1 id="遍历得到数组然后再判断"><a href="#遍历得到数组然后再判断" class="headerlink" title="遍历得到数组然后再判断"></a>遍历得到数组然后再判断</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">        <span class="keyword">while</span> (head)&#123;</span><br><span class="line">            <span class="comment">//此处可以用C++ 11新特性emplace_back,性能更佳</span></span><br><span class="line">            values.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = values.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (values[i] != values[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="翻转链表后半段，然后在比较"><a href="#翻转链表后半段，然后在比较" class="headerlink" title="翻转链表后半段，然后在比较"></a>翻转链表后半段，然后在比较</h1><p>空间复杂度可以降低到O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找中点</span></span><br><span class="line">        ListNode* mid = <span class="built_in">findMid</span>(head);</span><br><span class="line">        ListNode* newMid = <span class="built_in">reverseList</span>(mid-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = newMid;</span><br><span class="line">        <span class="keyword">while</span> (p2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复原</span></span><br><span class="line">        mid-&gt;next = <span class="built_in">reverseList</span>(newMid);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找链表的中点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>数字转换为十六进制数</title>
    <url>/2022/04/02/leetcode/leetcode-convert-a-number-to-hexadecimal/</url>
    <content><![CDATA[<h1 id="牛客网进制转换"><a href="#牛客网进制转换" class="headerlink" title="牛客网进制转换"></a>牛客网进制转换</h1><p>描述<br>给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。<br>当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 ‘A’ 表示此位为 10 ， ‘B’ 表示此位为 11 。<br>若 M 为负数，应在结果中保留负号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line"><span class="comment"># @param M int整型 给定整数</span></span><br><span class="line"><span class="comment"># @param N int整型 转换到的进制</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self , M: <span class="built_in">int</span>, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> M &lt; <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            M = -M</span><br><span class="line">        digit_map = &#123;</span><br><span class="line">            <span class="number">10</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">            <span class="number">11</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">            <span class="number">12</span>: <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">            <span class="number">13</span>: <span class="string">&#x27;D&#x27;</span>,</span><br><span class="line">            <span class="number">14</span>: <span class="string">&#x27;E&#x27;</span>,</span><br><span class="line">            <span class="number">15</span>: <span class="string">&#x27;F&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = M</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> num &gt;= N:</span><br><span class="line">            tmp = num % N</span><br><span class="line"><span class="comment">#             print(num,tmp)</span></span><br><span class="line">            ans = <span class="built_in">str</span>(tmp) + ans <span class="keyword">if</span> tmp &lt; <span class="number">10</span> <span class="keyword">else</span> digit_map[tmp] + ans</span><br><span class="line"><span class="comment">#             print(&#x27;ans&#x27;, ans)</span></span><br><span class="line">            num = num // N</span><br><span class="line">        tmp = num % N</span><br><span class="line">        ans = <span class="built_in">str</span>(tmp)+ans <span class="keyword">if</span> tmp &lt; <span class="number">10</span> <span class="keyword">else</span> digit_map[tmp] + ans</span><br><span class="line">        <span class="keyword">while</span> ans[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            ans = ans[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            ans = <span class="string">&#x27;-&#x27;</span> + ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="力扣转换16进制数"><a href="#力扣转换16进制数" class="headerlink" title="力扣转换16进制数"></a>力扣转换16进制数</h1><p>这个一个位运算的题目，需要对原码、反码、补码等知识了解比较清楚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string stringBuffer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = (num &gt;&gt; (<span class="number">4</span>*i)) &amp; <span class="number">0xf</span>;</span><br><span class="line">            <span class="comment">// 当val为0时，不能为最左第一个字符，即string不能为空</span></span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> || stringBuffer.<span class="built_in">length</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span>+val) : (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+val<span class="number">-10</span>);</span><br><span class="line">                stringBuffer.<span class="built_in">push_back</span>(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>感觉用C++刷题虽然会慢一点，但是感觉会很清晰，要不后面还是用C++刷题吧</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>前K个高频单词</title>
    <url>/2022/03/31/leetcode/leetcode-top-k-frequent-words/</url>
    <content><![CDATA[<p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: words = [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k = 2<br>输出: [“i”, “love”]<br>解析: “i” 和 “love” 为出现次数最多的两个单词，均为2次。<br>    注意，按字母顺序 “i” 在 “love” 之前。<br>示例 2：</p>
<p>输入: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k = 4<br>输出: [“the”, “is”, “sunny”, “day”]<br>解析: “the”, “is”, “sunny” 和 “day” 是出现次数最多的四个单词，<br>    出现次数依次为 4, 3, 2 和 1 次。
 </p>
<p>注意：</p>
<p>1 &lt;= words.length &lt;= 500<br>1 &lt;= words[i] &lt;= 10<br>words[i] 由小写英文字母组成。<br>k 的取值范围是 [1, 不同 words[i] 的数量]
 </p>
<p>进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p>
<hr>
<h1 id="哈希表-排序"><a href="#哈希表-排序" class="headerlink" title="哈希表+排序"></a>哈希表+排序</h1><p>时间复杂度：O(nlogn)</p>
<p>python元组排序，可以一次排序完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">from</span> heapq <span class="keyword">import</span> heappush,heappushpop,heapify</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> e <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[e] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[e] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># python的元组排序是按元素的字典序排序，因为数字要求从大到小，所以需要改为负数</span></span><br><span class="line">        ans = [(-v,k) <span class="keyword">for</span> k,v <span class="keyword">in</span> hash_map.items()]</span><br><span class="line">        ans.sort()</span><br><span class="line">        <span class="keyword">return</span> [e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> ans][:k]</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<p>写法上还可以有点不一样，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">from</span> heapq <span class="keyword">import</span> heappush,heappushpop,heapify</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> e <span class="keyword">in</span> hash_map:</span><br><span class="line">                hash_map[e] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_map[e] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">sorted</span>(hash_map.items(), key=<span class="keyword">lambda</span> x: (-x[<span class="number">1</span>],x[<span class="number">0</span>]))[:k]</span><br><span class="line">        <span class="keyword">return</span> [e[<span class="number">0</span>] <span class="keyword">for</span> e <span class="keyword">in</span> ans]</span><br></pre></td></tr></table></figure>

<h1 id="哈希表-优先队列"><a href="#哈希表-优先队列" class="headerlink" title="哈希表 + 优先队列"></a>哈希表 + 优先队列</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        hash_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">from</span> heapq <span class="keyword">import</span> heappush,heappushpop,heapify</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> words:</span><br><span class="line">            hash_map[e] = hash_map.get(e, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> hash_map.keys():</span><br><span class="line">            heappush(h, (-hash_map[e], e))</span><br><span class="line">            </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            ans.append(heapq.heappop(h))</span><br><span class="line">        <span class="comment"># print(&#x27;ans&#x27;, ans)</span></span><br><span class="line">        <span class="keyword">return</span> [e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> ans]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式求值&amp;&amp;表达式计算器</title>
    <url>/2022/03/26/leetcode/leetcode-evaluate-reverse-polish-notation/</url>
    <content><![CDATA[<h1 id="1-逆波兰表达式求值"><a href="#1-逆波兰表达式求值" class="headerlink" title="1. 逆波兰表达式求值"></a>1. 逆波兰表达式求值</h1><p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：tokens = [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br>示例 2：</p>
<p>输入：tokens = [“4”,”13”,”5”,”/“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6<br>示例 3：</p>
<p>输入：tokens = [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”/“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5<br>= ((10 * (6 / (12 * -11))) + 17) + 5<br>= ((10 * (6 / -132)) + 17) + 5<br>= ((10 * 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22
 </p>
<p>提示：</p>
<p>1 &lt;= tokens.length &lt;= 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “/“），或是在范围 [-200, 200] 内的一个整数
 </p>
<p>逆波兰表达式：</p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>题目限制所有的表达式都是合法的，可以使用栈。<br>将所有的数字全部入栈，碰到符号时，弹出两个栈顶元素，计算结果后入栈。<br>注意除法只保留整数部分，对于负数的情况需要特殊处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意一个数的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(tokens[<span class="number">0</span>])</span><br><span class="line">        stack = []</span><br><span class="line">        ops = [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">in</span> ops:</span><br><span class="line">                <span class="comment"># print(token, stack)</span></span><br><span class="line">                b = stack.pop()</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    c = a + b</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    c = a - b</span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    c = a * b</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c = <span class="built_in">int</span>(a/b)</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>

<h1 id="2-表达式计算器的通用套路"><a href="#2-表达式计算器的通用套路" class="headerlink" title="2. 表达式计算器的通用套路"></a>2. 表达式计算器的通用套路</h1><p>能同时解决leetcode 224，227，772</p>
<h2 id="双栈的解法"><a href="#双栈的解法" class="headerlink" title="双栈的解法"></a>双栈的解法</h2><p>循环遍历每个元素：<br>若为空格，跳过<br>若为左括号，入栈<br>若为右括号，则计算，直到碰到左括号<br>若为数字，则入栈<br>若为符号，则先计算，直到碰到左括号，然后符号入栈</p>
<p>细节需要注意：开头为符号以及括号内开头为符号的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">ops, nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ops) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(ops) &gt; <span class="number">0</span> <span class="keyword">and</span> ops[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(nums) &gt;= <span class="number">2</span>:</span><br><span class="line">                op = ops.pop()</span><br><span class="line">                b = nums.pop()</span><br><span class="line">                a = nums.pop()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    nums.append(a+b)</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    nums.append(a-b)</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ops = collections.deque()</span><br><span class="line">        nums = collections.deque()</span><br><span class="line">        <span class="comment"># 若开头为符号，加个0方便计算</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            nums.append(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="comment"># print(&#x27;i&#x27;, i, &#x27;\n&#x27;)</span></span><br><span class="line">            e = s[i]</span><br><span class="line">            <span class="keyword">if</span> e == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> e == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                ops.append(e)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> e == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> e == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="comment"># 加入符号前，先做判断，将可以计算的部分先计算结果放入nums栈</span></span><br><span class="line">                cal(ops, nums)</span><br><span class="line">                ops.append(e)</span><br><span class="line">                <span class="comment"># 如果左括号内第一个数是符号，那先补0，方便计算</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    nums.append(<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> e == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                cal(ops, nums)</span><br><span class="line">                op = ops.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="comment"># print(&quot;-----&quot;, ops, nums)</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> <span class="string">&#x27;0&#x27;</span> &lt;= s[i] <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    num = <span class="number">10</span>*num + <span class="built_in">int</span>(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums.append(num)</span><br><span class="line">        <span class="comment"># 最后可能存在一个括号外的符号和数字需要计算</span></span><br><span class="line">        cal(ops, nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>

<p>对于+、-、*、/只需要考虑入栈时候的优先级判断即可, 但是代码细节需要做一些微调</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def calculate(self, <span class="variable">s:</span> str) -&gt; in<span class="variable">t:</span></span><br><span class="line">        def get_priority(op):</span><br><span class="line">            pair = &#123;</span><br><span class="line">                <span class="string">&#x27;+&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;-&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;*&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">&#x27;/&#x27;</span>: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pair[op]</span><br><span class="line"></span><br><span class="line">        def <span class="keyword">cal</span>(ops, nums):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ops) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ops) &gt; <span class="number">0</span> <span class="built_in">and</span> ops[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span> <span class="built_in">and</span> <span class="built_in">len</span>(nums) &gt;= <span class="number">2</span>:</span><br><span class="line">                op = ops.<span class="keyword">pop</span>()</span><br><span class="line">                <span class="keyword">b</span> = nums.<span class="keyword">pop</span>()</span><br><span class="line">                <span class="keyword">a</span> = nums.<span class="keyword">pop</span>()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    nums.<span class="keyword">append</span>(<span class="keyword">a</span>+<span class="keyword">b</span>)</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    nums.<span class="keyword">append</span>(<span class="keyword">a</span>-<span class="keyword">b</span>)</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    nums.<span class="keyword">append</span>(<span class="keyword">a</span>*<span class="keyword">b</span>)</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    nums.<span class="keyword">append</span>(<span class="keyword">int</span>(<span class="keyword">a</span>/<span class="keyword">b</span>))</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ops = []</span><br><span class="line">        nums = []</span><br><span class="line">        # 若开头为符号，加个<span class="number">0</span>方便计算</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            nums.<span class="keyword">append</span>(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">e</span> = s[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">e</span> == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            elif <span class="keyword">e</span> == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                ops.<span class="keyword">append</span>(<span class="keyword">e</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            elif <span class="keyword">e</span> in [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]:</span><br><span class="line">                # 加入符号前，先做判断，将可以计算的部分先计算结果放入nums栈</span><br><span class="line">                <span class="keyword">while</span> ops <span class="built_in">and</span> get_priority(<span class="keyword">e</span>) &lt;= get_priority(ops[-<span class="number">1</span>]):</span><br><span class="line">                    <span class="keyword">cal</span>(ops, nums)</span><br><span class="line">                ops.<span class="keyword">append</span>(<span class="keyword">e</span>)</span><br><span class="line">                # 如果左括号内第一个数是符号，那先补<span class="number">0</span>，方便计算</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="built_in">and</span> s[i-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    nums.<span class="keyword">append</span>(<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            elif <span class="keyword">e</span> == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> ops <span class="built_in">and</span> ops[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="keyword">cal</span>(ops, nums)</span><br><span class="line">                op = ops.<span class="keyword">pop</span>()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                # <span class="keyword">print</span>(<span class="string">&quot;-----&quot;</span>, ops, nums)</span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="built_in">and</span> <span class="string">&#x27;0&#x27;</span> &lt;= s[i] <span class="built_in">and</span> s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    num = <span class="number">10</span>*num + <span class="keyword">int</span>(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums.<span class="keyword">append</span>(num)</span><br><span class="line">            # <span class="keyword">print</span>(<span class="string">&#x27;i&#x27;</span>, i, ops, nums)</span><br><span class="line">        # 最后可能存在一个括号外的符号和数字需要计算</span><br><span class="line">        <span class="keyword">while</span> op<span class="variable">s:</span></span><br><span class="line">            <span class="keyword">cal</span>(ops, nums)</span><br><span class="line">        <span class="keyword">return</span> sum(nums)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/2022/03/24/leetcode/leetcode-minimum-path-sum/</url>
    <content><![CDATA[<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<hr>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>dp[i][j]表示从左上角到(i,j)位置的最短路径和<br>对于第一行，i=0, j&lt;n, dp[i][j] = dp[i][j-1]+grid[i][j]<br>对于第一列，j=0, i&lt;m, dp[i][j] = dp[i-1][j]+grid[i][j]<br>对于其他行的位置，i&lt;m, j&lt; n,<br>dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左上角的节点初始化为当前节点的值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2022/03/23/leetcode/leetcode-majority-element/</url>
    <content><![CDATA[<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[3,2,3]<br>输出：3<br>示例 2：</p>
<p>输入：[2,2,1,1,1,2,2]<br>输出：2</p>
<hr>
<h1 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        counter = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> e <span class="keyword">in</span> counter:</span><br><span class="line">                counter[e] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counter[e] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> counter[e] &gt; <span class="built_in">len</span>(nums)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h1 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h1><p>有点神奇！</p>
<p>如果数字相同就+1，不同就-1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                ans = num</span><br><span class="line">            <span class="keyword">if</span> ans == num:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h1 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2022/03/23/leetcode/leetcode-balanced-binary-tree/</url>
    <content><![CDATA[<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<hr>
<h1 id="自顶向下递归"><a href="#自顶向下递归" class="headerlink" title="自顶向下递归"></a>自顶向下递归</h1><p>递归求高度，然后判断根节点和左右子节点是否都是平衡二叉树</p>
<p>时间复杂度为O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(height(root.left), height(root.right))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left)-height(root.right))&lt;=<span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="计算高度的时候-顺便判断是否是平衡二叉树"><a href="#计算高度的时候-顺便判断是否是平衡二叉树" class="headerlink" title="计算高度的时候 顺便判断是否是平衡二叉树"></a>计算高度的时候 顺便判断是否是平衡二叉树</h1><p>-1表示非平衡二叉树，否则为高度</p>
<p>时间复杂度为O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            left = height(root.left)</span><br><span class="line">            right = height(root.right)</span><br><span class="line">            <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left-right) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right)</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>链表排序</title>
    <url>/2022/03/20/leetcode/leetcode-sort-list/</url>
    <content><![CDATA[<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<hr>
<h1 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h1><p>和数组的方式类似，时间复杂度为O(n^2)<br>对应147. 对链表进行插入排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        undo = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> undo:</span><br><span class="line">            cur = undo</span><br><span class="line">            undo = undo.<span class="built_in">next</span></span><br><span class="line">            p = dummy</span><br><span class="line">            q = dummy.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># p,q之间即为带插入的节点的位置, cur为待插入的节点</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q.val &lt; cur.val:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = q</span><br><span class="line">            p.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="自顶向下递归"><a href="#自顶向下递归" class="headerlink" title="自顶向下递归"></a>自顶向下递归</h2><p>时间复杂度O(nlogn)<br>空间复杂度O(logn)</p>
<p>对链表自顶向下归并排序的过程如下。</p>
<p>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。<br>对两个子链表分别排序。</p>
<p>将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。</p>
<p>上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 11，即当链表为空或者链表只包含 11 个节点时，不需要对链表进行拆分和排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span>(<span class="params">list1, list2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">                <span class="keyword">return</span> list2</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line">            dummy = ListNode()</span><br><span class="line">            p = dummy</span><br><span class="line">            <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">                <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                    p.<span class="built_in">next</span> = list1</span><br><span class="line">                    list1 = list1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.<span class="built_in">next</span> = list2</span><br><span class="line">                    list2 = list2.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            p.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">head, tail</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span> == tail:</span><br><span class="line">                head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            slow = head</span><br><span class="line">            fast = head</span><br><span class="line">            <span class="keyword">while</span> fast != tail:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> fast != tail:</span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">            mid = slow</span><br><span class="line">            <span class="keyword">return</span> mergeTwoList(helper(head, mid), helper(mid, tail))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(head, <span class="literal">None</span>)</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>

<h2 id="自底向上归并"><a href="#自底向上归并" class="headerlink" title="自底向上归并"></a>自底向上归并</h2><p>迭代法，写起来细节有点繁琐，留TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>验证回文串</title>
    <url>/2022/03/20/leetcode/leetcode-valid-palindrome/</url>
    <content><![CDATA[<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串<br>示例 2:</p>
<p>输入: “race a car”<br>输出: false<br>解释：”raceacar” 不是回文串</p>
<hr>
<p>一种是先过滤掉非数字和字符串的字符，然后判断<br>一种是直接判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= s &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;A&#x27;</span> &lt;= s &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> &lt;= s &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n-<span class="number">1</span></span><br><span class="line">        mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; n <span class="keyword">and</span> <span class="keyword">not</span> self.isValidChar(s[left]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; -<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> self.isValidChar(s[right]):</span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(left, right)</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> s[left].lower() != s[right].lower():</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/2022/03/20/leetcode/leetcode-maximum-depth-of-binary-tree/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p>
<h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><p>也就是广度优先</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append((root, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                p, _ = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> p.left:</span><br><span class="line">                    queue.append((p.left, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> p.right:</span><br><span class="line">                    queue.append((p.right, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        left_level = self.maxDepth(root.left)</span><br><span class="line">        right_level = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_level, right_level)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2022/03/20/leetcode/leetcode-number-of-islands/</url>
    <content><![CDATA[<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：</p>
<p>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p>
<p>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
<hr>
<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><p>遍历网格中的每个元素，如果为”1”，则答案ans计数加1，<br>同时启动深度优先遍历，将上下左右四个方向的连接元素全部标记为非”1”<br>遍历下一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, row, column</span>):</span></span><br><span class="line">            <span class="comment"># 标记着色</span></span><br><span class="line">            grid[row][column] = ans</span><br><span class="line">            <span class="comment"># 上</span></span><br><span class="line">            <span class="keyword">if</span> row&gt;<span class="number">0</span> <span class="keyword">and</span> grid[row-<span class="number">1</span>][column] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, row-<span class="number">1</span>, column)</span><br><span class="line">            <span class="comment"># 下</span></span><br><span class="line">            <span class="keyword">if</span> row &lt; rows-<span class="number">1</span> <span class="keyword">and</span> grid[row+<span class="number">1</span>][column] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, row+<span class="number">1</span>, column)</span><br><span class="line">            <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">if</span> column&gt;<span class="number">0</span> <span class="keyword">and</span> grid[row][column-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, row, column-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 右</span></span><br><span class="line">            <span class="keyword">if</span> column&lt;columns-<span class="number">1</span> <span class="keyword">and</span> grid[row][column+<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, row, column+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        rows = <span class="built_in">len</span>(grid)</span><br><span class="line">        columns = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columns):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line">        <span class="comment"># print(grid)</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>这个就是最直观的思路，<br>用一个队列存储已访问的节点，然后出队列的时候，将其上下左右方向”连通”(即值为1)的元素放入队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows = <span class="built_in">len</span>(grid)</span><br><span class="line">        columns = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columns):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    queue.append((i, j))</span><br><span class="line">                    grid[i][j] = ans</span><br><span class="line">                    queue.append((i, j))</span><br><span class="line">                    <span class="keyword">while</span> queue:</span><br><span class="line">                        row, column = queue.popleft()</span><br><span class="line">                        <span class="keyword">if</span> row&gt;<span class="number">0</span> <span class="keyword">and</span> grid[row-<span class="number">1</span>][column] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                            queue.append((row-<span class="number">1</span>, column))</span><br><span class="line">                            grid[row-<span class="number">1</span>][column] = ans</span><br><span class="line">                        <span class="keyword">if</span> row &lt; rows-<span class="number">1</span> <span class="keyword">and</span> grid[row+<span class="number">1</span>][column] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                            queue.append((row+<span class="number">1</span>, column))</span><br><span class="line">                            grid[row+<span class="number">1</span>][column] = ans</span><br><span class="line">                        <span class="keyword">if</span> column&gt;<span class="number">0</span> <span class="keyword">and</span> grid[row][column-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                            queue.append((row, column-<span class="number">1</span>))</span><br><span class="line">                            grid[row][column-<span class="number">1</span>] = ans</span><br><span class="line">                        <span class="keyword">if</span> column&lt;columns-<span class="number">1</span> <span class="keyword">and</span> grid[row][column+<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                            queue.append((row, column+<span class="number">1</span>))</span><br><span class="line">                            grid[row][column+<span class="number">1</span>] = ans</span><br><span class="line">        <span class="comment"># print(grid)</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的右视图</title>
    <url>/2022/03/20/leetcode/leetcode-binary-tree-right-side-view/</url>
    <content><![CDATA[<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h1 id="层序遍历的思路"><a href="#层序遍历的思路" class="headerlink" title="层序遍历的思路"></a>层序遍历的思路</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            ans.append(queue[size-<span class="number">1</span>].val)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="comment"># 需要用dequeue改造</span></span><br><span class="line">                p = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> p.left:</span><br><span class="line">                    queue.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.right:</span><br><span class="line">                    queue.append(p.right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h1 id="还可以用深度优先遍历的思路"><a href="#还可以用深度优先遍历的思路" class="headerlink" title="还可以用深度优先遍历的思路"></a>还可以用深度优先遍历的思路</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2022/03/19/leetcode/leetcode-trapping-rain-water/</url>
    <content><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<hr>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>从左向右记录当前值及其左边所有数的最大值，left_max<br>从右向左记录right_max</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        left_max = [height[<span class="number">0</span>]] + [<span class="number">0</span>]*(n-<span class="number">1</span>)</span><br><span class="line">        right_max = [<span class="number">0</span>]*(n-<span class="number">1</span>) + [height[-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            left_max[i] = <span class="built_in">max</span>(left_max[i-<span class="number">1</span>], height[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            right_max[i] = <span class="built_in">max</span>(right_max[i+<span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += <span class="built_in">min</span>(left_max[i], right_max[i]) - height[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>left_max和right_max只记录当前值，一次遍历即可<br>时间复杂度还是O(n)<br>空间复杂度将为O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n-<span class="number">1</span></span><br><span class="line">        left_max = <span class="number">0</span></span><br><span class="line">        right_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            left_max = <span class="built_in">max</span>(left_max, height[left])</span><br><span class="line">            right_max = <span class="built_in">max</span>(right_max, height[right])</span><br><span class="line">            <span class="keyword">if</span> left_max &lt; right_max:</span><br><span class="line">                ans += left_max - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += right_max - height[right]</span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串排列(系列)</title>
    <url>/2022/03/19/leetcode/leetcode-permutation/</url>
    <content><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p> </p>
<p>示例:</p>
<p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>其实就是穷举法</p>
<p>从左往右依次填入字符，为了避免在同一位置填入相同元素需要设置一个标记数组来记录元素访问情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s, i, n, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> visited[j] <span class="keyword">or</span> (j &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[j-<span class="number">1</span>] <span class="keyword">and</span> s[j-<span class="number">1</span>]==s[j]):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                visited[j] = <span class="literal">True</span></span><br><span class="line">                res += s[j]</span><br><span class="line">                backtrack(<span class="built_in">list</span>(s), i+<span class="number">1</span>, n, res)</span><br><span class="line">                visited[j] = <span class="literal">False</span></span><br><span class="line">                res = res[:-<span class="number">1</span>]</span><br><span class="line">        result = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        visited = [<span class="literal">False</span>]*n</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        s.sort()</span><br><span class="line">        backtrack(s, <span class="number">0</span>, n, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h1><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：<br>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]</p>
<p>示例 2：<br>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="keyword">int</span>&gt;&amp; perm, <span class="keyword">int</span> index, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i] &amp;&amp; !vis[i<span class="number">-1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">                perm.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">backtrack</span>(ans, perm, index+<span class="number">1</span>, nums);</span><br><span class="line">                vis[i] = <span class="number">0</span>;</span><br><span class="line">                perm.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(ans, perm, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>合并K个升序链表</title>
    <url>/2022/03/13/leetcode/leetcode-merge-k-sorted-lists/</url>
    <content><![CDATA[<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p>
<p>输入：lists = []<br>输出：[]<br>示例 3：</p>
<p>输入：lists = [[]]<br>输出：[]</p>
<hr>
<p>没想到居然是一个困难题</p>
<h1 id="循环使用-2个链表合并的思路处理"><a href="#循环使用-2个链表合并的思路处理" class="headerlink" title="循环使用 2个链表合并的思路处理"></a>循环使用 2个链表合并的思路处理</h1><p>时间复杂度：由于除第一个链表外，其他每个链表都要被遍历多次，<br>等差数列：<br>第一次合并后，链表长度：2n<br>第二次合并后，链表长度：3n<br>第k-1次合并后，链表长度：kn<br>合计遍历(2+k)n*(k-1)/2=O(k^2*n)</p>
<p>空间复杂度O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">list1, list2</span>):</span></span><br><span class="line">            dummy = ListNode()</span><br><span class="line">            p = dummy</span><br><span class="line">            <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">                <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                    p.<span class="built_in">next</span> = list1</span><br><span class="line">                    list1 = list1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.<span class="built_in">next</span> = list2</span><br><span class="line">                    list2 = list2.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            p.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(lists)):</span><br><span class="line">            p = mergeTwoLists(p, lists[i])</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h1 id="分治-归并"><a href="#分治-归并" class="headerlink" title="分治+归并"></a>分治+归并</h1><p>k个数组，先两两合并，然后逐步归并。<br>划分深度为logk层，每层每个数都要遍历一次，每层k*n个数<br>时间复杂度O(logk * kn)<br>空间复杂度：栈空间logk，<br>若改为递归，则实际需要kn的额外空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">list1, list2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list1: <span class="keyword">return</span> list2</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1</span><br><span class="line">            dummy = ListNode()</span><br><span class="line">            p = dummy</span><br><span class="line">            <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">                <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                    p.<span class="built_in">next</span> = list1</span><br><span class="line">                    list1 = list1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.<span class="built_in">next</span> = list2</span><br><span class="line">                    list2 = list2.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            p.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeHelper</span>(<span class="params">lists, left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left == right: <span class="keyword">return</span> lists[left]</span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">                list1 = mergeHelper(lists, left, mid)</span><br><span class="line">                list2 = mergeHelper(lists, mid+<span class="number">1</span>, right)</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists(list1, list2)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mergeHelper(lists, <span class="number">0</span>, <span class="built_in">len</span>(lists)-<span class="number">1</span>)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h1 id="同时比较k个链表中开头的值，并用最小堆优化"><a href="#同时比较k个链表中开头的值，并用最小堆优化" class="headerlink" title="同时比较k个链表中开头的值，并用最小堆优化"></a>同时比较k个链表中开头的值，并用最小堆优化</h1><p>时间复杂度：n个节点，k为最小堆的大小，每个节点必进出最小堆一次,堆调整O(logk),整体O(nlogk)<br>空间复杂度：即为堆的大小，O(logk)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line">        heaq = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heappush(heaq, (lists[i].val, i))</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        head = dummy</span><br><span class="line">        <span class="keyword">while</span> heaq:</span><br><span class="line">            _, min_index = heappop(heaq)</span><br><span class="line">            head.<span class="built_in">next</span> = lists[min_index]</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            lists[min_index] = lists[min_index].<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> lists[min_index]:</span><br><span class="line">                heappush(heaq, (lists[min_index].val, min_index))</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机-系列</title>
    <url>/2022/03/12/leetcode/leetcode-best-time-to-buy-and-sell-stock/</url>
    <content><![CDATA[<h1 id="第一种类型：买卖限制各一次"><a href="#第一种类型：买卖限制各一次" class="headerlink" title="第一种类型：买卖限制各一次"></a>第一种类型：买卖限制各一次</h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<hr>
<h2 id="暴力法-无法通过OJ"><a href="#暴力法-无法通过OJ" class="headerlink" title="暴力法 无法通过OJ"></a>暴力法 无法通过OJ</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">                tmp = prices[j] - prices[i]</span><br><span class="line">                <span class="keyword">if</span> tmp &gt; result:</span><br><span class="line">                    result = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; min_price:</span><br><span class="line">                min_price = prices[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                profit = prices[i] - min_price</span><br><span class="line">                <span class="keyword">if</span> profit &gt; result:</span><br><span class="line">                    result = profit</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="不限制买卖次数-但是持有股票不超过1支"><a href="#不限制买卖次数-但是持有股票不超过1支" class="headerlink" title="不限制买卖次数, 但是持有股票不超过1支"></a>不限制买卖次数, 但是持有股票不超过1支</h1><p> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a><br>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p>
<p> <br>示例 1:<br>输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p>示例 2:<br>输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3:<br>输入: prices = [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>收集所有的上坡即可拿到所有的收益</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++&#123;</span><br><span class="line">        ans += max(<span class="number">0</span>, prices[i]-prices[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y&#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划的思想"><a href="#动态规划的思想" class="headerlink" title="动态规划的思想"></a>动态规划的思想</h2><p>由于限制了每天的最多只能持有一只股票，所以每天手头可以拥有的股票数是0或1只。<br>分别用dp[i][0]、dp[i][1]表示第i天交易完成后手头有0和1只股票情况下的最大收益。<br>dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0])<br>dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1])</p>
<p>其中dp[0][0] = 0, dp[0][1] = -prices[0]</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">func maxProfit(prices <span class="comment">[]</span>int) int &#123;</span><br><span class="line">    dp := make(<span class="comment">[]</span><span class="comment">[2]</span>int, len(prices))</span><br><span class="line">    dp<span class="comment">[0]</span><span class="comment">[1]</span> = -prices<span class="comment">[0]</span></span><br><span class="line">    for i := 1; i &lt; len(prices); i++&#123;</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[0]</span> = max(dp<span class="comment">[i-1]</span><span class="comment">[1]</span>+prices<span class="comment">[i]</span>, dp<span class="comment">[i-1]</span><span class="comment">[0]</span>)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[1]</span> = max(dp<span class="comment">[i-1]</span><span class="comment">[0]</span>-prices<span class="comment">[i]</span>, dp<span class="comment">[i-1]</span><span class="comment">[1]</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    return dp<span class="comment">[len(prices)-1]</span><span class="comment">[0]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int&#123;</span><br><span class="line">    if x &gt; y&#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="限制只能交易2次"><a href="#限制只能交易2次" class="headerlink" title="限制只能交易2次"></a>限制只能交易2次</h1><h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> </p>
<p>示例 1:</p>
<p>输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<br>示例 2：</p>
<p>输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  <br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  <br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3：</p>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<br>示例 4：</p>
<p>输入：prices = [1]<br>输出：0</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>只允许交易两次，那么任意一天的状态可以分为5种：</p>
<ul>
<li>0次交易</li>
<li>1次买入</li>
<li>1次买入1次卖出</li>
<li>1次交易 1次买入</li>
<li>2次交易<br>第一种情况收益为0，不考虑<br>分别记为buy1，sell1，buy2，sell2，则转移方程为：<br>buy1[i] = max(buy1[i-1], -prices[i])<br>sell1[i] = max(sell1[i-1], buy[i-1]+prices[i])<br>buy2[i] = max(buy2[i-1], sell1[i-1]-prices[i])<br>sell2[i] = max(sell2[i-1], buy2[i-1]+prices[i])<br>初始化值为：<br>buy1[0] = -prices[0]<br>sell1[0] = 0<br>buy2=-prices[0]<br>sell2=0</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">func maxProfit(prices <span class="comment">[]</span>int) int &#123;</span><br><span class="line">    n := len(prices)</span><br><span class="line">    buy1 := make(<span class="comment">[]</span>int, n)</span><br><span class="line">    sell1 := make(<span class="comment">[]</span>int, n)</span><br><span class="line">    buy2 := make(<span class="comment">[]</span>int, n)</span><br><span class="line">    sell2 := make(<span class="comment">[]</span>int, n)</span><br><span class="line">    buy1<span class="comment">[0]</span>, sell1<span class="comment">[0]</span> = -prices<span class="comment">[0]</span>, 0</span><br><span class="line">    buy2<span class="comment">[0]</span>, sell2<span class="comment">[0]</span> = -prices<span class="comment">[0]</span>, 0</span><br><span class="line">    // fmt.Println(buy1,sell1, buy2, sell2)</span><br><span class="line">    for i := 1; i &lt; len(prices);i++&#123;</span><br><span class="line">        buy1<span class="comment">[i]</span> = max(buy1<span class="comment">[i-1]</span>, -prices<span class="comment">[i]</span>)</span><br><span class="line">        sell1<span class="comment">[i]</span> = max(sell1<span class="comment">[i-1]</span>, buy1<span class="comment">[i-1]</span>+prices<span class="comment">[i]</span>)</span><br><span class="line">        buy2<span class="comment">[i]</span> = max(buy2<span class="comment">[i-1]</span>, sell1<span class="comment">[i-1]</span>-prices<span class="comment">[i]</span>)</span><br><span class="line">        sell2<span class="comment">[i]</span> = max(sell2<span class="comment">[i-1]</span>, buy2<span class="comment">[i-1]</span>+prices<span class="comment">[i]</span>)</span><br><span class="line">        // fmt.Println(i, -prices<span class="comment">[i]</span>, buy1,sell1, buy2, sell2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sell1, sell2)</span><br><span class="line">    return max(sell2<span class="comment">[n-1]</span>, sell1<span class="comment">[n-1]</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="限制改为最多进行k次交易，仍然限制最多只能同时持有1只股票"><a href="#限制改为最多进行k次交易，仍然限制最多只能同时持有1只股票" class="headerlink" title="限制改为最多进行k次交易，仍然限制最多只能同时持有1只股票"></a>限制改为最多进行k次交易，仍然限制最多只能同时持有1只股票</h1><p>这块还没有特别懂</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">func maxProfit(k int, prices <span class="comment">[]</span>int) int &#123;</span><br><span class="line">    n := len(prices)</span><br><span class="line">    if n == 0&#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    buy := make(<span class="comment">[]</span><span class="comment">[]</span>int, n)</span><br><span class="line">    sell := make(<span class="comment">[]</span><span class="comment">[]</span>int, n)</span><br><span class="line">    for i, _ := range buy&#123;</span><br><span class="line">        buy<span class="comment">[i]</span> = make(<span class="comment">[]</span>int, k+1)</span><br><span class="line">        sell<span class="comment">[i]</span> = make(<span class="comment">[]</span>int, k+1)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 1; i &lt;= k; i++ &#123;</span><br><span class="line">        buy<span class="comment">[0]</span><span class="comment">[i]</span> = math.MinInt64 / 2</span><br><span class="line">        sell<span class="comment">[0]</span><span class="comment">[i]</span> = math.MinInt64 / 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    buy<span class="comment">[0]</span><span class="comment">[0]</span> = -prices<span class="comment">[0]</span></span><br><span class="line">    for i := 1; i &lt; n; i++&#123;</span><br><span class="line">        buy<span class="comment">[i]</span><span class="comment">[0]</span> = max(buy<span class="comment">[i-1]</span><span class="comment">[0]</span>, sell<span class="comment">[i-1]</span><span class="comment">[0]</span>-prices<span class="comment">[i]</span>)</span><br><span class="line">        </span><br><span class="line">        for j := 1; j &lt;= k; j++&#123;</span><br><span class="line">            buy<span class="comment">[i]</span><span class="comment">[j]</span> = max(buy<span class="comment">[i-1]</span><span class="comment">[j]</span>, sell<span class="comment">[i-1]</span><span class="comment">[j]</span>-prices<span class="comment">[i]</span>)</span><br><span class="line">            sell<span class="comment">[i]</span><span class="comment">[j]</span> = max(sell<span class="comment">[i-1]</span><span class="comment">[j]</span>, buy<span class="comment">[i-1]</span><span class="comment">[j-1]</span>+prices<span class="comment">[i]</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max(sell<span class="comment">[n-1]</span>...)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a ...int) int&#123;</span><br><span class="line">    res := a<span class="comment">[0]</span></span><br><span class="line">    for _, v := range a&#123;</span><br><span class="line">        if v &gt; res&#123;</span><br><span class="line">            res = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2022/03/12/leetcode/leetcode-min-stack/</url>
    <content><![CDATA[<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。
 </p>
<p>示例 1:</p>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：<br>[null,null,null,null,-3,null,0,-2]</p>
<p>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>
<hr>
<h1 id="辅助栈-python实现"><a href="#辅助栈-python实现" class="headerlink" title="辅助栈-python实现"></a>辅助栈-python实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(val, self.getMin()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>

<h1 id="辅助栈-go实现"><a href="#辅助栈-go实现" class="headerlink" title="辅助栈-go实现"></a>辅助栈-go实现</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">type MinStack struct &#123;</span><br><span class="line">    stack []int</span><br><span class="line">    minStack []int</span><br><span class="line">    length int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Constructor() MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        stack: []int&#123;&#125;,</span><br><span class="line">        minStack: []int&#123;math.MaxInt64&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) Push(<span class="keyword">val</span> int)  &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = append(<span class="keyword">this</span>.stack, <span class="keyword">val</span>)</span><br><span class="line">    top := <span class="keyword">this</span>.minStack[len(<span class="keyword">this</span>.minStack)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.minStack = append(<span class="keyword">this</span>.minStack, min(top, <span class="keyword">val</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) Pop()  &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = <span class="keyword">this</span>.stack[:len(<span class="keyword">this</span>.stack)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.minStack = <span class="keyword">this</span>.minStack[:len(<span class="keyword">this</span>.minStack)-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) Top() int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[len(<span class="keyword">this</span>.stack)-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) GetMin() int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minStack[len(<span class="keyword">this</span>.minStack)-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(x, y int) int &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(val);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="存储和最小值的差值"><a href="#存储和最小值的差值" class="headerlink" title="存储和最小值的差值"></a>存储和最小值的差值</h1><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_value = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            self.stack.append(<span class="number">0</span>)</span><br><span class="line">            self.min_value = val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        diff = val - self.min_value</span><br><span class="line">        <span class="comment"># 当出现更小的数时，此时更新min_value</span></span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">            self.min_value = val</span><br><span class="line">        self.stack.append(diff)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        diff = self.stack.pop()</span><br><span class="line">        top = self.min_value + diff</span><br><span class="line">        <span class="comment"># 弹出时为负数，此时最小值即为栈顶值</span></span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">            top = self.min_value</span><br><span class="line">            self.min_value = self.min_value - diff</span><br><span class="line">        <span class="keyword">return</span> top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        diff = self.stack[-<span class="number">1</span>]</span><br><span class="line">        top = self.min_value + diff</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">            top = self.min_value</span><br><span class="line">        <span class="keyword">return</span> top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.min_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>

<h2 id="go实现"><a href="#go实现" class="headerlink" title="go实现"></a>go实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type MinStack struct &#123;</span><br><span class="line">    stack []int</span><br><span class="line">    minValue int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Constructor() MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        stack: []int&#123;&#125;,</span><br><span class="line">        minValue: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) Push(<span class="keyword">val</span> int)  &#123;</span><br><span class="line">    <span class="keyword">if</span> len(<span class="keyword">this</span>.stack) == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = append(<span class="keyword">this</span>.stack, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">this</span>.minValue = <span class="keyword">val</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        diff := <span class="keyword">val</span> - <span class="keyword">this</span>.minValue</span><br><span class="line">        <span class="keyword">this</span>.stack = append(<span class="keyword">this</span>.stack, diff)</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.minValue = <span class="keyword">val</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) Pop()  &#123;</span><br><span class="line">    <span class="keyword">if</span> len(<span class="keyword">this</span>.stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        diff := <span class="keyword">this</span>.stack[len(<span class="keyword">this</span>.stack)-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.minValue = <span class="keyword">this</span>.minValue - diff</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">this</span>.stack[:len(<span class="keyword">this</span>.stack)-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) Top() int &#123;</span><br><span class="line">    <span class="keyword">if</span> len(<span class="keyword">this</span>.stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        diff := <span class="keyword">this</span>.stack[len(<span class="keyword">this</span>.stack)-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>&#123;</span><br><span class="line">            top := <span class="keyword">this</span>.minValue</span><br><span class="line">            <span class="keyword">return</span> top</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            top := diff + <span class="keyword">this</span>.minValue</span><br><span class="line">            <span class="keyword">return</span> top</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (<span class="keyword">this</span> *MinStack) GetMin() int &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(val);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组(系列)</title>
    <url>/2022/03/12/leetcode/leetcode-search-in-rotated-sorted-array/</url>
    <content><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p> </p>
<p>示例 1：<br>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p>
<p>示例 2：<br>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p>
<p>示例 3：<br>输入：nums = [1], target = 0<br>输出：-1</p>
<hr>
<h2 id="python语言"><a href="#python语言" class="headerlink" title="python语言"></a>python语言</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line">        <span class="comment"># 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            <span class="keyword">mid</span> = low + (high-low<span class="comment">)//2</span></span><br><span class="line">            print(<span class="string">&#x27;low,high,mid&#x27;</span>, low, high, <span class="keyword">mid</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="keyword">mid</span>] == target:</span><br><span class="line">                <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">            elif nums[low] &lt;= nums[<span class="keyword">mid</span>]:</span><br><span class="line">                <span class="comment"># 左半有序 且目标值在左部分</span></span><br><span class="line">                <span class="keyword">if</span> nums[low] &lt;= target &lt; nums[<span class="keyword">mid</span>]:</span><br><span class="line">                    high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 右半有序 且目标值在右部分</span></span><br><span class="line">                <span class="keyword">if</span> nums[high] &gt;= target &gt; nums[<span class="keyword">mid</span>]:</span><br><span class="line">                    low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">        <span class="literal">return</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="go语言"><a href="#go语言" class="headerlink" title="go语言"></a>go语言</h2><p>go的执行效率比python真是高太多了</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">func search(nums []<span class="keyword">int</span>, <span class="built_in">target</span> <span class="keyword">int</span>) <span class="keyword">int</span> &#123;</span><br><span class="line">    low, high := <span class="number">0</span>, len(nums)-<span class="number">1</span></span><br><span class="line">    <span class="comment">// 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line">    <span class="comment">// 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span></span><br><span class="line">    <span class="comment">// fmt.Println(low, high)</span></span><br><span class="line">    <span class="comment">// print(low, high)</span></span><br><span class="line">    <span class="keyword">for</span> low &lt;= high&#123;</span><br><span class="line">        mid := low + (high-low)/<span class="number">2</span></span><br><span class="line">        <span class="comment">// fmt.Println(low, mid, highc)</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == <span class="built_in">target</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[low] &lt;= nums[mid]&#123;    <span class="comment">//左半数组有序, 注意&lt;=</span></span><br><span class="line">            <span class="keyword">if</span> nums[low] &lt;= <span class="built_in">target</span> &amp;&amp; <span class="built_in">target</span> &lt; nums[mid]&#123;</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> nums[high] &gt;= <span class="built_in">target</span> &amp;&amp; <span class="built_in">target</span> &gt; nums[mid]&#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fmt.Println(&quot;-----&quot;, low, mid, high)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>旋转后，每次二分的时候，一定会得到一半是有序一半是无序的数组，如果目标值落在有序部分，则可以按照经典二分处理，否则在无序部分再二分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[low] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 结果在左半边有序的这部分，注意包含左边界</span></span><br><span class="line">                <span class="keyword">if</span> (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 结果在右半边有序的这部分，注意包含右边界</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h1><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p>
<p>你必须尽可能减少整个操作步骤。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [2,5,6,0,0,1,2], target = 0<br>输出：true<br>示例 2：</p>
<p>输入：nums = [2,5,6,0,0,1,2], target = 3<br>输出：false</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 核心在于 如果有重复的数，可能导致无法判断哪边是有序的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[low] == nums[mid] &amp;&amp; nums[high] == nums[mid])&#123;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[low] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 结果在左半边有序的这部分，注意包含左边界</span></span><br><span class="line">                <span class="keyword">if</span> (nums[low] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 结果在右半边有序的这部分，注意包含右边界</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[high]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [3,4,5,1,2]<br>输出：1<br>解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br>示例 2：</p>
<p>输入：nums = [4,5,6,7,0,1,2]<br>输出：0<br>解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。<br>示例 3：</p>
<p>输入：nums = [11,13,15,17]<br>输出：11<br>解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p>
<p>提示：</p>
<p>n == nums.length<br>1 &lt;= n &lt;= 5000<br>-5000 &lt;= nums[i] &lt;= 5000<br>nums 中的所有整数 互不相同<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 左边有序，left即为左边最小值，需要去右边找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[left]);</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 右边有序，mid即为右边最小值，需要去左边找</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[mid]);</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a>154. 寻找旋转排序数组中的最小值 II</h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p>你必须尽可能减少整个过程的操作步骤。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,3,5]<br>输出：1<br>示例 2：</p>
<p>输入：nums = [2,2,2,0,1]<br>输出：0
 </p>
<p>提示：</p>
<p>n == nums.length<br>1 &lt;= n &lt;= 5000<br>-5000 &lt;= nums[i] &lt;= 5000<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 重复数字会导致无法判断左右哪边是否有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[mid]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[left]);</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[mid]);</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种逐渐逼近的思路，但是容易出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 如果全局有序，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[right]) <span class="keyword">return</span> nums[left];</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 重复数字会导致无法判断左右哪边是否有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">// 如果左边有序，由于全局无序，则右边必无序，最小值在右边</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 左边无序，右边有序，mid即为右边最小值</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right;</span></span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>求X 的平方根</title>
    <url>/2022/03/12/leetcode/leetcode-sqrtx/</url>
    <content><![CDATA[<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x = 4<br>输出：2<br>示例 2：</p>
<p>输入：x = 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p>
<hr>
<h1 id="二分查找的方法"><a href="#二分查找的方法" class="headerlink" title="二分查找的方法"></a>二分查找的方法</h1><p>在0和x中查找</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">func mySqrt(x <span class="built_in">int</span>) <span class="built_in">int</span> &#123;</span><br><span class="line">    l, r <span class="symbol">:</span>= <span class="number">0</span>, x</span><br><span class="line">    ans <span class="symbol">:</span>= -<span class="number">1</span></span><br><span class="line">    for l &lt;= r&#123;</span><br><span class="line">        <span class="built_in">mid</span> <span class="symbol">:</span>= l + (r-l)/<span class="number">2</span></span><br><span class="line">        <span class="built_in">if</span> <span class="built_in">mid</span>*<span class="built_in">mid</span> &lt;= x&#123;</span><br><span class="line">            ans = <span class="built_in">mid</span></span><br><span class="line">            l = <span class="built_in">mid</span> + <span class="number">1</span></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            r = <span class="built_in">mid</span> - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="袖珍计算器算法"><a href="#袖珍计算器算法" class="headerlink" title="袖珍计算器算法"></a>袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp 和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/2022/03/12/leetcode/leetcode-longest-increasing-subsequence/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p> <br>示例 1：</p>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums = [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>C++语言版本</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[j] 表示以j结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; nums[j])&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>go语言版本</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="number">0</span>;</span><br><span class="line">    length := <span class="built_in">len</span>(nums);</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, length);</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length; j++&#123;</span><br><span class="line">        dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; j; i++&#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[j]&#123;</span><br><span class="line">                <span class="keyword">if</span> dp[i]+<span class="number">1</span> &gt; dp[j]&#123;</span><br><span class="line">                    dp[j] = dp[i]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dp[j] &gt; result&#123;</span><br><span class="line">            result = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python3语言版本</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, num<span class="variable">s:</span> List[<span class="keyword">int</span>]) -&gt; in<span class="variable">t:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">dp</span> = [<span class="number">1</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, <span class="keyword">j</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[<span class="keyword">j</span>] <span class="built_in">and</span> <span class="keyword">dp</span>[i]+<span class="number">1</span> &gt; <span class="keyword">dp</span>[<span class="keyword">j</span>]:</span><br><span class="line">                    <span class="keyword">dp</span>[<span class="keyword">j</span>] = <span class="keyword">dp</span>[i]+<span class="number">1</span></span><br><span class="line">            result = <span class="keyword">dp</span>[<span class="keyword">j</span>] <span class="keyword">if</span> <span class="keyword">dp</span>[<span class="keyword">j</span>] &gt; result <span class="keyword">else</span> result</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution:</span><br><span class="line">    def lengthOfLIS(self, nums: <span class="keyword">List</span>[int]) -&gt; int:</span><br><span class="line">        # 开一个栈，每次取栈顶元素top和读到的元素temp做比较，如果temp &gt; top 则将temp入栈；如果temp &lt; top则二分查找栈中的比temp大的第1个数，并用temp替换它。 最长序列长度即为栈的大小top。</span><br><span class="line">        <span class="keyword">stack</span> = <span class="keyword">list</span>()</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">e</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> not <span class="keyword">stack</span> or <span class="keyword">stack</span>[-1] &lt; <span class="keyword">e</span>:</span><br><span class="line">                <span class="keyword">stack</span>.<span class="keyword">append</span>(<span class="keyword">e</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                # 二分查找，寻找第一个大于<span class="keyword">e</span>的数</span><br><span class="line">                low = 0</span><br><span class="line">                high = len(<span class="keyword">stack</span>) - 1</span><br><span class="line">                <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">                    mid = low + (high-low)<span class="comment">//2</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">e</span> &gt; <span class="keyword">stack</span>[mid]:</span><br><span class="line">                        low = mid + 1</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        high = mid -1</span><br><span class="line">                <span class="keyword">stack</span>[low] = <span class="keyword">e</span></span><br><span class="line">        <span class="keyword">return</span> len(<span class="keyword">stack</span>)</span><br></pre></td></tr></table></figure>

<h1 id="输出最长子序列个数"><a href="#输出最长子序列个数" class="headerlink" title="输出最长子序列个数"></a>输出最长子序列个数</h1><p>TODO</p>
<h1 id="输出所有最长子序列"><a href="#输出所有最长子序列" class="headerlink" title="输出所有最长子序列"></a>输出所有最长子序列</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>从前序与中序遍历序列构造二叉树</title>
    <url>/2022/03/10/leetcode/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal/</url>
    <content><![CDATA[<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<hr>
<h1 id="递归的思路"><a href="#递归的思路" class="headerlink" title="递归的思路"></a>递归的思路</h1><p>但是这里面的细节需要一些优化才能通过OJ</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &lt;=<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(inorder) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        root_val = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        </span><br><span class="line">        inorder_dict = &#123;v:k <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        inorder_index = inorder_dict[root_val]</span><br><span class="line">        left_tree_num = inorder_index</span><br><span class="line">        right_tree_num = <span class="built_in">len</span>(inorder) - inorder_index - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        root.left = self.buildTree(<span class="built_in">list</span>(preorder[<span class="number">1</span>:left_tree_num+<span class="number">1</span>]), <span class="built_in">list</span>(inorder[:inorder_index]))</span><br><span class="line">        root.right = self.buildTree(<span class="built_in">list</span>(preorder[<span class="number">1</span>+left_tree_num:]), <span class="built_in">list</span>(inorder[inorder_index+<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2022/03/08/leetcode/leetcode-3sum/</url>
    <content><![CDATA[<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p>
<p>输入：nums = []<br>输出：[]<br>示例 3：</p>
<p>输入：nums = [0]<br>输出：[]</p>
<hr>
<h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><p>无法通过OJ</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>, n):</span><br><span class="line">                    <span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span>:</span><br><span class="line">                        tmp = [nums[i], nums[j], nums[k]]</span><br><span class="line">                        tmp.sort()</span><br><span class="line">                        <span class="keyword">if</span> tmp <span class="keyword">in</span> result:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        result.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="先排序然后双指针"><a href="#先排序然后双指针" class="headerlink" title="先排序然后双指针"></a>先排序然后双指针</h1><p>j代表的循环，双指针，k均摊到每次需要移动1次，所以本轮循环时间复杂度为O(n)<br>排序时间复杂度O(nlogn), 两轮循环时间复杂度O(n^2)<br>整体取大值为时间复杂度O(n^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># print(n,i)</span></span><br><span class="line">            target = -nums[i]</span><br><span class="line">            k = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 需要保证j和前一个不同</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 选定i,j后选k</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] + nums[j] &gt; target:</span><br><span class="line">                    k = k - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[k] + nums[j] == target:</span><br><span class="line">                    result.append([nums[i],nums[j],nums[k]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">int</span> k = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] + nums[k] &gt;target)&#123;</span><br><span class="line">                    k = k - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == k)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] + nums[k] == target)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2022/03/07/leetcode/leetcode-longest-palindromic-substring/</url>
    <content><![CDATA[<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p>
<p>输入：s = “cbbd”<br>输出：”bb”</p>
<hr>
<h1 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, i, j</span>):</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; length <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                i = i - <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>, j-<span class="number">1</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            left,right = helper(s, i, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> right -left &gt;= count:</span><br><span class="line">                count = right - left</span><br><span class="line">                result = s[left:right+<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 这个地方比较巧妙</span></span><br><span class="line">            left,right = helper(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> right -left &gt;= count:</span><br><span class="line">                count = right - left</span><br><span class="line">                result = s[left:right+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="动态规划的方法"><a href="#动态规划的方法" class="headerlink" title="动态规划的方法"></a>动态规划的方法</h1><p>1.长度为1的串 必然为回文串<br>2.长度为2的串 如果字母相同也是回文串<br>3.如果s[i+1, j-1]是回文串且s[i]==s[j]则s[i, j]也是回文串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        max_length = <span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># L 表示子串长度</span></span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i表示左index，j表示右index</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                j = L + i - <span class="number">1</span></span><br><span class="line">                <span class="comment"># j非法时，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                    dp[i][j] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> L &lt;= <span class="number">2</span>:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> L &gt; max_length:</span><br><span class="line">                    max_length = L</span><br><span class="line">                    left = i</span><br><span class="line">        <span class="keyword">return</span> s[left:left+max_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数</title>
    <url>/2022/03/07/leetcode/leetcode-fibonacci-number/</url>
    <content><![CDATA[<p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给定 n ，请计算 F(n) 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1<br>示例 2：</p>
<p>输入：n = 3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2<br>示例 3：</p>
<p>输入：n = 4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p>
<hr>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.fib(n-<span class="number">1</span>) + self.fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h1 id="动态规划-滚动数组"><a href="#动态规划-滚动数组" class="headerlink" title="动态规划+滚动数组"></a>动态规划+滚动数组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        q = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            p = q</span><br><span class="line">            q = r</span><br><span class="line">            r = p + q</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2022/03/07/leetcode/leetcode-spiral-matrix/</url>
    <content><![CDATA[<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>示例 1：<br>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
<p>示例 2：<br>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<hr>
<h1 id="四次旋转模拟法"><a href="#四次旋转模拟法" class="headerlink" title="四次旋转模拟法"></a>四次旋转模拟法</h1><p>第一次：从左到右，横坐标不变，纵坐标+1<br>第二次：从上到下，纵坐标不变，横坐标+1<br>第三次：从右到左，横坐标不变，纵坐标-1<br>第四次：从下到上，纵坐标不变，横坐标-1</p>
<p>思路比较清晰，比较容易理解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        columns = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        total = rows * columns</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = columns - <span class="number">1</span></span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        bottom = rows - <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> total &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 通过总数控制循环是否停止</span></span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># print(top, i)</span></span><br><span class="line">                result.append(matrix[top][i])</span><br><span class="line">                total = total - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 每次循环完成后，某一个坐标需要改变</span></span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># print(i, right)</span></span><br><span class="line">                result.append(matrix[i][right])</span><br><span class="line">                total = total - <span class="number">1</span></span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># print(bottom, i)</span></span><br><span class="line">                result.append(matrix[bottom][i])</span><br><span class="line">                total = total - <span class="number">1</span></span><br><span class="line">            bottom = bottom - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># print(&quot;----&quot;, i, left)</span></span><br><span class="line">                result.append(matrix[i][left])</span><br><span class="line">                total = total - <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="逻辑优化后的模拟"><a href="#逻辑优化后的模拟" class="headerlink" title="逻辑优化后的模拟"></a>逻辑优化后的模拟</h1><p>其实代码初始理解起来并不直观，但是写起来比较舒适</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        columns = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        total = rows * columns</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="literal">False</span>]*columns <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        column = <span class="number">0</span></span><br><span class="line">        direction_index = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            result.append(matrix[row][column])</span><br><span class="line">            visited[row][column] = <span class="literal">True</span></span><br><span class="line">            next_row = row + directions[direction_index][<span class="number">0</span>]</span><br><span class="line">            next_column = column + directions[direction_index][<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 如果超出边界或者数据已经访问过，则表示需要转换规则</span></span><br><span class="line">            <span class="keyword">if</span> next_row &gt;= rows <span class="keyword">or</span> next_row &lt; <span class="number">0</span> <span class="keyword">or</span> next_column &gt;= columns <span class="keyword">or</span> next_column &lt; <span class="number">0</span> <span class="keyword">or</span> visited[next_row][next_column]:</span><br><span class="line">                direction_index = (direction_index+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">            </span><br><span class="line">            row += directions[direction_index][<span class="number">0</span>]</span><br><span class="line">            column += directions[direction_index][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="按层模拟"><a href="#按层模拟" class="headerlink" title="按层模拟"></a>按层模拟</h1><p>可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。<br>定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。<br>访问完一层以后，再访问里面一层，也算是一个思路。但是其实没有第一种直观。</p>
<p>(略过, 后面再训练这种思路)</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串</title>
    <url>/2022/03/07/leetcode/leetcode-reverse-string/</url>
    <content><![CDATA[<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]
 </p>
<hr>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>; i &lt; n/<span class="number">2</span>; i++, j--)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a>541. 反转字符串 II</h1><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
 </p>
<p>示例 1：</p>
<p>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”<br>示例 2：</p>
<p>输入：s = “abcd”, k = 2<br>输出：”bacd”
 </p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i, s.<span class="built_in">begin</span>()+<span class="built_in">min</span>(i+k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a>557. 反转字符串中的单词 III</h1><p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”<br>示例 2:</p>
<p>输入： s = “God Ding”<br>输出：”doG gniD”</p>
<hr>
<p>直接原地一趟翻转每个单词</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> end = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; start &lt;&lt; &quot; &quot; &lt;&lt; end &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[start], s[end]);</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="NC89-字符串变形"><a href="#NC89-字符串变形" class="headerlink" title="NC89 字符串变形"></a>NC89 字符串变形</h1><p>描述<br>对于一个长度为 n 字符串，我们需要对它做一些变形。</p>
<p>首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。</p>
<p>比如”Hello World”变形后就变成了”wORLD hELLO”。</p>
<p>字符串中包括大写英文字母、小写英文字母、空格。<br>进阶：空间复杂度 O(n)O(n) ， 时间复杂度 O(n)O(n)</p>
<p>输入描述：<br>给定一个字符串s以及它的长度n(1 ≤ n ≤ 10^6)<br>返回值描述：<br>请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。</p>
<p>示例1<br>输入：<br>“This is a sample”,16<br>返回值：<br>“SAMPLE A IS tHIS”</p>
<p>示例2<br>输入：<br>“nowcoder”,8<br>返回值：<br>“NOWCODER”</p>
<p>示例3<br>输入：<br>“iOS”,3<br>返回值：<br>“Ios”</p>
<hr>
<p>两次翻转：先整体翻转，然后每个单词翻转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">trans</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] &gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; s[j] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                    s[j] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s[j] -= <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i, s.<span class="built_in">begin</span>()+j);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/2022/03/06/leetcode/leetcode-lowest-common-ancestor-of-a-binary-tree/</url>
    <content><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<hr>
<h1 id="递归的思路"><a href="#递归的思路" class="headerlink" title="递归的思路"></a>递归的思路</h1><p>公共祖先有两种情况：<br>1.因为p节点和q节点都是不同且唯一的节点, p和q分别位于左和右子树，则根节点为公共祖先<br>2.p或者q为根节点，另一个节点在左或右子树中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val == p.val <span class="keyword">or</span> root.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left_node = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right_node = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left_node:</span><br><span class="line">            <span class="keyword">return</span> right_node</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> left_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left_node <span class="keyword">and</span> right_node:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h1 id="哈希表存储父节点"><a href="#哈希表存储父节点" class="headerlink" title="哈希表存储父节点"></a>哈希表存储父节点</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, father_dict</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                father_dict[root.left.val] = root</span><br><span class="line">                helper(root.left, father_dict)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                father_dict[root.right.val] = root</span><br><span class="line">                helper(root.right, father_dict)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        father_dict = <span class="built_in">dict</span>()</span><br><span class="line">        father_dict[root.val] = <span class="literal">None</span></span><br><span class="line">        helper(root, father_dict)</span><br><span class="line">        path = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            path[p.val] = <span class="number">1</span></span><br><span class="line">            p = father_dict[p.val]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q.val <span class="keyword">in</span> path:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            q = father_dict[q.val]</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>链表两数相加</title>
    <url>/2022/03/04/leetcode/leetcode-add-two-numbers/</url>
    <content><![CDATA[<h1 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h2 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h2><p>思路比较清晰，按照加法的方式顺序处理即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        p = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            l1_val = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l2_val = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = l1_val + l2_val + carry</span><br><span class="line">            l_tmp = ListNode(tmp%<span class="number">10</span>)</span><br><span class="line">            carry = tmp//<span class="number">10</span></span><br><span class="line">            p.<span class="built_in">next</span> = l_tmp</span><br><span class="line">            p = l_tmp</span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h1><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<hr>
<h1 id="同样是模拟法-不过需要考虑使用栈"><a href="#同样是模拟法-不过需要考虑使用栈" class="headerlink" title="同样是模拟法 不过需要考虑使用栈"></a>同样是模拟法 不过需要考虑使用栈</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        l1_stack = []</span><br><span class="line">        l2_stack = []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            l1_stack.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            l2_stack.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        <span class="keyword">while</span> l1_stack <span class="keyword">or</span> l2_stack <span class="keyword">or</span> carry:</span><br><span class="line">            l1_val = l1_stack.pop() <span class="keyword">if</span> l1_stack <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l2_val = l2_stack.pop() <span class="keyword">if</span> l2_stack <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = l1_val + l2_val + carry</span><br><span class="line">            tmp_Node = ListNode(tmp%<span class="number">10</span>)</span><br><span class="line">            carry = tmp//<span class="number">10</span></span><br><span class="line">            tmp_Node.<span class="built_in">next</span> = dummy.<span class="built_in">next</span></span><br><span class="line">            dummy.<span class="built_in">next</span> = tmp_Node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的第一个公共结点</title>
    <url>/2022/03/03/leetcode/leetcode-intersection-of-two-linked-lists/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：<br>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<hr>
<h1 id="直观解法"><a href="#直观解法" class="headerlink" title="直观解法"></a>直观解法</h1><p>先计算长度，然后长链表先走，最后一起走</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        p = headA</span><br><span class="line">        q = headB</span><br><span class="line">        <span class="comment"># 先计算各自长度</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        p = headA</span><br><span class="line">        q = headB</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a,b&#x27;</span>, a, b)</span><br><span class="line">        c = a - b</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            p = headA</span><br><span class="line">            q = headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = headB</span><br><span class="line">            q = headA</span><br><span class="line">            c = -c</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 长链表先走，然后一起走 </span></span><br><span class="line">        <span class="keyword">while</span> c:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            c = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h1 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        a_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> headA:</span><br><span class="line">            a_dict[headA] = <span class="number">1</span></span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> headB:</span><br><span class="line">            <span class="keyword">if</span> headB <span class="keyword">in</span> a_dict:</span><br><span class="line">                <span class="keyword">return</span> headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                headB = headB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h1 id="双指针法，比较巧妙"><a href="#双指针法，比较巧妙" class="headerlink" title="双指针法，比较巧妙"></a>双指针法，比较巧妙</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pA = headA</span><br><span class="line">        pB = headB</span><br><span class="line">        <span class="keyword">while</span> pA != pB:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pA:</span><br><span class="line">                pA = headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pA = pA.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pB:</span><br><span class="line">                pB = headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pB = pB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pA</span><br><span class="line">        </span><br><span class="line">            </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2022/03/03/leetcode/leetcode-longest-common-subsequence/</url>
    <content><![CDATA[<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p>示例 1：<br>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
<p>示例 2：<br>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。</p>
<p>示例 3：<br>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p>
<hr>
<h1 id="动态规划的解法"><a href="#动态规划的解法" class="headerlink" title="动态规划的解法"></a>动态规划的解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(text1)</span><br><span class="line">        n = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line">                </span><br></pre></td></tr></table></figure>


<h1 id="输出最长子序列"><a href="#输出最长子序列" class="headerlink" title="输出最长子序列"></a>输出最长子序列</h1><p>输出所有的最长子序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traceBack</span>(<span class="params">self, i, j, text1, text2, dp, path, ans</span>):</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                path.appendleft(text1[i-<span class="number">1</span>])</span><br><span class="line">                i = i - <span class="number">1</span>;</span><br><span class="line">                j = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 上方的大</span></span><br><span class="line">                <span class="keyword">if</span> dp[i-<span class="number">1</span>][j] &gt; dp[i][j-<span class="number">1</span>]:</span><br><span class="line">                    i = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> dp[i-<span class="number">1</span>][j] &lt; dp[i][j-<span class="number">1</span>]:   <span class="comment"># 左边大</span></span><br><span class="line">                    j = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.traceBack(i-<span class="number">1</span>, j, text1, text2, dp, collections.deque(path), ans)</span><br><span class="line">                    self.traceBack(i, j-<span class="number">1</span>, text1, text2, dp, collections.deque(path), ans)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">        ans.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(text1)</span><br><span class="line">        n = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        path = collections.deque()</span><br><span class="line">        ans = []</span><br><span class="line">        self.traceBack(m, n, text1, text2, dp, path, ans)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子串(最长重复子数组)</title>
    <url>/2022/02/27/leetcode/leetcode-maximum-length-of-repeated-subarray/</url>
    <content><![CDATA[<p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p>
<hr>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>这种解法过于粗暴，无法通过OJ</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">                k = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i+k &lt; <span class="built_in">len</span>(nums1) <span class="keyword">and</span> j+k &lt; <span class="built_in">len</span>(nums2) <span class="keyword">and</span> nums1[i+k] == nums2[j+k]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, k)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="不太优雅的滑动窗口？"><a href="#不太优雅的滑动窗口？" class="headerlink" title="不太优雅的滑动窗口？"></a>不太优雅的滑动窗口？</h1><p>分别使用A数组的每一个数为起点与B数组比较，如果数字相同计数加1<br>然后交换A B重新比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            i = offset</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> nums1[i] == nums2[j]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            j = offset</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="comment"># print(&#x27;i, j, count&#x27;, i, j, count)</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> nums1[i] == nums2[j]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>假设已经对齐了两个数组的起点，我们就可以对两个数组进行一趟遍历，求得最长的数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">start1, start2, length</span>):</span></span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">if</span> nums1[start1+i] == nums2[start2+i]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = <span class="number">0</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, k)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            length = <span class="built_in">min</span>(m-i, n)</span><br><span class="line">            <span class="comment"># 小优化，length如果小于ans，则无需比较了</span></span><br><span class="line">            <span class="keyword">if</span> length &gt; ans:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, helper(i, <span class="number">0</span>, length))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            length = <span class="built_in">min</span>(n-i, m)</span><br><span class="line">            <span class="keyword">if</span> length &gt; ans:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, helper(<span class="number">0</span>, i, length))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><p>dp[i][j] 表示长度为i，结尾index为i-1的nums1数组与长度为j，结尾index为j-1的nums2数组的最长公共子数组的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                ans = <span class="built_in">max</span>(dp[i][j], ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="动态规划算法优化"><a href="#动态规划算法优化" class="headerlink" title="动态规划算法优化"></a>动态规划算法优化</h1><p>发现上述dp其实每次只依赖上一行左上角的值，也就是内层循环。可以优化一下空间复杂度。<br>但是为了避免左上角的值被覆盖，内层循环需要从右向左计算。</p>
<p>可以将空间复杂度降低为O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = dp[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                ans = <span class="built_in">max</span>(dp[j], ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="二分法-hash"><a href="#二分法-hash" class="headerlink" title="二分法+hash"></a>二分法+hash</h1><p>TODO</p>
<h1 id="输出子串"><a href="#输出子串" class="headerlink" title="输出子串"></a>输出子串</h1><p>TODO</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>之字型层序打印二叉树</title>
    <url>/2022/02/27/leetcode/leetcode-zhi-levelOrder/</url>
    <content><![CDATA[<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<hr>
<h1 id="结果集双端队列，避免翻转"><a href="#结果集双端队列，避免翻转" class="headerlink" title="结果集双端队列，避免翻转"></a>结果集双端队列，避免翻转</h1><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="literal">return</span> ans</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        flag = False</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="built_in">length</span> = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 结果集也用双端队列，省去一次翻转动作</span></span><br><span class="line">            <span class="built_in">result</span> = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">length</span>):</span><br><span class="line">                p = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="built_in">result</span>.appendleft(p.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">result</span>.append(p.val)</span><br><span class="line">                <span class="keyword">if</span> p.left:</span><br><span class="line">                    queue.append(p.left)</span><br><span class="line">                <span class="keyword">if</span> p.<span class="literal">right</span>:</span><br><span class="line">                    queue.append(p.<span class="literal">right</span>) </span><br><span class="line">            ans.append(list(<span class="built_in">result</span>))</span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line">        <span class="literal">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双端队列-奇偶层逻辑分离"><a href="#双端队列-奇偶层逻辑分离" class="headerlink" title="双端队列 奇偶层逻辑分离"></a>双端队列 奇偶层逻辑分离</h1><p>可以实际画一个双端队列感受一下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> <span class="keyword">a</span> binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, <span class="keyword">x</span>):</span><br><span class="line">#         self.val = <span class="keyword">x</span></span><br><span class="line">#         self.<span class="keyword">left</span> = None</span><br><span class="line">#         self.<span class="keyword">right</span> = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, roo<span class="variable">t:</span> TreeNode) -&gt; List[List[<span class="keyword">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.<span class="keyword">append</span>(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            # 处理奇数层 从左向右打印 从左向右添加下层节点</span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            result = <span class="keyword">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">p</span> = queue.popleft()</span><br><span class="line">                result.<span class="keyword">append</span>(<span class="keyword">p</span>.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.lef<span class="variable">t:</span></span><br><span class="line">                    queue.<span class="keyword">append</span>(<span class="keyword">p</span>.<span class="keyword">left</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.righ<span class="variable">t:</span></span><br><span class="line">                    queue.<span class="keyword">append</span>(<span class="keyword">p</span>.<span class="keyword">right</span>) </span><br><span class="line">            ans.<span class="keyword">append</span>(<span class="keyword">list</span>(result))</span><br><span class="line">            <span class="keyword">if</span> not queue:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            # 处理偶数层 从右向左打印 从右向左添加下层节点</span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            result = <span class="keyword">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">p</span> = queue.<span class="keyword">pop</span>()</span><br><span class="line">                result.<span class="keyword">append</span>(<span class="keyword">p</span>.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.righ<span class="variable">t:</span></span><br><span class="line">                    queue.appendleft(<span class="keyword">p</span>.<span class="keyword">right</span>) </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.lef<span class="variable">t:</span></span><br><span class="line">                    queue.appendleft(<span class="keyword">p</span>.<span class="keyword">left</span>)</span><br><span class="line">            ans.<span class="keyword">append</span>(<span class="keyword">list</span>(result))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>大数加法</title>
    <url>/2022/02/27/leetcode/leetcode-add-strings/</url>
    <content><![CDATA[<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：num1 = “11”, num2 = “123”<br>输出：”134”<br>示例 2：</p>
<p>输入：num1 = “456”, num2 = “77”<br>输出：”533”<br>示例 3：</p>
<p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p>
<hr>
<p>大数加法</p>
<h1 id="模拟的思路"><a href="#模拟的思路" class="headerlink" title="模拟的思路"></a>模拟的思路</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">class</span> Solution:</span><br><span class="line">    <span class="attribute">def</span> addStrings(self, num<span class="number">1</span>: str, num<span class="number">2</span>: str) -&gt; str:</span><br><span class="line">        <span class="attribute">if</span> not num<span class="number">1</span>:</span><br><span class="line">            <span class="attribute">return</span> num<span class="number">2</span></span><br><span class="line">        <span class="attribute">if</span> not num<span class="number">2</span>:</span><br><span class="line">            <span class="attribute">return</span> num<span class="number">1</span></span><br><span class="line">        <span class="attribute">i</span> = len(num<span class="number">1</span>)-<span class="number">1</span></span><br><span class="line">        <span class="attribute">j</span> = len(num<span class="number">2</span>)-<span class="number">1</span></span><br><span class="line">        <span class="attribute">carry</span> = <span class="number">0</span></span><br><span class="line">        <span class="attribute">result</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attribute">while</span> i &gt;= <span class="number">0</span> or j &gt;= <span class="number">0</span> or carry:</span><br><span class="line">            <span class="attribute">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="attribute">first</span> = num<span class="number">1</span>[i]</span><br><span class="line">            <span class="attribute">else</span>:</span><br><span class="line">                <span class="attribute">first</span> = <span class="number">0</span></span><br><span class="line">            <span class="attribute">if</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="attribute">second</span> = num<span class="number">2</span>[j]</span><br><span class="line">            <span class="attribute">else</span>:</span><br><span class="line">                <span class="attribute">second</span> = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print(&#x27;i, j&#x27;, i, j)</span></span><br><span class="line">            <span class="comment"># print(&#x27;first, second, carry&#x27;, first, second, carry)</span></span><br><span class="line">            <span class="attribute">tmp</span> = int(first) + int(second) + carry</span><br><span class="line">            <span class="attribute">result</span> = str(tmp%<span class="number">10</span>) + result</span><br><span class="line">            <span class="attribute">carry</span> = tmp // <span class="number">10</span></span><br><span class="line">            <span class="attribute">i</span> = i - <span class="number">1</span></span><br><span class="line">            <span class="attribute">j</span> = j - <span class="number">1</span></span><br><span class="line">        <span class="attribute">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>链表的倒数第K个节点(系列)</title>
    <url>/2022/02/27/leetcode/leetcode-remove-nth-node-from-end-of-list/</url>
    <content><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p> </p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<hr>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>让fast和slow均指向dummy，然后先让fast走k步，然后二者一起走，k为NULL时，slow到达目的地。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = dummy, *slow = dummy;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            k--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head = [1], n = 1<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1,2], n = 1<br>输出：[1]
 </p>
<p>提示：</p>
<p>链表中结点的数目为 sz<br>1 &lt;= sz &lt;= 30<br>0 &lt;= Node.val &lt;= 100<br>1 &lt;= n &lt;= sz</p>
<hr>
<h2 id="双指针思路"><a href="#双指针思路" class="headerlink" title="双指针思路"></a>双指针思路</h2><p>先让一个节点early早点出发，先走N步，然后再让另一个节点normal一起走。<br>当early节点走到链表结尾的时候，另一个节点normal就是需要被删除的节点。<br>注意记录normal节点的上一个节点</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> singly-linked <span class="keyword">list</span>.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=<span class="number">0</span>, <span class="keyword">next</span>=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: ListNode, n: <span class="keyword">int</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="keyword">next</span> = head</span><br><span class="line"></span><br><span class="line">        early = dummy</span><br><span class="line">        <span class="keyword">while</span> early <span class="built_in">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            early = early.<span class="keyword">next</span></span><br><span class="line">            n = n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">normal</span> = dummy</span><br><span class="line">        <span class="keyword">prev</span> = dummy</span><br><span class="line">        <span class="keyword">while</span> early:</span><br><span class="line">            <span class="keyword">prev</span> = <span class="keyword">normal</span></span><br><span class="line">            <span class="keyword">normal</span> = <span class="keyword">normal</span>.<span class="keyword">next</span></span><br><span class="line">            early = early.<span class="keyword">next</span></span><br><span class="line">        # <span class="keyword">print</span>(early, <span class="keyword">normal</span>)</span><br><span class="line">        <span class="keyword">prev</span>.<span class="keyword">next</span> = <span class="keyword">normal</span>.<span class="keyword">next</span></span><br><span class="line">        del <span class="keyword">normal</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<h2 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h2><p>略</p>
<h2 id="计算长度"><a href="#计算长度" class="headerlink" title="计算长度"></a>计算长度</h2><p>略</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>判断括号是否有效</title>
    <url>/2022/02/27/leetcode/leetcode-valid-parentheses/</url>
    <content><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s = “()”<br>输出：true<br>示例 2：</p>
<p>输入：s = “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s = “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s = “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s = “{[]}”<br>输出：true
 </p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 104<br>s 仅由括号 ‘()[]{}’ 组成</p>
<hr>
<p>和表达式计算器类似，考虑使用栈来实现</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 若长度为偶数, 必然不是合法串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        pairs = &#123;</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 碰到右括号则一定要有对应的左括号</span></span><br><span class="line">            <span class="keyword">if</span> e <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> stack <span class="keyword">and</span> stack.pop() == pairs[e]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(e)</span><br><span class="line">        <span class="comment"># 最后如果有落单的左括号，则非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表是否有环已经环的入口</title>
    <url>/2022/02/27/leetcode/leetcode-linked-list-cycle/</url>
    <content><![CDATA[<h1 id="1-判断单链表是否有环"><a href="#1-判断单链表是否有环" class="headerlink" title="1.判断单链表是否有环"></a>1.判断单链表是否有环</h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<h3 id="使用hash表标记法"><a href="#使用hash表标记法" class="headerlink" title="使用hash表标记法"></a>使用hash表标记法</h3><p>遍历一次链表，用hash表记录已访问的链表，如果遍历中第二次出现已访问的元素，则证明存在环</p>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 构建虚拟节点</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="comment"># 慢指针一次走一步，快指针一次走两步</span></span><br><span class="line">        slow = dummy.<span class="built_in">next</span></span><br><span class="line">        fast = dummy.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="comment"># 若无环，则快指针必然会先到达链表尾部</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-寻找环的入口"><a href="#2-寻找环的入口" class="headerlink" title="2.寻找环的入口"></a>2.寻找环的入口</h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<hr>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        exists = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> exists:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            exists[head] = <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>设链表中环外部分的长度为 a。<br>slow指针进入环后，又走了 b 的距离与fast 相遇。<br>此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc</p>
<p>根据题意，任意时刻，fast 指针走过的距离都为slow 指针的 2 倍。因此，有:<br>a+(n+1)b+nc=2(a+b)       ⟹         a=c+(n−1)(b+c)</p>
<p>有了 a=c+(n-1)(b+c) 的等量关系，我们会发现：<br>从相遇点到入环点的距离加上 n-1圈的环长，恰好等于从链表头部到入环点的距离。</p>
<p>因此，当发现slow 与 fast 相遇时，我们再额外使用一个指针p。起始，它指向链表头部；随后，它和slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        slow = dummy.<span class="built_in">next</span></span><br><span class="line">        fast = dummy.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="comment"># 当slow和fast相遇时，p和slow继续前进后一定会在环入口处相遇</span></span><br><span class="line">        <span class="keyword">while</span> slow:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">while</span> p != slow:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/2022/02/26/leetcode/leetcode-longest-substring-without-duplicate-strings/</url>
    <content><![CDATA[<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:<br>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:<br>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:<br>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。
 </p>
<p>提示：<br>0 &lt;= s.length &lt;= 5 * 104<br>s 由英文字母、数字、符号和空格组成</p>
<hr>
<h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, <span class="variable">s:</span> str) -&gt; in<span class="variable">t:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">e</span> in <span class="variable">s:</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">e</span> in resul<span class="variable">t:</span></span><br><span class="line">                result.<span class="keyword">pop</span>(<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">count</span> = <span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">            result.<span class="keyword">append</span>(<span class="keyword">e</span>)</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="built_in">count</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<h1 id="双指针的思路"><a href="#双指针的思路" class="headerlink" title="双指针的思路"></a>双指针的思路</h1><p>使用队列，在查找效率方面比较低，改为双指针。<br>时间复杂度O(n), 空间复杂度O(k)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        allchar = <span class="built_in">dict</span>()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i =<span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">while</span> s[j] <span class="keyword">in</span> allchar:</span><br><span class="line">                allchar.pop(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            allchar[s[j]] = j</span><br><span class="line">            count = j - i + <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子数组和</title>
    <url>/2022/02/26/leetcode/leetcode-sum-of-longest-sub-array/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p> </p>
<p>示例 1：<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>示例 2：<br>输入：nums = [1]<br>输出：1</p>
<p>示例 3：<br>输入：nums = [5,4,-1,7,8]<br>输出：23
 </p>
<p>提示：<br>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104</p>
<hr>
<h1 id="动态规划的思想"><a href="#动态规划的思想" class="headerlink" title="动态规划的思想"></a>动态规划的思想</h1><p>假设nums 数组的长度是 n，下标从 0 到 n−1。<br>我们用 f(i) 代表以第 i个数结尾的「连续子数组的最大和」<br>则f(i) = max{f(i-1)+nums[i], nums[i]}<br>最后，求出这里面的最大值即可。<br>时间复杂度和空间复杂度均为O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line">        f = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            tmp = f[i-<span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt;= nums[i]:</span><br><span class="line">                f.append(tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f.append(nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="考虑到题目中只需要求出最大值即可，可以对空间复杂度做一些优化"><a href="#考虑到题目中只需要求出最大值即可，可以对空间复杂度做一些优化" class="headerlink" title="考虑到题目中只需要求出最大值即可，可以对空间复杂度做一些优化"></a>考虑到题目中只需要求出最大值即可，可以对空间复杂度做一些优化</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[<span class="type">int</span>]) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type">int</span>:</span><br><span class="line">        if <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> nums[<span class="number">0</span>]</span><br><span class="line">        f <span class="operator">=</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, len(nums)):</span><br><span class="line">            f <span class="operator">=</span> <span class="built_in">max</span>(f<span class="operator">+</span>nums[i], nums[i])</span><br><span class="line">            <span class="keyword">result</span> <span class="operator">=</span> <span class="built_in">max</span>(f, <span class="keyword">result</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">result</span></span><br></pre></td></tr></table></figure>

<h2 id="如果需要打印出这个子数组"><a href="#如果需要打印出这个子数组" class="headerlink" title="如果需要打印出这个子数组"></a>如果需要打印出这个子数组</h2><p>可以记录最大子数组的结尾序号，然后倒序查找和为最大值的数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line">        f = nums[<span class="number">0</span>]</span><br><span class="line">        maxIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            tmp = f + nums[i]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt;= nums[i]:</span><br><span class="line">                f = tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f = nums[i]</span><br><span class="line">            <span class="keyword">if</span> f &gt; result:</span><br><span class="line">                result = f</span><br><span class="line">                maxIndex = i</span><br><span class="line">        <span class="comment"># print(f,maxIndex)</span></span><br><span class="line">        resultList = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxIndex, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(resultList) == result:</span><br><span class="line">                <span class="built_in">print</span>(resultList)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                resultList.insert(<span class="number">0</span>, nums[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="分治法-线段树"><a href="#分治法-线段树" class="headerlink" title="分治法: 线段树"></a>分治法: 线段树</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2022/02/25/leetcode/leetcode-reverse-nodes-in-k-group/</url>
    <content><![CDATA[<p>可以借鉴以前的反转链表的代码，然后分别一组一组的反转。<br>属于细节题目，适合反复训练</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> singly-linked <span class="keyword">list</span>.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=<span class="number">0</span>, <span class="keyword">next</span>=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.<span class="keyword">next</span> = <span class="keyword">next</span></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head, tail):</span><br><span class="line">        <span class="keyword">if</span> not head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        # 注意这里需要保留与tail之后数据的连接</span><br><span class="line">        <span class="keyword">pre</span> = tail.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">p</span> = head</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">pre</span> != tai<span class="variable">l:</span></span><br><span class="line">            q = <span class="keyword">p</span>.<span class="keyword">next</span></span><br><span class="line">            <span class="keyword">p</span>.<span class="keyword">next</span> = <span class="keyword">pre</span></span><br><span class="line">            <span class="keyword">pre</span> = <span class="keyword">p</span></span><br><span class="line">            <span class="keyword">p</span> = q</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">pre</span>, head</span><br><span class="line"></span><br><span class="line">    def reverseKGroup(self, head: Optional[ListNode], <span class="keyword">k</span>: <span class="keyword">int</span>) -&gt; Optional[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="keyword">next</span> = head</span><br><span class="line">        <span class="keyword">left</span> = dummy</span><br><span class="line">        tail = dummy</span><br><span class="line">        # <span class="keyword">print</span>(<span class="string">&#x27;left,right,head&#x27;</span>,<span class="keyword">left</span>.val, <span class="keyword">right</span>.val,head.val)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">k</span>):</span><br><span class="line">                tail = tail.<span class="keyword">next</span></span><br><span class="line">                <span class="keyword">if</span> not tai<span class="variable">l:</span></span><br><span class="line">                    <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line">            # <span class="keyword">print</span>(<span class="string">&#x27;head,tail&#x27;</span>,head,tail)</span><br><span class="line">            # 开始翻转前先记录被翻转部分的左右两部分</span><br><span class="line">            <span class="keyword">right</span> = tail.<span class="keyword">next</span></span><br><span class="line">            new_head, new_tail = self.reverseList(head, tail)</span><br><span class="line">            # <span class="keyword">print</span>(<span class="string">&#x27;new_head,new_tail&#x27;</span>,new_head,new_tail)</span><br><span class="line">            # 翻转后的新链表连接到原链表中间</span><br><span class="line">            <span class="keyword">left</span>.<span class="keyword">next</span> = new_head</span><br><span class="line">            new_tail.<span class="keyword">next</span> = <span class="keyword">right</span></span><br><span class="line"></span><br><span class="line">            # 重新初始化待翻转链表的head、tail以及左半部分</span><br><span class="line">            head = new_tail.<span class="keyword">next</span></span><br><span class="line">            tail = new_tail</span><br><span class="line"></span><br><span class="line">            <span class="keyword">left</span> = new_tail</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶</title>
    <url>/2022/02/24/leetcode/leetcode-jump-steps/</url>
    <content><![CDATA[<p>青蛙爬上最后一级台阶的时候，可能是一次跳了一步，也可能是一次跳了两步<br>所以方案数f(n) = f(n-1) + f(n-2)</p>
<h1 id="递归的方法"><a href="#递归的方法" class="headerlink" title="递归的方法"></a>递归的方法</h1><p>超时无法通过OJ，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n-<span class="number">1</span>) + self.climbStairs(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h1 id="动态规划的方法"><a href="#动态规划的方法" class="headerlink" title="动态规划的方法"></a>动态规划的方法</h1><p>时间复杂度和空间复杂度都是O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        result[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            result[i] = result[i-<span class="number">1</span>] + result[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> result[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>考虑到其实每次只需要结果值的前两个值，所以我们可以用p,q,r轮动的方式去推进<br>可以降低空间复杂度到O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        q = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            p = q</span><br><span class="line">            q = r</span><br><span class="line">            r = p + q</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="还有矩阵快速幂的方法"><a href="#还有矩阵快速幂的方法" class="headerlink" title="还有矩阵快速幂的方法"></a>还有矩阵快速幂的方法</h1><p>如果一个问题可与转化为求解一个矩阵的 n次方的形式，那么可以用快速幂来加速计算</p>
<h1 id="还可以求通项公式"><a href="#还可以求通项公式" class="headerlink" title="还可以求通项公式"></a>还可以求通项公式</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2022/02/24/leetcode/leetcode-two-stack-for-queue/</url>
    <content><![CDATA[<hr>
<p>队头插入：每次直接压入左边的栈即可<br>队尾删除：若右栈不为空，则直接弹出一个值即可；若右栈为空，则将左栈先全部入右栈，再弹出一个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.left_stack = <span class="built_in">list</span>()</span><br><span class="line">        self.right_stack = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.left_stack.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.right_stack <span class="keyword">and</span> <span class="keyword">not</span> self.left_stack:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.right_stack:</span><br><span class="line">            <span class="keyword">while</span> self.left_stack:</span><br><span class="line">                self.right_stack.append(self.left_stack.pop())</span><br><span class="line">            <span class="keyword">return</span> self.right_stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.right_stack.pop()</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>两个有序链表合并</title>
    <url>/2022/02/24/leetcode/leetcode-linklist-merge/</url>
    <content><![CDATA[<h1 id="迭代方法直接处理"><a href="#迭代方法直接处理" class="headerlink" title="迭代方法直接处理"></a>迭代方法直接处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                r = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># print(r.val, cur.val)</span></span><br><span class="line">            cur.<span class="built_in">next</span> = r</span><br><span class="line">            cur = r</span><br><span class="line">        <span class="keyword">while</span> list1:</span><br><span class="line">            cur.<span class="built_in">next</span> = list1</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> list2:</span><br><span class="line">            cur.<span class="built_in">next</span> = list2</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist-merge</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2022/02/23/leetcode/leetcode-two-sum/</url>
    <content><![CDATA[<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span> 


<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            tmp = target - v</span><br><span class="line">            <span class="keyword">if</span> tmp <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[tmp],k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashtable[v] = k</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>第K大的数</title>
    <url>/2022/02/22/leetcode/leetcode-Kth/</url>
    <content><![CDATA[<h1 id="快排划分的思想。"><a href="#快排划分的思想。" class="headerlink" title="快排划分的思想。"></a>快排划分的思想。</h1><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def partition(self, nums, left, right):</span><br><span class="line">        pivot = left</span><br><span class="line">        <span class="keyword">index</span> = <span class="keyword">left</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">index</span>, <span class="keyword">right</span>+<span class="number">1</span>):</span><br><span class="line">            # print(<span class="string">&#x27;left,right,i&#x27;</span>, <span class="keyword">left</span>, <span class="keyword">right</span>, i)</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[pivot]:</span><br><span class="line">                <span class="keyword">self</span>.swap(nums, i, <span class="keyword">index</span>)</span><br><span class="line">                <span class="keyword">index</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.swap(nums, pivot, <span class="keyword">index</span><span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">index</span><span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">    def swap(<span class="keyword">self</span>, nums, i, j):</span><br><span class="line">        nums[i],nums[j] = nums[j], nums[i]</span><br><span class="line">    </span><br><span class="line">    def partitionK(<span class="keyword">self</span>, nums, <span class="keyword">left</span>, <span class="keyword">right</span>, k):</span><br><span class="line">        <span class="keyword">index</span> = <span class="keyword">self</span>.<span class="keyword">partition</span>(nums, <span class="keyword">left</span>, <span class="keyword">right</span>)</span><br><span class="line">        <span class="built_in">length</span> = <span class="keyword">index</span>-<span class="keyword">left</span>+<span class="number">1</span></span><br><span class="line">        # 如果已划分的个数<span class="built_in">length</span>大于需要找的数k, 则在<span class="keyword">index</span>左半部分重新找k个数</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span> &gt; k:</span><br><span class="line">            <span class="keyword">self</span>.partitionK(nums, <span class="keyword">left</span>, <span class="keyword">index</span><span class="number">-1</span>, k)</span><br><span class="line">        # 如果已划分的个数<span class="built_in">length</span>小于需要找的数k, 则在<span class="keyword">index</span>右半部分再找k-<span class="built_in">length</span>个数即可</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span> &lt; k:</span><br><span class="line">            <span class="keyword">self</span>.partitionK(nums, <span class="keyword">index</span>+<span class="number">1</span>, <span class="keyword">right</span>, k-<span class="built_in">length</span>)</span><br><span class="line"></span><br><span class="line">    def findKthLargest(<span class="keyword">self</span>, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        <span class="keyword">self</span>.partitionK(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>, k)</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>上面的partitionK可以改为迭代的写法</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">def partitionK(self, nums, left, right, k):</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            <span class="keyword">index</span> = <span class="keyword">self</span>.<span class="keyword">partition</span>(nums, <span class="keyword">left</span>, <span class="keyword">right</span>)</span><br><span class="line">            <span class="built_in">length</span> = <span class="keyword">index</span>-<span class="keyword">left</span>+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="built_in">length</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="built_in">length</span>:</span><br><span class="line">                <span class="keyword">right</span> = <span class="keyword">index</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">length</span>:</span><br><span class="line">                <span class="keyword">left</span> = <span class="keyword">index</span> + <span class="number">1</span></span><br><span class="line">                k = k - <span class="built_in">length</span></span><br></pre></td></tr></table></figure>
<span id="more"></span> 

<h1 id="堆排序的思想"><a href="#堆排序的思想" class="headerlink" title="堆排序的思想"></a>堆排序的思想</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 构建小顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust</span>(<span class="params">self, nums, i, length</span>):</span></span><br><span class="line">        k = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        tmp = nums[i]</span><br><span class="line">        <span class="keyword">while</span> k &lt; length:</span><br><span class="line">            <span class="keyword">if</span> k + <span class="number">1</span> &lt; length <span class="keyword">and</span> nums[k+<span class="number">1</span>] &lt; nums[k]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; length <span class="keyword">and</span> nums[k] &lt; tmp:</span><br><span class="line">                nums[i] = nums[k]</span><br><span class="line">                i = k</span><br><span class="line">            k = <span class="number">2</span>*k + <span class="number">1</span></span><br><span class="line">        nums[i] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.adjust(nums, i, <span class="built_in">len</span>(nums)) </span><br><span class="line">        <span class="keyword">return</span> nums </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">self, nums, i, j</span>):</span></span><br><span class="line">        nums[i],nums[j] = nums[j], nums[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构建小顶堆，堆中存储最大的前k个数，堆顶就是第K大的数</span></span><br><span class="line">    <span class="comment"># 然后循环遍历剩下的数，如果比堆顶元素大，则将之与堆顶元素交换并调整</span></span><br><span class="line">    <span class="comment"># 返回堆顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums[:k] = self.buildHeap(nums[:k])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[<span class="number">0</span>]:</span><br><span class="line">                self.swap(nums, i, <span class="number">0</span>)</span><br><span class="line">                self.adjust(nums, <span class="number">0</span>, k)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>当然，也可以完全参考堆排序的过程，不过只输出前k个数</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>前K大的数</title>
    <url>/2022/02/22/leetcode/leetcode-topK/</url>
    <content><![CDATA[<h1 id="1-快排划分思路的解法"><a href="#1-快排划分思路的解法" class="headerlink" title="1.快排划分思路的解法"></a>1.快排划分思路的解法</h1><p>特别注意k=0的情况</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        if not arr or k == 0:</span><br><span class="line">            return []</span><br><span class="line">        self.partitionK(arr, 0, len(arr)-1, k)</span><br><span class="line">        return arr[:k]</span><br><span class="line"></span><br><span class="line">    def partitionK(self, nums, l, r, k):</span><br><span class="line">        <span class="keyword">index</span> = <span class="keyword">self</span>.<span class="keyword">partition</span>(nums, l, r)</span><br><span class="line">        <span class="built_in">length</span> = <span class="keyword">index</span> - l + <span class="number">1</span></span><br><span class="line">        # print(<span class="string">&quot;index,nums,l,r,k, length&quot;</span>,<span class="keyword">index</span>,nums,l,r,k, <span class="built_in">length</span>)</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">length</span>:</span><br><span class="line">            <span class="keyword">self</span>.partitionK(nums, <span class="keyword">index</span>+<span class="number">1</span>, r, k-<span class="built_in">length</span>)</span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="built_in">length</span>:</span><br><span class="line">            <span class="keyword">self</span>.partitionK(nums, l, <span class="keyword">index</span><span class="number">-1</span>, k)</span><br><span class="line"></span><br><span class="line">    def <span class="keyword">partition</span>(<span class="keyword">self</span>, nums, l, r):</span><br><span class="line">        <span class="keyword">self</span>.swap(nums, l, l+(r-l)//<span class="number">2</span>)</span><br><span class="line">        # print(<span class="string">&quot;partition,nums&quot;</span>, nums)</span><br><span class="line">        pivot = l</span><br><span class="line">        <span class="keyword">index</span> = l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">index</span>, r+<span class="number">1</span>):</span><br><span class="line">            # print(<span class="string">&#x27;i,index,nums&#x27;</span>, i,<span class="keyword">index</span>,nums)</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[pivot]:</span><br><span class="line">                <span class="keyword">self</span>.swap(nums, <span class="keyword">index</span>, i)</span><br><span class="line">                <span class="keyword">index</span> += <span class="number">1</span></span><br><span class="line">        # print(<span class="string">&quot;partition2,nums&quot;</span>, nums)</span><br><span class="line">        <span class="keyword">self</span>.swap(nums, pivot, <span class="keyword">index</span><span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">index</span><span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    def swap(<span class="keyword">self</span>, nums, i, j):</span><br><span class="line">        nums[i],nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>
<span id="more"></span> 


<h1 id="2-堆排序的思路"><a href="#2-堆排序的思路" class="headerlink" title="2. 堆排序的思路"></a>2. 堆排序的思路</h1><p>建立一个大顶堆，然后将剩下的数按次序和堆顶元素比较，如果比堆顶元素小，则交换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="comment"># 异常case需要考虑</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        arr[:k] = self.build(arr[:k])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="comment"># print(&quot;arr[i]&quot;,i, arr[i])</span></span><br><span class="line">            <span class="keyword">if</span> arr[<span class="number">0</span>] &gt; arr[i]:</span><br><span class="line">                arr[<span class="number">0</span>] = arr[i]</span><br><span class="line">                self.adjust(arr, <span class="number">0</span>, k)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">self, nums, i, j</span>):</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust</span>(<span class="params">self, nums, i, length</span>):</span></span><br><span class="line">        tmp = nums[i]</span><br><span class="line">        k = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; length:</span><br><span class="line">            <span class="keyword">if</span> k+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[k+<span class="number">1</span>] &gt; nums[k]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; length <span class="keyword">and</span> nums[k] &gt; tmp:</span><br><span class="line">                nums[i] = nums[k]</span><br><span class="line">                i = k</span><br><span class="line">            k = <span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line">        nums[i] = tmp        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.adjust(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h1><h1 id="4-计数排序"><a href="#4-计数排序" class="headerlink" title="4. 计数排序"></a>4. 计数排序</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>topK</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历(系列)</title>
    <url>/2022/02/22/leetcode/leetcode-binary-tree-levelOrder-traversal/</url>
    <content><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p>
<p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root = []<br>输出：[]
 </p>
<h2 id="递归的解法"><a href="#递归的解法" class="headerlink" title="递归的解法"></a>递归的解法</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        <span class="built_in">result</span> = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="literal">return</span> <span class="built_in">result</span></span><br><span class="line">        self.helper(root, <span class="number">0</span>, <span class="built_in">result</span>)</span><br><span class="line">        <span class="literal">return</span> <span class="built_in">result</span></span><br><span class="line"></span><br><span class="line">    def helper(self, root, level, <span class="built_in">result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">result</span>) == level:</span><br><span class="line">            <span class="built_in">result</span>.append([])</span><br><span class="line">        <span class="built_in">result</span>[level].append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.helper(root.left, level+<span class="number">1</span>, <span class="built_in">result</span>)</span><br><span class="line">        <span class="keyword">if</span> root.<span class="literal">right</span>:</span><br><span class="line">            self.helper(root.<span class="literal">right</span>, level+<span class="number">1</span>, <span class="built_in">result</span>)</span><br><span class="line">        </span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<h2 id="使用dummy标记进行迭代"><a href="#使用dummy标记进行迭代" class="headerlink" title="使用dummy标记进行迭代"></a>使用dummy标记进行迭代</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> <span class="keyword">a</span> binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=<span class="number">0</span>, <span class="keyword">left</span>=None, <span class="keyword">right</span>=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.<span class="keyword">left</span> = <span class="keyword">left</span></span><br><span class="line">#         self.<span class="keyword">right</span> = <span class="keyword">right</span></span><br><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, roo<span class="variable">t:</span> TreeNode) -&gt; List[List[<span class="keyword">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        dummy = TreeNode()</span><br><span class="line">        <span class="keyword">p</span> = root</span><br><span class="line">        queue = [root, dummy]</span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            # <span class="keyword">print</span>(<span class="string">&quot;queue,p&quot;</span>, [<span class="keyword">e</span>.val <span class="keyword">for</span> <span class="keyword">e</span> in queue],<span class="keyword">p</span>.val)</span><br><span class="line">            <span class="keyword">p</span> = queue.<span class="keyword">pop</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">p</span> != dummy:</span><br><span class="line">                level.<span class="keyword">append</span>(<span class="keyword">p</span>.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.lef<span class="variable">t:</span></span><br><span class="line">                    queue.<span class="keyword">append</span>(<span class="keyword">p</span>.<span class="keyword">left</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.righ<span class="variable">t:</span></span><br><span class="line">                    queue.<span class="keyword">append</span>(<span class="keyword">p</span>.<span class="keyword">right</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.<span class="keyword">append</span>(<span class="keyword">list</span>(level))</span><br><span class="line">                level = []</span><br><span class="line">                # 若队列中已无数据，则不再添加标记节点</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    queue.<span class="keyword">append</span>(dummy)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">          </span><br></pre></td></tr></table></figure>

<h2 id="迭代：每次直接遍历一层的数据"><a href="#迭代：每次直接遍历一层的数据" class="headerlink" title="迭代：每次直接遍历一层的数据"></a>迭代：每次直接遍历一层的数据</h2><p>我们可以用一种巧妙的方法修改广度优先搜索：<br>首先根元素入队<br>当队列不为空的时候:<br>      求当前队列的长度Si<br>      依次从队列中取 Si个元素进行拓展，然后进入下一次迭代</p>
<p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 Si个元素。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> <span class="keyword">a</span> binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=<span class="number">0</span>, <span class="keyword">left</span>=None, <span class="keyword">right</span>=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.<span class="keyword">left</span> = <span class="keyword">left</span></span><br><span class="line">#         self.<span class="keyword">right</span> = <span class="keyword">right</span></span><br><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, roo<span class="variable">t:</span> TreeNode) -&gt; List[List[<span class="keyword">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">p</span> = root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            levelQueue = []</span><br><span class="line">            level = <span class="built_in">len</span>(queue)</span><br><span class="line">            # <span class="keyword">print</span>(<span class="string">&quot;queue, level&quot;</span>, [<span class="keyword">e</span>.val <span class="keyword">for</span> <span class="keyword">e</span> in queue], level)</span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(level):</span><br><span class="line">                <span class="keyword">p</span> = queue.<span class="keyword">pop</span>(<span class="number">0</span>)</span><br><span class="line">                levelQueue.<span class="keyword">append</span>(<span class="keyword">p</span>.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.lef<span class="variable">t:</span></span><br><span class="line">                    queue.<span class="keyword">append</span>(<span class="keyword">p</span>.<span class="keyword">left</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">p</span>.righ<span class="variable">t:</span></span><br><span class="line">                    queue.<span class="keyword">append</span>(<span class="keyword">p</span>.<span class="keyword">right</span>)</span><br><span class="line">            result.<span class="keyword">append</span>(<span class="keyword">list</span>(levelQueue))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">           </span><br></pre></td></tr></table></figure>

<p>C++版本，2022年5月2日重刷</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a>103. 二叉树的锯齿形层序遍历</h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p>
<p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root = []<br>输出：[]</p>
<hr>
<h2 id="双端队列-广度优先遍历"><a href="#双端队列-广度优先遍历" class="headerlink" title="双端队列-广度优先遍历"></a>双端队列-广度优先遍历</h2><p>如果队列中的数据，从队头到队尾都是顺序存放的，那么：</p>
<ul>
<li>从队头依次访问队列，就是顺序访问</li>
<li>从队尾依次访问队列，就是逆序访问</li>
</ul>
<p>时间空间复杂度均为O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// 双端队列</span></span><br><span class="line">        deque&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace_back</span>(root);</span><br><span class="line">        <span class="keyword">bool</span> direction = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(direction)&#123;</span><br><span class="line">                    <span class="comment">// 从队头依次读取数据，并从左到右加入子节点到队列尾部，【这样子节点从队头到队尾是顺序的】</span></span><br><span class="line">                    <span class="comment">// 从队头顺序读取，相当于顺序读取</span></span><br><span class="line">                    TreeNode* node = q.<span class="built_in">front</span>(); </span><br><span class="line">                    q.<span class="built_in">pop_front</span>();</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">emplace_back</span>(node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">emplace_back</span>(node-&gt;right);</span><br><span class="line">                    tmp.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 从队尾依次读取数据，并从右到左加入子节点到队列头部，【这样子节点从队头到队尾是顺序的】</span></span><br><span class="line">                    <span class="comment">// 从队尾顺序读取，相当于反序读取</span></span><br><span class="line">                    TreeNode* node = q.<span class="built_in">back</span>(); </span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">emplace_front</span>(node-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">emplace_front</span>(node-&gt;left);</span><br><span class="line">                    tmp.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过direction标记控制读取的顺序</span></span><br><span class="line">            direction = <span class="keyword">not</span> direction;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a>107. 二叉树的层序遍历 II</h1><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[15,7],[9,20],[3]]<br>示例 2：</p>
<p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root = []<br>输出：[]
 </p>
<hr>
<p>看题解基本都是将102题的答案翻转得到，没有想到更好的办法，暂时重写一遍，就当练习了。</p>
<h2 id="广度优先-队列"><a href="#广度优先-队列" class="headerlink" title="广度优先-队列"></a>广度优先-队列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先-递归"><a href="#深度优先-递归" class="headerlink" title="深度优先-递归"></a>深度优先-递归</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 注意初始时ans的大小为0</span></span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; level) ans.<span class="built_in">emplace_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        ans[level<span class="number">-1</span>].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">levelOrder</span>(root-&gt;left, level+<span class="number">1</span>, ans);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">levelOrder</span>(root-&gt;right, level+<span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">levelOrder</span>(root, <span class="number">1</span>, ans);</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a>637. 二叉树的层平均值</h1><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。<br>因此返回 [3, 14.5, 11] 。<br>示例 2:</p>
<p>输入：root = [3,9,20,15,7]<br>输出：[3.00000,14.50000,11.00000]</p>
<hr>
<p>还是沿用广度优先和深度优先的思路分别求解</p>
<h2 id="广度优先遍历-队列"><a href="#广度优先遍历-队列" class="headerlink" title="广度优先遍历-队列"></a>广度优先遍历-队列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 如果先求和然后算平均值，sum可能会溢出，需要为long int</span></span><br><span class="line">            <span class="comment">// 或者也可以记录当前所有数的平均数和个数,每次更新平均数</span></span><br><span class="line">            <span class="keyword">double</span> avg = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                avg = (avg*count+node-&gt;val)/(++count);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(avg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, vector&lt;<span class="keyword">double</span>&gt; &amp;avg, vector&lt;<span class="keyword">int</span>&gt; &amp;count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (avg.<span class="built_in">size</span>() &lt; level) &#123;</span><br><span class="line">            avg.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">            count.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        avg[level<span class="number">-1</span>] = (avg[level<span class="number">-1</span>]*count[level<span class="number">-1</span>]+root-&gt;val)/(count[level<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        count[level<span class="number">-1</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left, level+<span class="number">1</span>, avg, count);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right, level+<span class="number">1</span>, avg, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">1</span>, ans, count);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：2<br>示例 2：</p>
<p>输入：root = [2,null,3,null,4,null,5,null,6]<br>输出：5</p>
<hr>
<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, level);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left, level+<span class="number">1</span>, ans);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right, level+<span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">1</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 由于是从上到下分层遍历，所以当某层出现叶子结点时，即为最小深度，即刻返回。</span></span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a>429. N 叉树的层序遍历</h1><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]<br>示例 2：</p>
<p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
 </p>
<hr>
<h2 id="广度优先遍历-队列-1"><a href="#广度优先遍历-队列-1" class="headerlink" title="广度优先遍历-队列"></a>广度优先遍历-队列</h2><p>多叉树的子节点是一个vector对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> child : node-&gt;children) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先遍历-1"><a href="#深度优先遍历-1" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root, <span class="keyword">int</span> level, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; level) ans.<span class="built_in">emplace_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        ans[level<span class="number">-1</span>].<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(child, level+<span class="number">1</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">1</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a>993. 二叉树的堂兄弟节点</h1><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>
<p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>
<p>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。</p>
<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false<br>示例 2：</p>
<p>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4<br>输出：true<br>示例 3：</p>
<p>输入：root = [1,2,3,null,4], x = 2, y = 3<br>输出：false</p>
<hr>
<p>还是二叉树的层序遍历：</p>
<ol>
<li>层序遍历二叉树，记录x和y的层数以及父节点，当树遍历完或者x，y均遍历到时，结束遍历</li>
<li>判断x和y是否是堂兄弟节点</li>
</ol>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录x和y的层数以及父节点</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>, xLevel = <span class="number">0</span> , yLevel = <span class="number">0</span>;</span><br><span class="line">        TreeNode* xFather, *yFather;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q, fatherQueue;</span><br><span class="line">        q.<span class="built_in">emplace</span>(root);</span><br><span class="line">        fatherQueue.<span class="built_in">emplace</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                TreeNode* father = fatherQueue.<span class="built_in">front</span>(); fatherQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val == x) &#123;</span><br><span class="line">                    xLevel = level;</span><br><span class="line">                    xFather = father;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val == y) &#123;</span><br><span class="line">                    yLevel = level;</span><br><span class="line">                    yFather = father;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                    fatherQueue.<span class="built_in">emplace</span>(node);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">                    fatherQueue.<span class="built_in">emplace</span>(node);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (xLevel != <span class="number">0</span> &amp;&amp; yLevel != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xLevel != <span class="number">0</span> &amp;&amp; yLevel != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xLevel == <span class="number">0</span> || yLevel == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> xLevel == yLevel &amp;&amp; xFather != yFather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先遍历-2"><a href="#深度优先遍历-2" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录x和y的层数以及父节点</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>, xLevel = <span class="number">0</span> , yLevel = <span class="number">0</span>;</span><br><span class="line">    TreeNode* xFather, *yFather;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* pre, <span class="keyword">int</span> level, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == x) &#123;</span><br><span class="line">            xLevel = level;</span><br><span class="line">            xFather = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == y) &#123;</span><br><span class="line">            yLevel = level;</span><br><span class="line">            yFather = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (xLevel != <span class="number">0</span> &amp;&amp; yLevel != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left, root, level+<span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right, root, level+<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="literal">nullptr</span>, <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">if</span> (xLevel == <span class="number">0</span> || yLevel == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xLevel == yLevel &amp;&amp; xFather != yFather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="314-二叉树的垂直遍历"><a href="#314-二叉树的垂直遍历" class="headerlink" title="314. 二叉树的垂直遍历"></a>314. 二叉树的垂直遍历</h1><p>给定一个二叉树，返回其结点 垂直方向（从上到下，逐列）遍历的值。</p>
<p>如果两个结点在同一行和列，那么顺序则为 从左到右。</p>
<p>输入: [3,9,20,null,null,15,7]</p>
<p>3<br>/<br>/<br>9 20<br>/<br>/<br>15 7</p>
<p>输出:</p>
<p>[<br>[9],<br>[3,15],<br>[20],<br>[7]<br>]</p>
<hr>
<p>思路：以根节点为(0,0)坐标，然后层序遍历。其中需要用一个队列记录每个节点的列。</p>
<p>每一个子节点的列号：</p>
<ul>
<li>若子节点为左孩子，则列号减1</li>
<li>若子节点为右孩子，则列号加1</li>
</ul>
<p>具体实现同样可以用BFS或DFS均可。</p>
<p>此题现在需要会员，暂时不给答案。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前中后三种遍历(递归、非递归和Morris)</title>
    <url>/2022/02/19/leetcode/leetcode-binary-tree-traversal/</url>
    <content><![CDATA[<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><p>递归的一个思想就是：假设子问题已经解决。<br>对于遍历来说，就是左子树的结果已经知道了，右子树的结果也已经知道了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        result += self.preorderTraversal(root.left)</span><br><span class="line">        result += self.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>根-左-右，使用栈的思路。<br>核心要点，访问完根节点后，考虑栈先进后出的特点，需要先将右子树压栈，再将左子树压栈。</p>
<span id="more"></span> 

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> <span class="keyword">a</span> binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=<span class="number">0</span>, <span class="keyword">left</span>=None, <span class="keyword">right</span>=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.<span class="keyword">left</span> = <span class="keyword">left</span></span><br><span class="line">#         self.<span class="keyword">right</span> = <span class="keyword">right</span></span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, roo<span class="variable">t:</span> Optional[TreeNode]) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.<span class="keyword">pop</span>()</span><br><span class="line">            result.<span class="keyword">append</span>(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.righ<span class="variable">t:</span></span><br><span class="line">                stack.<span class="keyword">append</span>(cur.<span class="keyword">right</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.lef<span class="variable">t:</span></span><br><span class="line">                stack.<span class="keyword">append</span>(cur.<span class="keyword">left</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result += self.inorderTraversal(root.left)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        result += self.inorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="非递归版本-1"><a href="#非递归版本-1" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>中序顺序是左-根-右<br>1.先将根节点入栈，然后将左节点持续入栈，直至叶子节点。<br>2.出栈访问，然后同样的方式该节点的右节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> p:</span><br><span class="line">            <span class="comment"># 将先根入栈，然后左节点入栈</span></span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="comment"># 左节点为空，根节点此时可以出栈，然后再看该节点的右节点</span></span><br><span class="line">            p = stack.pop()</span><br><span class="line">            result.append(p.val)</span><br><span class="line">            p = p.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure>


<p>###Morris 遍历待补充</p>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归版本-2"><a href="#递归版本-2" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result += self.postorderTraversal(root.left)</span><br><span class="line">        result += self.postorderTraversal(root.right)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="非递归版本-2"><a href="#非递归版本-2" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>搞懂了以后也比较简单，和中序遍历比较类似，<br>不同的是后序遍历在右子树存在时需要先临时将根入栈，待右子树都处理完以后才能将根节点入栈。</p>
<p>这里面有个冲突就是：当判断某个根节点是否该被访问还是先将右子树进行访问的时候无法区分右子树是否已被访问过，所以需要一个prev标记一下。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> <span class="keyword">a</span> binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=<span class="number">0</span>, <span class="keyword">left</span>=None, <span class="keyword">right</span>=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.<span class="keyword">left</span> = <span class="keyword">left</span></span><br><span class="line">#         self.<span class="keyword">right</span> = <span class="keyword">right</span></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, roo<span class="variable">t:</span> Optional[TreeNode]) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">p</span> = root</span><br><span class="line">        <span class="keyword">prev</span> = None</span><br><span class="line">        <span class="keyword">while</span> stack <span class="built_in">or</span> <span class="keyword">p</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">p</span>:</span><br><span class="line">                stack.<span class="keyword">append</span>(<span class="keyword">p</span>)</span><br><span class="line">                <span class="keyword">p</span> = <span class="keyword">p</span>.<span class="keyword">left</span></span><br><span class="line">            <span class="keyword">p</span> = stack.<span class="keyword">pop</span>()</span><br><span class="line">            # 如果上一次访问过<span class="keyword">p</span>的右子树或者右子树不存在</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">prev</span> == <span class="keyword">p</span>.<span class="keyword">right</span> <span class="built_in">or</span> not <span class="keyword">p</span>.righ<span class="variable">t:</span></span><br><span class="line">                result.<span class="keyword">append</span>(<span class="keyword">p</span>.val)</span><br><span class="line">                <span class="keyword">prev</span> = <span class="keyword">p</span></span><br><span class="line">                <span class="keyword">p</span> = None</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.<span class="keyword">append</span>(<span class="keyword">p</span>)</span><br><span class="line">                <span class="keyword">p</span> = <span class="keyword">p</span>.<span class="keyword">right</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU缓存结构</title>
    <url>/2022/02/18/leetcode/leetcode-lru/</url>
    <content><![CDATA[<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p> </p>
<p>示例：</p>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
<p>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4
 </p>
<p>提示：</p>
<p>1 &lt;= capacity &lt;= 3000<br>0 &lt;= key &lt;= 10000<br>0 &lt;= value &lt;= 105<br>最多调用 2 * 105 次 get 和 put</p>
<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>核心思路是 哈希表+双向链表。</p>
<p>哈希表存储key和双向链表中的位置。<br>双向链表队头的元素是最近访问过的元素，队尾是最近未访问过的元素</p>
<p>注意：所有put操作和get读取到的情况，都要将数据插入到队头<br>设置head和tail的dummy节点，可以简化操作。<br>由于空间满的时候需要删除队尾数据，所以使用单链表的时间复杂度会达到O(k), 而双向链表可以做到读写都是O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        <span class="comment">#双向链表初始化时，head.prev和tail.next均为None</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 将节点插入头节点head之后，思路和单链表类似，先将node连上head之后的节点，再将head指向node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#删除动作，两次指针变换，node节点的后一个节点的前驱，node节点的前一个节点的后继</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除队尾节点就是删除tail节点前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.remove(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># print(&quot;get1 &quot;, self.head.next.next.key, self.head.next.next.value)</span></span><br><span class="line">        <span class="comment"># print(&quot;get2 &quot;, self.head.next.next.key, self.head.next.next.value)</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache.keys():</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            self.remove(node)</span><br><span class="line">            self.insertHead(node)</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.remove(node)</span><br><span class="line">            self.insertHead(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            self.insertHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size = self.size - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>lru</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法梳理</title>
    <url>/2022/02/09/leetcode/leetcode-sort/</url>
    <content><![CDATA[<h1 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>核心动作：比较和交换</p>
<ol>
<li>n-1次循环(因为最后一个数不用冒泡了)，每次循环将一个值”冒泡”至最终位置，i为循环轮次</li>
<li>每次循环两两比较相邻数，若不符合要求就交换，j表示比较的数</li>
<li>若上一次循环没有交换数据，则表示已完成排序，可以终止循环了，flag标记</li>
</ol>
<p>复杂度：时间复杂度O(n^2), 空间复杂度O(1)</p>
<p>稳定性：比较的时候可以设定相等的元素不交换，所以是稳定的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NC140 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>-i):</span><br><span class="line">                <span class="comment"># 升序或降序只需要修改下面的比较符号即可</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    tmp = nums[j]</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>]</span><br><span class="line">                    nums[j+<span class="number">1</span>] = tmp</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次选择最小的一个数据放置在指定位置<br>核心动作：比较和交换</p>
<ol>
<li>循环n-1次，每次循环选择一个最小的数，与未处理部分的第一个元素交换</li>
</ol>
<p>复杂度：时间复杂度O(n^2), 空间复杂度O(1)</p>
<p>稳定性：交换动作可能会导致未处理部分的第一个元素与其重复值相对顺序改变，所以是不稳定的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):</span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                <span class="comment"># 升序或降序只需要修改下面的比较符号即可</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[min_index]:</span><br><span class="line">                    min_index = j</span><br><span class="line">            <span class="comment"># 未排序部分中的最小值 与 未排序部分的第一个元素 交换</span></span><br><span class="line">            <span class="comment"># 此部分导致选择排序的不稳定性，因为如果「未排序部分的第一个元素」存在重复元素，交换时会导致这个值相对顺序的改变</span></span><br><span class="line">            <span class="comment"># 如果需要改变稳定性，可以改为：将未排序部分中的最小值 插入 到未排序部分第一个元素 之前</span></span><br><span class="line">            <span class="comment"># 如果是链表实现的，则比较容易实现上述插入动作</span></span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            nums[i] = nums[min_index]</span><br><span class="line">            nums[min_index] = tmp</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>将数组分为已排序和未排序两部分，然后将未排序部分的数依次插入到已排序数组中的合适位置<br>核心动作：比较和移动<br>1.将第1个数视为已排序部分，剩下部分视为未排序部分<br>2.未排序部分：i表示需要依次遍历的数，从第二个数到最后一个数<br>3.已排序部分：i左边的所有数<br>4.将本次需要插入的数和已排序部分依次比较，如果需要插入的数比已排序部分这个数大，就将这个数后移一位，直到第0个数<br>5.将待插入数据插入到查到到的位置</p>
<p>复杂度：时间复杂度O(n^2), 空间复杂度O(1)</p>
<p>稳定性：插入的过程不改变相对位置，是稳定排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            <span class="comment"># 同样的，升序或降序只需要修改下面的比较符号即可</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; tmp:</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            nums[j+<span class="number">1</span>] = tmp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>寻找需要插入位置的时候，其实是一个二分查找过程，可以使用二分查找减少比较次数，但是移动次数不会改变</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sortArray(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        <span class="built_in">length</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="built_in">length</span>):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            low = <span class="number">0</span></span><br><span class="line">            high = j</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            <span class="comment"># 注意这里是&lt;=, 可以保证最终值在low和high之间。</span></span><br><span class="line">            <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">                <span class="keyword">mid</span> = low + (high - low<span class="comment">)//2</span></span><br><span class="line">                <span class="comment"># 如果数值相同，右边的数认为更大，可以保持排序稳定</span></span><br><span class="line">                <span class="comment"># 同样的，升序或降序只需要修改下面的比较符号即可</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="keyword">mid</span>] &lt;= tmp:</span><br><span class="line">                    low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;=<span class="number">0</span> <span class="keyword">and</span> j &gt; high:</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            nums[high+<span class="number">1</span>] = tmp</span><br><span class="line">        <span class="literal">return</span> nums</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>核心在于partition动作, 实现方式有多种，这里的这种比较巧妙</p>
<p>复杂度：时间复杂度O(nlogn), 空间复杂度O(1)</p>
<p>稳定性：大间隔交换动作可能导致相对顺序改变，不稳定排序</p>
<h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def partition(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        # 选择pivot是一个比较关键的点，影响最好最快的复杂度</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="keyword">left</span>] &lt; nums[<span class="keyword">right</span>]:</span><br><span class="line">            self.swap(nums, <span class="keyword">left</span>, <span class="keyword">left</span>+(<span class="keyword">right</span>-<span class="keyword">left</span>)//<span class="number">2</span>)</span><br><span class="line">        pivot = <span class="keyword">left</span></span><br><span class="line">        <span class="built_in">index</span> = <span class="keyword">left</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">index</span>, <span class="keyword">right</span>+<span class="number">1</span>):</span><br><span class="line">            # 同样的，升序或降序只需要修改下面的比较符号即可</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[pivot]:</span><br><span class="line">                self.swap(nums, i, <span class="built_in">index</span>)</span><br><span class="line">                <span class="built_in">index</span> += <span class="number">1</span></span><br><span class="line">        self.swap(nums, <span class="built_in">index</span>-<span class="number">1</span>, pivot)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">index</span>-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def swap(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>] = nums[<span class="keyword">right</span>], nums[<span class="keyword">left</span>]</span><br><span class="line">    </span><br><span class="line">    def quickSort(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span> &lt; righ<span class="variable">t:</span></span><br><span class="line">            pivot_index = self.partition(nums, <span class="keyword">left</span>, <span class="keyword">right</span>)</span><br><span class="line">            self.quickSort(nums, <span class="keyword">left</span>, pivot_index-<span class="number">1</span>)</span><br><span class="line">            self.quickSort(nums, pivot_index+<span class="number">1</span>, <span class="keyword">right</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    def sortArray(self, num<span class="variable">s:</span> List[<span class="keyword">int</span>]) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>Partition函数还有一种写法，pivot，内存2个while顺序和最后1次交换者，很值得琢磨</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">partition</span>(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        if nums[<span class="keyword">left</span>] <span class="operator">&lt;</span> nums[<span class="keyword">right</span>]:</span><br><span class="line">            self.swap(nums, <span class="keyword">right</span>, <span class="keyword">left</span><span class="operator">+</span>(<span class="keyword">right</span><span class="operator">-</span><span class="keyword">left</span>)<span class="operator">/</span><span class="operator">/</span><span class="number">2</span>)</span><br><span class="line">        <span class="keyword">begin</span><span class="operator">=</span><span class="keyword">left</span></span><br><span class="line">        <span class="keyword">end</span><span class="operator">=</span><span class="keyword">right</span></span><br><span class="line">        pivot<span class="operator">=</span><span class="keyword">right</span></span><br><span class="line">        # 最终<span class="keyword">begin</span>和<span class="keyword">end</span>都指向一处。</span><br><span class="line">        # 若pivot指向右边，则需要先走左边的while，否则先走右边</span><br><span class="line">        while <span class="keyword">begin</span> <span class="operator">&lt;</span> <span class="keyword">end</span>:</span><br><span class="line">            while <span class="keyword">begin</span> <span class="operator">&lt;</span> <span class="keyword">end</span> <span class="keyword">and</span> nums[<span class="keyword">begin</span>] <span class="operator">&lt;=</span> nums[pivot]:</span><br><span class="line">                <span class="keyword">begin</span> <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span></span><br><span class="line">            while <span class="keyword">begin</span> <span class="operator">&lt;</span> <span class="keyword">end</span> <span class="keyword">and</span> nums[<span class="keyword">end</span>] <span class="operator">&gt;=</span> nums[pivot]:</span><br><span class="line">                <span class="keyword">end</span> <span class="operator">=</span> <span class="keyword">end</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">            self.swap(nums, <span class="keyword">begin</span>, <span class="keyword">end</span>)</span><br><span class="line">        self.swap(nums, <span class="keyword">begin</span>, pivot)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">begin</span></span><br></pre></td></tr></table></figure>

<h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>只修改了quickSort部分的代码</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def partition(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="keyword">left</span>] &lt; nums[<span class="keyword">right</span>]:</span><br><span class="line">            self.swap(nums, <span class="keyword">left</span>, <span class="keyword">left</span>+(<span class="keyword">right</span>-<span class="keyword">left</span>)//<span class="number">2</span>)</span><br><span class="line">        pivot = <span class="keyword">left</span></span><br><span class="line">        <span class="built_in">index</span> = <span class="keyword">left</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">index</span>, <span class="keyword">right</span>+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[pivot]:</span><br><span class="line">                self.swap(nums, i, <span class="built_in">index</span>)</span><br><span class="line">                <span class="built_in">index</span> += <span class="number">1</span></span><br><span class="line">        self.swap(nums, <span class="built_in">index</span>-<span class="number">1</span>, pivot)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">index</span>-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def swap(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>] = nums[<span class="keyword">right</span>], nums[<span class="keyword">left</span>]</span><br><span class="line">    </span><br><span class="line">    def quickSort(self, nums, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span> &lt; righ<span class="variable">t:</span></span><br><span class="line">            stack = [<span class="keyword">right</span>, <span class="keyword">left</span>]</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                i = stack.<span class="keyword">pop</span>()</span><br><span class="line">                <span class="keyword">j</span> = stack.<span class="keyword">pop</span>()</span><br><span class="line">                pivot_index = self.partition(nums, i, <span class="keyword">j</span>)</span><br><span class="line">                <span class="keyword">if</span> i &lt; pivot_index:</span><br><span class="line">                    stack.<span class="keyword">append</span>(pivot_index-<span class="number">1</span>)</span><br><span class="line">                    stack.<span class="keyword">append</span>(i)</span><br><span class="line">                <span class="keyword">if</span> pivot_index &lt; <span class="keyword">j</span>:</span><br><span class="line">                    stack.<span class="keyword">append</span>(<span class="keyword">j</span>)</span><br><span class="line">                    stack.<span class="keyword">append</span>(pivot_index+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    def sortArray(self, num<span class="variable">s:</span> List[<span class="keyword">int</span>]) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort2</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// quickSort(nums, 0, nums.size()-1);</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归版本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, left, pivot<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, pivot+<span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归版本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">            stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            s.<span class="built_in">push</span>(right);</span><br><span class="line">            s.<span class="built_in">push</span>(left);</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">int</span> l = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> r = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> pivot = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">                <span class="comment">// l, pivot-1</span></span><br><span class="line">                <span class="comment">// pivot+1, r</span></span><br><span class="line">                <span class="keyword">if</span> (l &lt; pivot<span class="number">-1</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(pivot<span class="number">-1</span>);</span><br><span class="line">                    s.<span class="built_in">push</span>(l);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pivot+<span class="number">1</span> &lt; r)&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(r);</span><br><span class="line">                    s.<span class="built_in">push</span>(pivot+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快排的核心函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt; nums[right])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left], nums[mid]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = left;</span><br><span class="line">        <span class="keyword">int</span> index = left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left+<span class="number">1</span>; i &lt;= right; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[pivot])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[index++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[index<span class="number">-1</span>], nums[pivot]);</span><br><span class="line">        <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>核心是merge函数，主体函数里面先将数组划分为两部分，分别mergesort后，执行两部分结果的merge</p>
<p>时间复杂度：O(nlogn), 但是空间复杂度为O(n)<br>稳定性：属于稳定排序</p>
<h3 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sortArray(self, num<span class="variable">s:</span> List[<span class="keyword">int</span>]) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(nums)</span><br><span class="line"></span><br><span class="line">    def mergeSort(self, nums):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        mid = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">left</span> = self.mergeSort(nums[<span class="number">0</span>:mid])</span><br><span class="line">        <span class="keyword">right</span> = self.mergeSort(nums[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(<span class="keyword">left</span>, <span class="keyword">right</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def merge(self, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> <span class="built_in">and</span> righ<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">left</span>[<span class="number">0</span>] &lt;= <span class="keyword">right</span>[<span class="number">0</span>]:</span><br><span class="line">                result.<span class="keyword">append</span>(<span class="keyword">left</span>.<span class="keyword">pop</span>(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.<span class="keyword">append</span>(<span class="keyword">right</span>.<span class="keyword">pop</span>(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> lef<span class="variable">t:</span></span><br><span class="line">            result.<span class="keyword">append</span>(<span class="keyword">left</span>.<span class="keyword">pop</span>(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> righ<span class="variable">t:</span></span><br><span class="line">            result.<span class="keyword">append</span>(<span class="keyword">right</span>.<span class="keyword">pop</span>(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="非递归版本-1"><a href="#非递归版本-1" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>假设 nums = [5,4,0,3,1,6,2,7]<br>第一次：我们将数组分为 8个子数组 每个数组 1 个元素，对相邻的两个数组进行排序合并。<br>第二次：我们将数组分为 4个子数组 每个数组 2 个元素，对相邻的两个数组进行排序合并。<br>第三次：我们将数组分为 2个子数组 每个数组 4 个元素，对相邻的两个数组进行排序合并。<br>第一步：划分每个子数组元素的个数（也就是子数组的长度)</p>
<ol>
<li>第一次 每个子数组元素 个数 为 1.</li>
<li>第二次 每个子数组元素 个数 为 2.</li>
<li>第三次 每个子数组元素 个数 为 4.<br>可以看出来 每个子数组元素个数 以2的倍数递增. 设置step步长，初始1，2倍递增<br>首先：求得要合并的两个相邻数组的区间 [low:mid) [mid:high)</li>
<li>当子数组长度为 1 的时候 要合并的相邻两个数组的区间为：<br>[0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8) 子数组长度为 1</li>
<li>子数组长度为 2 要合并的相邻两个数组的区间为：<br>[0,2) [2,4) [4,6) [6,8) 子数组长度为 2</li>
<li>子数组长度为 4 要合并的相邻两个数组的区间为：<br>[0,4) [4,8) 子数组长度为 4<br>下面来求 区间中的 low mid height:<br>low = low + 2 x step<br>mid = low + step<br>high = low + 2 x step</li>
</ol>
<p>但是要注意nums长度不为2的整数倍时，high可能越界，需要优化。</p>
<p>中间过程可能存在轮空的情况，mid和high的关系也需要确保mid&lt;high</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sortArray(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        <span class="literal">return</span> self.mergeSort(nums)</span><br><span class="line"></span><br><span class="line">    def mergeSort(self, nums):</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> step &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            low = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">mid</span> = low + step</span><br><span class="line">                high = <span class="built_in">min</span>(<span class="built_in">len</span>(nums), low+<span class="number">2</span>*step)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">mid</span> &lt; high:</span><br><span class="line">                    self.<span class="built_in">merge</span>(nums, low, <span class="keyword">mid</span>, high)</span><br><span class="line">                low += <span class="number">2</span>*step</span><br><span class="line">            step = step * <span class="number">2</span></span><br><span class="line">        <span class="literal">return</span> nums</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def <span class="built_in">merge</span>(self, nums, begin, <span class="keyword">mid</span>, <span class="keyword">end</span>):</span><br><span class="line">        <span class="built_in">result</span> = []</span><br><span class="line">        i, j = begin, <span class="keyword">mid</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="keyword">mid</span> <span class="keyword">and</span> j &lt; <span class="keyword">end</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                <span class="built_in">result</span>.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">result</span>.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="built_in">result</span> += nums[i:<span class="keyword">mid</span>]</span><br><span class="line">        <span class="built_in">result</span> += nums[j:<span class="keyword">end</span>]</span><br><span class="line">        nums[begin:<span class="keyword">end</span>] = <span class="built_in">result</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>核心是一个调整动作adjust函数，</p>
<p>建堆过程，从倒数第一个非叶子节点开始调整，直到第一个节点。<br>排序过程，每次选择堆顶元素与最后一个交换后调整第一个节点。</p>
<p>时间复杂度：O(nlogn), 有空可以详细推导一下<br>稳定性：中间交换过程不可控，不稳定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.heapSort(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        self.buildHeap(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.swap(nums, i, <span class="number">0</span>)</span><br><span class="line">            self.adjust(nums, <span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">self, nums, i, j</span>):</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.adjust(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust</span>(<span class="params">self, nums, i, length</span>):</span></span><br><span class="line">        temp = nums[i]</span><br><span class="line">        k = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; length:</span><br><span class="line">            <span class="comment"># 升序和降序修改此处第二个比较符号</span></span><br><span class="line">            <span class="keyword">if</span> k+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[k+<span class="number">1</span>] &gt; nums[k]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 升序和降序修改此处比较符号</span></span><br><span class="line">            <span class="keyword">if</span> nums[k] &gt; temp:</span><br><span class="line">                nums[i] = nums[k]</span><br><span class="line">                i = k</span><br><span class="line">            k = <span class="number">2</span>*k + <span class="number">1</span></span><br><span class="line">        nums[i] = temp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表(系列)</title>
    <url>/2022/02/08/leetcode/leetcode-reverse-list/</url>
    <content><![CDATA[<h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h2><h4 id="方法一：依次插入空头节点后完成反转"><a href="#方法一：依次插入空头节点后完成反转" class="headerlink" title="方法一：依次插入空头节点后完成反转"></a>方法一：依次插入空头节点后完成反转</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># 1.构造带头节点的空链表，注意next为None，后续会变为最后一个节点</span></span><br><span class="line"><span class="comment"># 2. 将链表节点p依次插入空链表的头节点之后</span></span><br><span class="line"><span class="comment"># 3. 注意终止条件，q=NULL</span></span><br><span class="line"><span class="comment"># 4. 注意处理最后一个p节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(<span class="keyword">self</span>, <span class="symbol">head:</span> ListNode)</span></span> -&gt; <span class="symbol">ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="symbol">head:</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        p = head</span><br><span class="line">        q = head.<span class="keyword">next</span></span><br><span class="line">        <span class="keyword">while</span> <span class="symbol">q:</span></span><br><span class="line">            p.<span class="keyword">next</span> = dummy.<span class="keyword">next</span></span><br><span class="line">            dummy.<span class="keyword">next</span> = p</span><br><span class="line">            p = q</span><br><span class="line">            q = q.<span class="keyword">next</span></span><br><span class="line">        p.<span class="keyword">next</span> = dummy.<span class="keyword">next</span></span><br><span class="line">        dummy.<span class="keyword">next</span> = p</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二：直接链表一次遍历完成反转"><a href="#方法二：直接链表一次遍历完成反转" class="headerlink" title="方法二：直接链表一次遍历完成反转"></a>方法二：直接链表一次遍历完成反转</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># pre初始指向空，p指向当前待处理节点，初始为head，q记录p的下一个节点</span></span><br><span class="line"><span class="comment"># p连上上一个节点pre，pre变为当前节点p，p后移指向下一个待处理节点q</span></span><br><span class="line"><span class="comment"># 结束时，p为空，pre为最后被处理的节点，即新链表的头节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = p </span><br><span class="line">            p = q</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方法三：迭代求解"><a href="#方法三：迭代求解" class="headerlink" title="方法三：迭代求解"></a>方法三：迭代求解</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># 以第一个节点为未反转部分，剩下部分为已求解部分</span></span><br><span class="line"><span class="comment"># 第二个节点为已求解部分最后的一个节点，将最后一个未反转节点加入已求解部分</span></span><br><span class="line"><span class="comment"># 注意两点：1. head.next为空需要提前判断，否则有语法错误   2.最终一个节点的next为None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        right = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<h1 id="复用以前的反转算法"><a href="#复用以前的反转算法" class="headerlink" title="复用以前的反转算法"></a>复用以前的反转算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># head为第一个要处理的节点，tail为要处理节点的下一个节点，可能为None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head, tail</span>):</span></span><br><span class="line">            prev = tail</span><br><span class="line">            cur = head</span><br><span class="line">            p = head</span><br><span class="line">            <span class="keyword">while</span> p != tail:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = prev</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = p</span><br><span class="line">            <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        p = dummy</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        prev_node = dummy</span><br><span class="line">        right_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> count == left-<span class="number">1</span>:</span><br><span class="line">                prev_node = p</span><br><span class="line">            <span class="keyword">if</span> count == right:</span><br><span class="line">                right_node = p</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(prev_node.val, right_node.val)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right_node:</span><br><span class="line">            prev_node.<span class="built_in">next</span> = reverseList(prev_node.<span class="built_in">next</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev_node.<span class="built_in">next</span> = reverseList(prev_node.<span class="built_in">next</span>, right_node.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题学习大纲</title>
    <url>/2021/11/21/algorithm/</url>
    <content><![CDATA[<h2 id="算法全局概览"><a href="#算法全局概览" class="headerlink" title="算法全局概览"></a>算法全局概览</h2><p><img data-src="http://huifangshuyuan.com/img/algorithm.png" alt="算法概览图"></p>
<h2 id="TOP20"><a href="#TOP20" class="headerlink" title="TOP20"></a>TOP20</h2><p>10个数据结构<br>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；</p>
<p>10个算法<br>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</p>
<h2 id="学习原则"><a href="#学习原则" class="headerlink" title="学习原则"></a>学习原则</h2><p>学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景” </p>
<h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><ul>
<li>算法专栏</li>
<li>剑指offer</li>
<li>牛客高频300</li>
<li>leetcode各分类3题</li>
</ul>
<p>3链表：<a href="https://leetcode.com/problemset/all/?topicSlugs=linked-list">https://leetcode.com/problemset/all/?topicSlugs=linked-list</a></p>
<p>3栈: <a href="https://leetcode.com/problemset/all/?topicSlugs=stack">https://leetcode.com/problemset/all/?topicSlugs=stack</a></p>
<p>3队列：<a href="https://leetcode.com/problemset/all/?topicSlugs=queue">https://leetcode.com/problemset/all/?topicSlugs=queue</a></p>
<p>散列表：</p>
<p>6二叉树：<a href="https://leetcode.com/problemset/all/?topicSlugs=tree">https://leetcode.com/problemset/all/?topicSlugs=tree</a></p>
<p>3堆：<a href="https://leetcode.com/problemset/all/?topicSlugs=heap">https://leetcode.com/problemset/all/?topicSlugs=heap</a></p>
<p>跳表：</p>
<p>6图：<a href="https://leetcode.com/problemset/all/?topicSlugs=graph">https://leetcode.com/problemset/all/?topicSlugs=graph</a></p>
<p>3Trie树：<a href="https://leetcode.com/problemset/all/?topicSlugs=trie">https://leetcode.com/problemset/all/?topicSlugs=trie</a></p>
<p>3递归：<a href="https://leetcode.com/problemset/all/?topicSlugs=recursion">https://leetcode.com/problemset/all/?topicSlugs=recursion</a></p>
<p>6排序：<a href="https://leetcode.com/problemset/all/?topicSlugs=sort">https://leetcode.com/problemset/all/?topicSlugs=sort</a></p>
<p>3二分查找：<a href="https://leetcode.com/problemset/all/?topicSlugs=binary-search">https://leetcode.com/problemset/all/?topicSlugs=binary-search</a></p>
<p>搜索：</p>
<p>哈希算法：</p>
<p>6贪心算法：<a href="https://leetcode.com/problemset/all/?topicSlugs=greedy">https://leetcode.com/problemset/all/?topicSlugs=greedy</a></p>
<p>6分治算法：<a href="https://leetcode.com/problemset/all/?topicSlugs=divide-and-conquer">https://leetcode.com/problemset/all/?topicSlugs=divide-and-conquer</a></p>
<p>6回溯算法：<a href="https://leetcode.com/problemset/all/?topicSlugs=backtracking">https://leetcode.com/problemset/all/?topicSlugs=backtracking</a></p>
<p>6+动态规划：<a href="https://leetcode.com/problemset/all/?topicSlugs=dynamic-programming">https://leetcode.com/problemset/all/?topicSlugs=dynamic-programming</a></p>
<p>字符串匹配：</p>
<p>其他：</p>
<p>哈希表<a href="https://leetcode.com/problemset/all/?topicSlugs=hash-table">https://leetcode.com/problemset/all/?topicSlugs=hash-table</a></p>
<h2 id="经典算法题目梳理"><a href="#经典算法题目梳理" class="headerlink" title="经典算法题目梳理"></a>经典算法题目梳理</h2><ul>
<li>1.单链表是否有环  环的入口</li>
<li>2.最长公共子串和最长公共子序列</li>
<li>3.二叉树的先序，中序，后序，层序遍历</li>
<li>4.快速排序，归并排序，堆排序</li>
<li>5.atoi</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日微习惯</title>
    <url>/2021/11/21/daily-plan-note/</url>
    <content><![CDATA[<p>12月5日  后续通过flomo记录，并改为每周计划与复盘</p>
<p>11月24日 后续改为评论区记录，可以更加清楚的看出时间线</p>
<h3 id="2021年11月23日"><a href="#2021年11月23日" class="headerlink" title="2021年11月23日"></a>2021年11月23日</h3><table>
<thead>
<tr>
<th>TODO</th>
<th>是否完成</th>
<th>完成时间与说明</th>
</tr>
</thead>
<tbody><tr>
<td>锻炼</td>
<td>是</td>
<td>下午4点跑步3km</td>
</tr>
<tr>
<td>早上阅读</td>
<td>是</td>
<td>9.30-10:30点阅读。合计1h</td>
</tr>
<tr>
<td>中午阅读</td>
<td>是</td>
<td>13-14阅读 合计1h</td>
</tr>
<tr>
<td>晚上阅读</td>
<td>是</td>
<td>晚上阅读0.5h, 感觉长时间阅读同一个东西，有点厌烦的感觉，应该交替着进行</td>
</tr>
</tbody></table>
<h3 id="2021年11月22日"><a href="#2021年11月22日" class="headerlink" title="2021年11月22日"></a>2021年11月22日</h3><table>
<thead>
<tr>
<th>TODO</th>
<th>是否完成</th>
<th>完成时间与说明</th>
</tr>
</thead>
<tbody><tr>
<td>锻炼</td>
<td>是</td>
<td>下午5点跑步5km</td>
</tr>
<tr>
<td>早上阅读</td>
<td>是</td>
<td>早上8-8.15, 9.30-11点阅读。合计1.5h</td>
</tr>
<tr>
<td>中午阅读</td>
<td>否</td>
<td>有点困，未完成。今天早点睡，明天要不顾一切的完成</td>
</tr>
<tr>
<td>晚上阅读</td>
<td>否</td>
<td>做规划，未完成。明天要不顾一切的完成</td>
</tr>
</tbody></table>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>每周锻炼3次，2021年11月20日启动</li>
<li>每周阅读20小时，2021年11月22日启动</li>
<li>每周刷一道算法题，2021年11月22日启动</li>
</ol>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><ul>
<li>锻炼可以有良好的身体，身体是一切的基础。不阅读有如文盲，文盲无法在这个社会生存。</li>
<li>二者都属于第二象限的人生要事，需要保证</li>
<li>每日记载总结，周级复盘，理论-实践-反馈分析的循环必超凡入圣</li>
</ul>
<h2 id="时间从哪来"><a href="#时间从哪来" class="headerlink" title="时间从哪来"></a>时间从哪来</h2><p>锻炼：</p>
<ul>
<li>工作日：每天下午5点，如果5点有会，就4点；如果没有跑步机，就早起跑步</li>
<li>周末：公司跑步或早起跑步</li>
<li>没有特殊情况，比如下雨就在家keep，总之不找理由尽可能想办法实现。</li>
</ul>
<p>阅读：</p>
<ul>
<li>工作日：早上10点半以前，中午1点至2点，晚上6点至7点</li>
<li>周末：尽可能安排在上午，原则是补足20小时，若已满20小时，则至少阅读1小时</li>
<li>第二象限的工作，不找借口，保证完成。最终必会反哺工作和生活</li>
</ul>
<h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h2><p>锻炼：</p>
<ul>
<li>体重</li>
<li>BMI</li>
<li>最大摄氧量</li>
<li>仰卧起坐个数</li>
<li>俯卧撑个数</li>
<li>头发色泽和密度</li>
<li>三围</li>
<li>身材图(正面和侧面)</li>
</ul>
<p>阅读：</p>
<ul>
<li>每日阅读时长</li>
<li>每月阅读书本数</li>
<li>产出读书笔记数</li>
</ul>
<h2 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h2><p>锻炼：</p>
<ul>
<li>第一阶段：跑步</li>
<li>第二阶段：跑步与力量训练交替</li>
</ul>
<p>阅读：</p>
<ul>
<li>方式：主题阅读(技术、成长、业务、效能、管理、财务)</li>
<li>阅读什么书？要阅读当下感兴趣的书，快速阅读，吸取有用的部分即可<br><img data-src="http://huifangshuyuan.com/img/book_familiarVSinterest.jpeg" alt="书的分类"></li>
<li>如何选书：豆瓣评分7.0以上的书，豆瓣评论，大咖推荐</li>
</ul>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Misunderstandings-in-Life</title>
    <url>/2021/11/14/Misunderstandings-in-life/</url>
    <content><![CDATA[<p>记录一些生活中的误解</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><h3 id="错误归因"><a href="#错误归因" class="headerlink" title="错误归因"></a>错误归因</h3><h3 id="真实原因原因"><a href="#真实原因原因" class="headerlink" title="真实原因原因"></a>真实原因原因</h3>]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>周计划设定与Review</title>
    <url>/2021/08/29/weekly-plan-note/</url>
    <content><![CDATA[<hr>
<h2 id="2022-1-Week3-四个维度平衡发展"><a href="#2022-1-Week3-四个维度平衡发展" class="headerlink" title="2022-1 Week3 四个维度平衡发展"></a>2022-1 Week3 四个维度平衡发展</h2><p>每周学习20小时<br>2022.1.17-2022.1.23</p>
<p>TOP1: 家庭幸福<br>TODO：未计划</p>
<p>TOP2: 精力充沛(锻炼、饮食、休息)<br>TODO：每周运动3次+，每次30min</p>
<p>TOP2: 工作发展(晋升，技术业务管理)<br>TODO：每天看一章节，刷1道题</p>
<p>TOP2: 财务自由<br>TODO：每天学习30min；周末输出一篇文章</p>
<span id="more"></span> 

<h2 id="2022-1-Week3-四个维度平衡发展-1"><a href="#2022-1-Week3-四个维度平衡发展-1" class="headerlink" title="2022-1 Week3 四个维度平衡发展"></a>2022-1 Week3 四个维度平衡发展</h2><p>每周学习20小时<br>2022.1.10-2022.1.16</p>
<p>TOP1: 家庭幸福<br>TODO：未计划</p>
<p>TOP2: 精力充沛(锻炼、饮食、休息)<br>TODO：每周运动3次+，每次30min<br>REVEIW：跑步4次，最大摄氧量47</p>
<p>TOP2: 工作发展(晋升，技术业务管理)<br>TODO：每天学习30min</p>
<p>TOP2: 财务自由<br>TODO：学习30min</p>
<p>行动指南：<br><img data-src="http://huifangshuyuan.com/img/six_things20211120.png" alt="六大维度均衡发展"></p>
<h2 id="2022-1-Week2-TOP3"><a href="#2022-1-Week2-TOP3" class="headerlink" title="2022-1 Week2 TOP3"></a>2022-1 Week2 TOP3</h2><p>2022.1.3-2022.1.9<br>每周学习20小时</p>
<p>未计划</p>
<h2 id="2022-1-Week1-TOP3"><a href="#2022-1-Week1-TOP3" class="headerlink" title="2022-1 Week1 TOP3"></a>2022-1 Week1 TOP3</h2><p>2021.12.27-2022.1.2<br>每周学习20小时</p>
<p>TOP1: 锻炼身体<br>TODO：每周运动3次+，每次30min<br>Review:完成</p>
<p>TOP2: 阅读<br>TODO：完成&lt;掌控&gt;学习笔记<br>review:未完成</p>
<p>TOP3：工作精进<br>TODO：完成算法专栏学习<br>review：未完成</p>
<h2 id="2021-12-Week4-TOP3"><a href="#2021-12-Week4-TOP3" class="headerlink" title="2021-12 Week4 TOP3"></a>2021-12 Week4 TOP3</h2><p>2021.12.20-2021.12.26<br>未计划</p>
<h2 id="2021-12-Week3-TOP3"><a href="#2021-12-Week3-TOP3" class="headerlink" title="2021-12 Week3 TOP3"></a>2021-12 Week3 TOP3</h2><p>2021.12.13-2021.12.19<br>整体每周学习20小时，二者大概比例2：1，即技术14小时，身体7小时<br>中间感悟与时长用flomo记录，周五晚上复盘，不足之处周末补足。<br>此外，继续每周记账，确定财务自由的基数。</p>
<p>TOP1: 锻炼身体<br>TODO：每周运动3次+，每次30min<br>Review:完成</p>
<p>TOP2: 阅读<br>TODO：阅读完成&lt;掌控&gt;，完成学习笔记和运动指标的设定；确定财务相关书籍、关注博主等<br>review：读完，但是未做笔记</p>
<p>TOP3：工作精进<br>TODO：完成算法专栏学习；阅读10页统计学习方法<br>review：未完成</p>
<h2 id="2021-12-Week2-TOP3"><a href="#2021-12-Week2-TOP3" class="headerlink" title="2021-12 Week2 TOP3"></a>2021-12 Week2 TOP3</h2><p>2021.12.6-2021.12.12<br>计划前感想：<br>当前阶段最重要的事情是找到一份推荐算法的工作，所以核心是算法题和ML相关知识学习。<br>此外非技术方面，需要保持对阅读的持续投入，主题暂定为身体、精力与生产力提升方面<br>整体每周学习20小时，二者大概比例2：1，即技术14小时，身体7小时<br>周一至周五每天三小时，早上和晚上看技术，中午看非技术<br>中间感悟用flomo记录，每周复盘。<br>此外，从12月1日开始，每周记账，确定财务自由的基数。<br>复盘时感想：<br>推荐算法的工作有点畏难情绪，没有开展，也因为担心沉没成本太高，所以其实处于摇摆不定的状态。<br>下周继续推进，先初步完成一轮计划再看。摇摆最伤人<br>算法课程继续有在跟进。下周继续跟进，并记录学习时长。<br>本周整理了投资相关的文章，确立初步大方向，当前阶段投资方面最重要的是渡过第零阶段，蓄满前面2桶水，<br>计划年前给家人做一次正式汇报</p>
<p>TOP1: 锻炼身体<br>TODO：每周运动3次+，每次30min<br>Review: 本周跑步5次，撸铁1次，户外散步1次。但是下周需要由时间或者次数驱动改为有氧适能指标驱动。</p>
<p>TOP2: 阅读<br>TODO：阅读段永平雪球问答录。整理出身体相关的书籍<br>review：阅读&lt;掌控&gt;，进度10%；初步完成投资体系的整理</p>
<p>TOP3：工作精进<br>TODO：如何做推荐算法<br>review：未完成</p>
<h2 id="2021-11-Week1-TOP3-Review"><a href="#2021-11-Week1-TOP3-Review" class="headerlink" title="2021-11 Week1 TOP3  Review"></a>2021-11 Week1 TOP3  Review</h2><p>2021.11.29-2021.12.5</p>
<p>TOP1: 锻炼身体<br>TODO：每周运动3次+，每次30min<br>RESULT: 只运用了2次</p>
<p>TOP2: 阅读<br>TODO：每月阅读一本非技术书<br>RESULT：阅读了财务自由星球</p>
<p>TOP3：工作精进<br>TODO：保留随时跳槽的能力<br>RESULT: UNDO</p>
<h2 id="2021-11-Week4-TOP3-Review"><a href="#2021-11-Week4-TOP3-Review" class="headerlink" title="2021-11 Week4 TOP3  Review"></a>2021-11 Week4 TOP3  Review</h2><p>2021.11.22-2021.11.28</p>
<p>TOP1: 锻炼身体<br>TODO：每周运动3次+，每次30min<br>RESULT: 完成</p>
<p>TOP2: 阅读<br>TODO：每月阅读一本非技术书<br>RESULT：UNDO</p>
<p>TOP3：工作精进<br>TODO：保留随时跳槽的能力<br>RESULT: UNDO</p>
<h2 id="2021-11-Week3-TOP3-Review"><a href="#2021-11-Week3-TOP3-Review" class="headerlink" title="2021-11 Week3 TOP3 Review"></a>2021-11 Week3 TOP3 Review</h2><p>2021.11.15-2021.11.21</p>
<p>TOP1: 机器学习理论</p>
<p>TODO：通读《统计学习方法》，5-10章，每天1个小时，不懂的认为没有缘分，先标记跳过学习。</p>
<p>完成情况：未完成。需要保证读书时间，早中晚各一个小时</p>
<p>TOP2: 健康身体</p>
<p>TODO: 锻炼三次</p>
<p>完成情况：完成7次运动</p>
<p>TOP3: 生活规划<br>TODO: 思考2022年的OKR</p>
<p>完成情况：完成整体工作拆解(身体、认知、关系、内心、工作、财务)。</p>
<p>当前需要行动起来的有：</p>
<p>1.每天运动30min</p>
<p>2.每月阅读一本书，制定并执行阅读计划</p>
<p>3.制定跳槽能力训练计划：刷题、梳理项目</p>
<p>4.继续执行推荐系统学习计划</p>
<p>5.制定并缓慢布局财务自由计划</p>
<h2 id="2021-11-Week2-TOP3-Review"><a href="#2021-11-Week2-TOP3-Review" class="headerlink" title="2021-11 Week2 TOP3 Review"></a>2021-11 Week2 TOP3 Review</h2><p>2021.11.8-2021.11.14</p>
<p>TOP1: 机器学习理论<br>TODO：通读《统计学习方法》，5-10章，每天1个小时，不懂的认为没有缘分，先标记跳过学习。<br>完成情况：未完成</p>
<p>TOP2: 健康身体<br>TODO: 锻炼三次<br>完成情况：完成</p>
<p>TOP3: 生活规划<br>TODO: 思考2022年的OKR<br>完成情况：未完成</p>
<h2 id="2021-11-Week1-TOP3-Review-1"><a href="#2021-11-Week1-TOP3-Review-1" class="headerlink" title="2021-11 Week1 TOP3 Review"></a>2021-11 Week1 TOP3 Review</h2><p>2021.11.1-2021.11.7</p>
<p>TOP1: 机器学习理论<br>TODO：通读《统计学习方法》，每天1个小时，不懂的认为没有缘分，先标记跳过学习。<br>完成情况：未完成，周末合计学习4小时，阅读至第5章，决策树</p>
<p>TOP2: 健康身体<br>TODO: 锻炼三次<br>完成情况：完成。本周完成5次跑步</p>
<h2 id="2021-10-Week5-TOP3-Review"><a href="#2021-10-Week5-TOP3-Review" class="headerlink" title="2021-10 Week5 TOP3 Review"></a>2021-10 Week5 TOP3 Review</h2><p>2021.10.25-2021.10.31</p>
<p>TOP1: 机器学习理论<br>TODO：通读《统计学习方法》，每天30页，不懂的认为没有缘分，先标记跳过学习。<br>完成情况：未完成</p>
<p>TOP2: 健康身体<br>TODO: 锻炼三次<br>完成情况：完成。俯卧撑2次，跑步两次</p>
<!--more--> 

<h2 id="2021-10-Week4-TOP3-Review"><a href="#2021-10-Week4-TOP3-Review" class="headerlink" title="2021-10 Week4 TOP3 Review"></a>2021-10 Week4 TOP3 Review</h2><p>2021.10.18-2021.10.24<br>TOP1: 机器学习理论<br>TODO：集中精力全力完成吴恩达课程3次编程作业和总结<br>完成情况：完成课程学习。神经网络、SVM、推荐系统部分有疑问需要补足。</p>
<p>TOP2: 健康身体<br>TODO: 健身3次<br>完成情况：未完成。</p>
<h2 id="2021-10-Week3-TOP3-Review"><a href="#2021-10-Week3-TOP3-Review" class="headerlink" title="2021-10 Week3 TOP3 Review"></a>2021-10 Week3 TOP3 Review</h2><p>2021.10.11-2021.10.17</p>
<p>TOP1: 机器学习理论<br>TODO：完成吴恩达课程3次编程作业和总结<br>完成情况：未完成。本周做Q4工作规划、家里事情太多</p>
<p>TOP2: 健康身体<br>TODO: 健身3次<br>完成情况：未完成。后续晚上在家做俯卧撑和仰卧起坐</p>
<p>TOP3: 输入&amp;&amp;输出<br>TODO：输出一篇星球PPT&amp;语音；一篇房产文章<br>完成情况：未完成，暂缓。但是后续非技术层面需要跟进</p>
<h2 id="2021-10-Week2-TOP3-Review"><a href="#2021-10-Week2-TOP3-Review" class="headerlink" title="2021-10 Week2 TOP3 Review"></a>2021-10 Week2 TOP3 Review</h2><p>2021.10.4-2021.10.10</p>
<p>TOP1: 机器学习理论<br>TODO：未完成。剩余第7-9周编程作业</p>
<p>TOP2: 健康身体<br>TODO: 完成</p>
<p>TOP3: 输入&amp;&amp;输出<br>TODO: 未完成。</p>
<h2 id="2021-10-Week1-TOP3-Review"><a href="#2021-10-Week1-TOP3-Review" class="headerlink" title="2021-10 Week1 TOP3 Review"></a>2021-10 Week1 TOP3 Review</h2><p>2021.9.27-2021.10.3</p>
<p>TOP1: 机器学习理论<br>TODO：完成4-6课</p>
<p>TOP2: 健康身体<br>TODO: 完成</p>
<h2 id="2021-09-Week4-TOP3"><a href="#2021-09-Week4-TOP3" class="headerlink" title="2021-09 Week4 TOP3"></a>2021-09 Week4 TOP3</h2><p>TOP1: 机器学习理论<br>TODO：完成吴恩达第3周学习，预计需要6.5小时；完成第4周学习，预计需要4.5小时</p>
<p>TOP2: 健康身体<br>TODO: 健身3次</p>
<p>TOP3: 软实力:输入与输出<br>TODO: 阐述使命愿景价值观战略的含义及各大公司案例; 阅读并分享Measure What Matters</p>
<h3 id="2021-09-Week4-TOP3-Review"><a href="#2021-09-Week4-TOP3-Review" class="headerlink" title="2021-09 Week4 TOP3 Review"></a>2021-09 Week4 TOP3 Review</h3><p>TOP1: 机器学习理论<br>TODO：【未完成】第三周已完成，第四周编程部分未完成。</p>
<p>TOP2: 健康身体，体脂率17%<br>TODO: 【未完成】本周感冒，未锻炼</p>
<p>TOP3: 软实力:输入与输出<br>TODO: 【未完成】此项pending，后续全力完成TOP1</p>
<h2 id="2021-09-Week3-TOP3"><a href="#2021-09-Week3-TOP3" class="headerlink" title="2021-09 Week3 TOP3"></a>2021-09 Week3 TOP3</h2><p>TOP1: 机器学习理论<br>TODO：完成吴恩达第3周学习</p>
<p>TOP2: 健康身体<br>TODO: 健身3次</p>
<p>TOP3: 软实力:输入与输出<br>TODO: 阐述使命愿景价值观战略的含义及各大公司案例<br>备注: 优先[职场]和[个人成长]这俩主题分享</p>
<h3 id="2021-09-Week3-TOP3-Review"><a href="#2021-09-Week3-TOP3-Review" class="headerlink" title="2021-09 Week3 TOP3 Review"></a>2021-09 Week3 TOP3 Review</h3><p>TOP1: 机器学习理论<br>TODO：【未完成】第二周linear regression部分的习题周日(9.19)才完成</p>
<p>TOP2: 健康身体，体脂率17%<br>TODO: 【未完成】健身2次，keep瑜伽一次</p>
<p>TOP3: 软实力:输入与输出<br>TODO: 【未完成】阐述使命愿景价值观战略的含义及各大公司案例，预计9.20完成</p>
<h2 id="2021-09-Week2-TOP3"><a href="#2021-09-Week2-TOP3" class="headerlink" title="2021-09 Week2 TOP3"></a>2021-09 Week2 TOP3</h2><p>TOP1: 机器学习理论<br>TODO：完成吴恩达第3周学习</p>
<p>TOP2: 健康身体<br>TODO: 健身3次，跑步1次</p>
<p>TOP3: 软实力:输入与输出<br>TODO: 整理星球主题</p>
<h3 id="2021-09-Week2-TOP3-Review"><a href="#2021-09-Week2-TOP3-Review" class="headerlink" title="2021-09 Week2 TOP3 Review"></a>2021-09 Week2 TOP3 Review</h3><p>TOP1: 机器学习理论<br>TODO：【未完成】第二周剩余Octave教程部分和练习题</p>
<p>TOP2: 健康身体，体脂率17%<br>TODO: 【完成】健身3次，【未完成】跑步1次</p>
<p>TOP3: 软实力:输入与输出<br>TODO: 【完成】整理星球主题</p>
<h2 id="2021-09-Week1-TOP3"><a href="#2021-09-Week1-TOP3" class="headerlink" title="2021-09 Week1 TOP3"></a>2021-09 Week1 TOP3</h2><p>TOP1: 机器学习理论<br>TODO：学习机器学习数学基础</p>
<p>TOP2: 健康身体<br>TODO: 锻炼5次+</p>
<h3 id="2021-09-Week1-TOP3-Review"><a href="#2021-09-Week1-TOP3-Review" class="headerlink" title="2021-09 Week1 TOP3 Review"></a>2021-09 Week1 TOP3 Review</h3><p>TOP1: 机器学习理论<br>TODO：学习吴恩达课程第一周完成</p>
<p>TOP2: 健康身体<br>TODO: 完成3次健身，2次5km跑步</p>
<p>当前候选书单：<br>技术类：</p>
<ul>
<li><input disabled="" type="checkbox"> 统计学习方法</li>
<li><input disabled="" type="checkbox"> 花书，</li>
<li><input disabled="" type="checkbox"> 机器学习实战，</li>
<li><input disabled="" type="checkbox"> 深度学习推荐系统</li>
<li><input disabled="" type="checkbox"> 算法专栏</li>
</ul>
<p>非技术类：</p>
<ul>
<li><input disabled="" type="checkbox"> 用图表说话</li>
<li><input disabled="" type="checkbox"> 写给大家看的设计书</li>
<li><input disabled="" type="checkbox"> 金字塔原理</li>
<li><input disabled="" type="checkbox"> 系统思考🤔</li>
<li><input disabled="" type="checkbox"> 系统思考2</li>
<li><input disabled="" type="checkbox"> 这就是OKR</li>
<li><input disabled="" type="checkbox"> 保洁战略模型</li>
</ul>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐策略入门学习记录</title>
    <url>/2021/08/29/machine-learning-note/</url>
    <content><![CDATA[<p>经过知识点梳理、目标确定、行动拆分后确定第一阶段推荐策略入门规划如下</p>
<p>理论(3月)—-框架(1.5月)—–实战(1.5月)—–面试(3月)</p>
<p>前6个月学习大致拆分如下：</p>
<ul>
<li>9.1-9.15      0.5月, 通读花书数学基础章节</li>
<li>9.1-10.15     1.5月, <a href="https://www.coursera.org/learn/machine-learning">吴恩达课程</a></li>
<li>10.1-10.31    1月, 通读统计学习方法</li>
<li>11.1-11.30    1月, 通读花书CNN、RNN、LSTM部分</li>
<li>12.1-12.15    0.5月, 学习sklearn框架，实现3个算法</li>
<li>12.16-1.15    1月, 学习pytorch框架，实现图片分类功能</li>
<li>1.16-2.16     1月, 通读机器学习实战</li>
<li>2.17-2.28     0.5月, 推荐系统专栏</li>
</ul>
<span id="more"></span> 

<h1 id="2021-9-13"><a href="#2021-9-13" class="headerlink" title="2021.9.13"></a>2021.9.13</h1><p>1.学习第二周课程Octave Tutorial部分</p>
<h1 id="2021-9-19"><a href="#2021-9-19" class="headerlink" title="2021.9.19"></a>2021.9.19</h1><p>完成第二周linear regression部分编程作业</p>
<h1 id="2021-9-20-8-00"><a href="#2021-9-20-8-00" class="headerlink" title="2021.9.20 8:00"></a>2021.9.20 8:00</h1><p>启动第三周课程的学习<br><a href="https://www.coursera.org/learn/machine-learning/home/week/3">https://www.coursera.org/learn/machine-learning/home/week/3</a></p>
<h1 id="2021-9-20-12-40"><a href="#2021-9-20-12-40" class="headerlink" title="2021.9.20 12:40"></a>2021.9.20 12:40</h1><p>完成第三周课程部分学习</p>
<h1 id="2021-9-28-7-39"><a href="#2021-9-28-7-39" class="headerlink" title="2021.9.28 7:39"></a>2021.9.28 7:39</h1><p>完成第三周编程作业 100分。<br>后面最好还是学完一课立马完成编程作业巩固。</p>
<h1 id="2021-10-24"><a href="#2021-10-24" class="headerlink" title="2021.10.24"></a>2021.10.24</h1><p>完成吴恩达机器学习课程学习，得分96.86分。<br>神经网络、推荐系统部分尚有疑问，其他部分可以理解原理和实现。<br>SVM部分可以实现，原理尚有疑问。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>海淀驾校二轮摩托车驾照考试流程</title>
    <url>/2021/08/07/how-to-get-a-motorcycle-driver-licence/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文简单介绍一下北京摩托车驾照获得的流程和考试的一些心得，希望能帮到大家。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>长安居大不易，相信每一个帝都生活的朋友都对生活的艰难有自己的感受，在汽车摇号无望，电动车续航不给力，地铁太挤，打车太堵且贵，长期骑单车太累的情况下，<br>摩托通勤成为了一个勉强可以接受的方案，虽然明知”肉包铁”，也不得已而为之。</p>
<p>话不多说，直入主题，我是2021年5月份在海淀驾校报名的，主要是因为海驾班车比较方便。</p>
<p>我报的是二轮摩托车，也就是俗称的E本，活动优惠后价格是900元，大概7月中旬考完科目一后，连续预约了3次练习，8月1日晚上集训一次，8月2日科目二科目三科目四都是一把过，成功拿本。</p>
<p>其实如果不差钱且想快速拿本的话，建议报三轮摩托车，由于三轮摩托车车速较慢且不需要考虑平衡性问题，考试较简单。三轮是D本，涵盖了E本的全部功能。</p>
<span id="more"></span>

<h3 id="北京摩托车限行规定"><a href="#北京摩托车限行规定" class="headerlink" title="北京摩托车限行规定"></a>北京摩托车限行规定</h3><p>摩托车车牌主要分京A和京B两类，京A是公户，目前比较难办。<br>个人办理的主要是京B私户，京B仅限户口或居住证在非城6区(东城、西城、朝阳、海淀、丰台、石景山)居民办理，可以过户。<br>我们主要关注京B的政策：</p>
<p>北京市要求摩托车不允许进入四环以内（但四环双向辅路可以行使），以及四环主路、五环主路不允许上。</p>
<p>还有一些其他的限禁行规则，可以在百度地图绑定车牌后使用摩托车导航功能，避开具体限制。</p>
<h3 id="驾照记分规则"><a href="#驾照记分规则" class="headerlink" title="驾照记分规则"></a>驾照记分规则</h3><p>摩托车作为机动车，其驾照是和小汽车合并在一起的，也共享12分的累计记分。<br>在报名驾照学习的时候，如果你已有其他驾照，比如小汽车C1的驾照，这个时候你需要走”增驾”流程，<br>假设你报名的是三轮摩托车，如果增驾流程通过的话，你会得到一个新的驾驶本，C1D驾照。</p>
<p>需要重点注意的是，驾驶小汽车和摩托车的12分是共享的，也就是说如果你拿到C1D本以后，如果开汽车扣了6分，开摩托扣了6分，<br>那么你合计就扣了12分，需要重新去参加理论考试了。如果你的摩托车恰好还在实习期，那尴尬了，摩托车驾照作废，你得重新去参加所有科目的考试。</p>
<h3 id="驾照学习整体流程"><a href="#驾照学习整体流程" class="headerlink" title="驾照学习整体流程"></a>驾照学习整体流程</h3><h4 id="1-报名"><a href="#1-报名" class="headerlink" title="1. 报名"></a>1. 报名</h4><p>首先你要去驾校报名，直接带身份证和money去驾校，现场有自助机可以拍照，体检，一站式搞定。<br>目前外地户口也不需要居住证了。如果你是增驾，记得把原驾照也带着。</p>
<h4 id="2-科目一理论学习与备考"><a href="#2-科目一理论学习与备考" class="headerlink" title="2. 科目一理论学习与备考"></a>2. 科目一理论学习与备考</h4><p>报名后，你需要在海淀驾校APP学习相应的视频，这个有相应的学习时长要求，打开app按要求播放完就可以了，老师讲的还不错，有时间的可以看一看。</p>
<p>在app上学习完科目一的课程后，你就可以在海淀驾校官网开始约考科目一的考试了，这个地址不用记，报名的时候工作人员会告诉你</p>
<p>正式考试前，你需要在驾考宝典上过一遍题库，然后做几套模拟真题，科目一考试通过标准是90分及格。你连续做3套真题，都能得到95分以上，基本就可以去参加考试了，这样很稳。</p>
<h4 id="3-科目一考试"><a href="#3-科目一考试" class="headerlink" title="3. 科目一考试"></a>3. 科目一考试</h4><p>考试当天，记得携带身份证按时去海驾6号楼报道，录完指纹后就可以去大厅侯考，从录完指纹到考试结束大概2个小时可以搞定，上班族可以中午请假2小时过来。</p>
<p>科目一考试通过，可以开始预约科目二的训练(其实是科目二和科目三一起)，可以现场预约和电话预约，建议现场直接预约比较容易，电话预约比较困难。</p>
<p>现场预约会给你一张小票，可以拍个照留存，免得到时候自己忘了。</p>
<h4 id="4-科目二训练和考试"><a href="#4-科目二训练和考试" class="headerlink" title="4. 科目二训练和考试"></a>4. 科目二训练和考试</h4><p>科目二训练每天有3个时段，分别是早(8：30-11：30)、中(12：30-15：30)、晚(16：30-17：30)，每个时段有对应的班车前往，平时和周末有细微差异，<br>可以在海驾app上查看班车情况。<br>每个训练时段大约是3个小时，每天最多只能预约一个时段，每个时段会同时有约8+人轮换使用4辆车，碰到雨天不会停课，所以其实每个训练时段，<br>轮到每个人学习的时间不会太长。</p>
<p>建议不是经常骑车车感较好的朋友直接连续预约3天的训练，一气呵成预约考试，比较稳妥。<br>从2020年10月以后，北京摩托车考试从人工考试变为电子考试，考试过程摄像头和传感器数据连接市局，考试变严格了许多。</p>
<p>科目二的考场和考试项目如图：</p>
<p><img data-src="http://huifangshuyuan.com/img/moto_licence_test2.png" alt="科目二考场"></p>
<p>考场在海淀驾校10号楼旁边，摩托车考场在考北的位置，西面是科目二考场，东面是科目三考场。<br>科目二考场最西面是一个小坡。</p>
<p>科目二考试当天有2次机会，任何一次通过即可。科目二考试通过后可以直接去参加科目三的考试，科目三没有通过科目二也不需要重考。</p>
<p>科目二包含三个项目:</p>
<ul>
<li>坡道定点停车和起步</li>
<li>单边桥</li>
<li>绕桩</li>
</ul>
<p>需要说明的是，科目二考试全程无需打灯，具体流程可以如下：</p>
<ol start="0">
<li>戴头盔，挂档，启动，刷身份证，起步</li>
<li>行驶到坡道处，同时捏离合和前后刹车将车停稳，仅左脚点地(不限次数)，注意，前车轮中心落在黄线上，前后车轮距离右边线距离30cm内</li>
<li>脚刹狠狠踩住，松手刹，给油，半联动起步，松脚刹，车辆到达坡顶后完全松开离合</li>
<li>掉头，下坡，走单边桥</li>
<li>下单边桥后，不要加油，怠速行驶至绕桩处，找准切入点进行绕桩，注意不要撞杆，不要压黄线，不能脚点地</li>
<li>出绕桩区域，考试结束。</li>
</ol>
<p>从教练给的数据和实际感受来看，科目二失败基本都在绕桩部分。建议对平衡性掌握不好的朋友可以选择报三轮摩托车，<br>三轮摩托车速度很慢容易反应且不会出现脚点地问题，绕桩过程可以根据教练所说的标记打死，难度相对较低。</p>
<p>总结一下：</p>
<ol>
<li>坡道定点考核的其实是油门和离合的配合，重点在找半联动的感觉</li>
<li>单边桥最简单，保持身体放松，顺着车辙摆正车的位置，给点油就可以冲过去了</li>
<li>绕桩最难，需要考验车操作的灵活性和平衡性，总结的技巧就是一个字：慢。让车速慢下来，<br>你就有了足够的反应时间，可以根据具体情况做一些微调。<br>实际训练和考前教练会教你一些在什么地方转弯的技巧，这个你知道即可，主要还是靠自己的训练，找到适合自己的方式。<br>很多</li>
</ol>
<p>说一下绕桩时候的几个问题：</p>
<ol>
<li>心理畏惧。由于考场和训练场不一样，训练场的训练杆很低，而考场是5根很高的电子杆，显得空间很狭小，<br>很多人心理上本能都担心会撞杆，再加上考试本来心理紧张，就更容易出错了。</li>
<li>不敢转向。由于摩托车其实比较重，1档速度也比较慢，转向还是需要一些力气的，这样有人可能会发现，<br>自己朝左弯比较轻松，朝右弯比较困难，这是正常的。你可以将身体尽量坐的考前一点，双腿夹住邮箱，可以在平地入桩前多试试左右打轮的感觉。<br>习惯以后就会好多了。</li>
<li>速度过快。这里面强调在入桩考区域前较长一段距离都不要加油，甚至需要轻点刹车，将速度保持在较低水平。但是由于考场本身是一边高，一边低的，<br>即使不加油，你也会发现速度其实是在逐步加快的，可以轻点刹车，或者在入桩考区域前左右打轮几次，将速度降下来。</li>
</ol>
<h4 id="5-科目三考试"><a href="#5-科目三考试" class="headerlink" title="5. 科目三考试"></a>5. 科目三考试</h4><p>科目二靠训练，科目三靠记忆。科目三主要是模拟上数时候的考试，只要你记住了灯光，刹车，油离配合，起步，停车等技巧以后，其实不难。<br>具体看图：</p>
<p><img data-src="http://huifangshuyuan.com/img/moto_licence_test3.png" alt="科目三考场"></p>
<ol start="0">
<li>戴头盔，逆时针绕车。开车到起点，空档，关灯</li>
<li>刷身份证，左灯，1档，3s后起步</li>
<li>关灯，公交站牌10米内，刹车轻捏两次，左右摆头</li>
<li>人行横道10米内，刹车2次左右摆头</li>
<li>人行横道前左灯，向左看，过人行横道变道，关灯</li>
<li>掉头线上左灯，左摆头，刹车2次，掉头后关灯</li>
<li>走两步，右灯，3秒后变道，关灯</li>
<li>给油加速，捏离合换2档(1档时速不高于20，2档不低于5，走直线)</li>
<li>右灯，过停止线后前后刹同时用停车，停稳后立马关灯</li>
<li>挂空档，停车</li>
</ol>
<p>注意：其他车没有熄火停车时，你不能超车。考试时候可以自由掌握发车时间，不着急，多等等再起步。</p>
<p>整体来看，建议练习三次：</p>
<ol>
<li>第一次训练熟悉车和流程，搞定油门和离合配合的技巧，记住科目三的考试要点</li>
<li>第二次主攻科目二绕桩，做到基本达到考试标准</li>
<li>第三次保证绕桩达到90%以上的成功率(比如连续10次有9次以上成功，次数太少没有说服力)</li>
</ol>
<h4 id="6-约考、考前集训"><a href="#6-约考、考前集训" class="headerlink" title="6. 约考、考前集训"></a>6. 约考、考前集训</h4><p>绕桩能够保证90%以上的情况成功绕桩以后就可以约考了，可以电话约考或者在8号楼大厅现场约考。<br>约考前一天下午4：30到驾校参加集训。</p>
<p>注意约考的前置条件是提前一天在app上学完科目四, 也就是科目三理论考试的学时。切记！否则无法约考</p>
<p>集训是在正式考场，我集训的那天，居然有60多人去了，应该是有不少人不是第二天考试的也去现场集训了。</p>
<p>整整3个小时，我才绕了4次桩。幸亏平时基础功底扎实，考试一把过了。</p>
<h4 id="7-考试当天"><a href="#7-考试当天" class="headerlink" title="7. 考试当天"></a>7. 考试当天</h4><p>注意考前一天要在12123app上交完全部的考试费和工本费。</p>
<p>考试当天早上8点前到10号楼A区大厅等待，注意带上身份证、原驾照、3张白底一寸照片。</p>
<p>等待的过程中会有人让你穿上黄色的马甲，然后等待叫号。</p>
<p>考试是一拨人一拨人开始的，等着叫号排队，然后会有人带你走路到考试现场。</p>
<p>首先参加科目二的考试，考试有2次机会，科目二三个科目合计100分，80分及格。</p>
<p>科目二考试通过后，可以直接去旁边科目三考场，参加科目三的考试，科目三也考试通过后，自行回到侯考大厅，签字。</p>
<p>一般早上9点半左右就可以考完科目二和科目三了。</p>
<p>当天可以约考科目四，或者改天再考也OK。</p>
<p>我是选择直接当天约考。当天9点多考完科目三以后，我就直接去6号楼约考科目四了。可惜只能约考下午1:30的考试了。</p>
<p>中午可以在6号楼旁边的食堂吃一顿午饭，和学校食堂窗口类似，价格还可以。</p>
<p>科目四和科目一流程类似。科目四考完提交材料，然后就可以坐等制证啦。</p>
<p>大概下午3点半，终于拿到了我心爱的C1E本啦。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从开始报名到拿本，慢悠悠的学习，考试，前后经历了大概3个月，实际科目二训练开始到拿本大概2周即可。</p>
<p>着急的小伙伴，大约可以2周搞定。为了保证后续上路的安全，理论学习和实际训练自我感觉都练习的比较扎实，毕竟是性命攸关。</p>
<p>网上有很多人说可以3天甚至1天拿本，建议大家还是按正规驾校多学习多练习，其实整体时间也不长，但是相对来说，生命更加有保障。</p>
<p>最后，祝大家都能顺利拿本，有问题也可以在文末留言。后续有机会再分享买车上牌的流程。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>摩托车驾照 二轮摩托车 北京摩托车 海淀驾校</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客教程</title>
    <url>/2021/07/10/hexo-tutorial/</url>
    <content><![CDATA[<h1 id="hexo-next-为文章添加分类"><a href="#hexo-next-为文章添加分类" class="headerlink" title="hexo next 为文章添加分类"></a>hexo next 为文章添加分类</h1><h2 id="新建一个页面，命名为-categories-。命令如下："><a href="#新建一个页面，命名为-categories-。命令如下：" class="headerlink" title="新建一个页面，命名为 categories 。命令如下："></a>新建一个页面，命名为 categories 。命令如下：</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">page</span> categories</span><br></pre></td></tr></table></figure>

<h2 id="编辑刚新建的页面，将页面的类型设置为-categories-，主题将自动为这个页面显示所有分类"><a href="#编辑刚新建的页面，将页面的类型设置为-categories-，主题将自动为这个页面显示所有分类" class="headerlink" title="编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类"></a>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类</h2><p>可选是否关闭评论</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">title</span>: 分类</span><br><span class="line"><span class="attribute">date</span>: <span class="number">2014</span>-<span class="number">12</span>-<span class="number">22</span> <span class="number">12</span>:<span class="number">39</span>:<span class="number">04</span></span><br><span class="line"><span class="attribute">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attribute">comments</span>: false</span><br></pre></td></tr></table></figure>
<span id="more"></span> 


<h2 id="在菜单中添加链接。编辑主题的-config-yml-，将-menu-中的-categories-categories-注释去掉，如下"><a href="#在菜单中添加链接。编辑主题的-config-yml-，将-menu-中的-categories-categories-注释去掉，如下" class="headerlink" title="在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:"></a>在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure>

<h2 id="在其中添加categories属性，再部署之后就可以在分类页看到分类了"><a href="#在其中添加categories属性，再部署之后就可以在分类页看到分类了" class="headerlink" title="在其中添加categories属性，再部署之后就可以在分类页看到分类了"></a>在其中添加categories属性，再部署之后就可以在分类页看到分类了</h2><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2016<span class="string">-03</span><span class="string">-16</span> 08:12:43</span><br><span class="line"><span class="keyword">tags:</span></span><br><span class="line">categories: tech</span><br></pre></td></tr></table></figure>

<p>更多可以参考Hexo官方<a href="https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE">教程</a></p>
<h1 id="hexo文章折叠"><a href="#hexo文章折叠" class="headerlink" title="hexo文章折叠"></a>hexo文章折叠</h1><p>使用以下标签，之后的文章都会被折叠</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span> </span><br></pre></td></tr></table></figure>

<h1 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h1><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p>
<p>在 Google 的 Search Console 的 抓取-&gt;站点地图 有为你的站点添加站点地图的选项。在此处添加了站点地图文件地址后，你的站点就能够充分地展示在 google 搜索引擎使用者的眼前。</p>
<h2 id="在-Hexo-根目录下，执行如下命令以安装插件"><a href="#在-Hexo-根目录下，执行如下命令以安装插件" class="headerlink" title="在 Hexo 根目录下，执行如下命令以安装插件"></a>在 Hexo 根目录下，执行如下命令以安装插件</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google版本</span></span><br><span class="line">npm <span class="keyword">install </span>hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu 版本</span></span><br><span class="line">npm <span class="keyword">install </span>hexo-generator-<span class="keyword">baidu-sitemap </span>--save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="生成站点地图文件"><a href="#生成站点地图文件" class="headerlink" title="生成站点地图文件"></a>生成站点地图文件</h2><p>安装好插件后，插件会在每次 hexo g 命令将 markdown 文件转化为 html 文件时执行</p>
<p>执行结果为，在存放 html 文件根目录下，即 blog/public 下生成一 ‘sitemap.xml’/‘baidusitemap.xml’</p>
<h2 id="添加站点地图-url"><a href="#添加站点地图-url" class="headerlink" title="添加站点地图 url"></a>添加站点地图 url</h2><p>最后，你只需将该站点地图文件的 url 添加至搜索引擎的 search console</p>
<h1 id="使用-LocalSearch-搜索功能"><a href="#使用-LocalSearch-搜索功能" class="headerlink" title="使用 LocalSearch 搜索功能"></a>使用 LocalSearch 搜索功能</h1><h2 id="安装搜索插件"><a href="#安装搜索插件" class="headerlink" title="安装搜索插件"></a>安装搜索插件</h2><p>博客根目录执行以下命令</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<h1 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h1><p>安装完成，编辑博客配置文件：_config.yml</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>Next 主题自带搜索设置，编辑主题配置文件：_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="开启字数统计及阅读时长预估"><a href="#开启字数统计及阅读时长预估" class="headerlink" title="开启字数统计及阅读时长预估"></a>开启字数统计及阅读时长预估</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>博客根目录执行以下命令</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-<span class="built_in">count</span>-<span class="built_in">time</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<h1 id="配置博客-1"><a href="#配置博客-1" class="headerlink" title="配置博客"></a>配置博客</h1><p>安装完成，编辑博客配置文件：_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment"># 阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span> <span class="comment"># 所有文章总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment"># 所有文章阅读中时长</span></span><br></pre></td></tr></table></figure>
<p>编辑Next主题配置文件：_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># 是否换行显示 字数统计 及 阅读时长</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 文章 字数统计 阅读时长 使用图标 还是 文本表示</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示</span></span><br></pre></td></tr></table></figure>

<h1 id="指定文章置项"><a href="#指定文章置项" class="headerlink" title="指定文章置项"></a>指定文章置项</h1><p>Hexo Next主题中，首页文章默认排序方式是按照时间逆序来排的，越新的文章排在越前面。当我们想让访客一进来就能看到推荐的文章时，可以将这些文章置顶。</p>
<h2 id="1-卸载原插件和安装置顶插件"><a href="#1-卸载原插件和安装置顶插件" class="headerlink" title="1 卸载原插件和安装置顶插件"></a>1 卸载原插件和安装置顶插件</h2><p>执行下面两行命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<h2 id="2-在新增文章的开头中加入top-true，比如："><a href="#2-在新增文章的开头中加入top-true，比如：" class="headerlink" title="2. 在新增文章的开头中加入top: true，比如："></a>2. 在新增文章的开头中加入top: true，比如：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title: Hexo Next主题设置文章置顶</span><br><span class="line"><span class="built_in">id</span>: <span class="number">1</span></span><br><span class="line">date: <span class="number">2022</span>-04-04 <span class="number">17</span>:<span class="number">26</span>:01</span><br><span class="line">categories: Hexo</span><br><span class="line">tags: Next主题</span><br><span class="line">top: true</span><br></pre></td></tr></table></figure>

<h2 id="3-设置置顶标志"><a href="#3-设置置顶标志" class="headerlink" title="3 设置置顶标志"></a>3 设置置顶标志</h2><p>打开<strong>\themes\your theme\layout_macro\post.swig</strong><br>找到<div class="post-meta">下面插入一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> post.top %&#125;</span><br><span class="line">    &lt;i <span class="class"><span class="keyword">class</span>=&quot;<span class="title">fa</span> <span class="title">fa</span>-<span class="title">thumb</span>-<span class="title">tack</span>&quot;&gt;&lt;/<span class="title">i</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">font</span> <span class="title">color</span>=&quot;<span class="title">RED</span>&quot;&gt;置顶&lt;/<span class="title">font</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">span</span> <span class="title">class</span>=&quot;<span class="title">post</span>-<span class="title">meta</span>-<span class="title">divider</span>&quot;&gt;|&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&#123;% <span class="title">endif</span> %&#125;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<p>至此，功能已完成。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2编码问题分析</title>
    <url>/2017/11/24/python2-encode-and-decode-problem/</url>
    <content><![CDATA[<p>Python2编码问题</p>
<p>python2的字符串有两种：str和unicode</p>
<span id="more"></span> 


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.10</span> (default, Aug <span class="number">22</span> <span class="number">2015</span>, <span class="number">20</span>:<span class="number">33</span>:<span class="number">39</span>)</span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> Compatible Apple LLVM <span class="number">7.0</span><span class="number">.0</span> (clang-<span class="number">700.0</span><span class="number">.59</span><span class="number">.1</span>)] on darwin</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br><span class="line"><span class="string">&#x27;ascii&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">u&#x27;百度&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;unicode&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a</span><br><span class="line">百度</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">u&#x27;\u767e\u5ea6&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">u&#x27;\u767e\u5ea6&#x27;</span></span><br><span class="line">百度</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa = a.encode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa</span><br><span class="line"><span class="string">&#x27;\\u767e\\u5ea6&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> aa</span><br><span class="line">\u767e\u5ea6</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">len</span>(aa)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> b.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>unicode在python里以一种编码无关的方式存储，存储的是code point, 如中文**u’百度’<strong>的编码就是</strong>u’\u767e\u5ea6’**。</p>
<p>如果字符串是str,代表一定采用了某种编码，如utf8，这个时候存储的是字节。当然，也可以使用<strong>unicode_escape</strong>对unicode进行编码，aa字符数为12个，此时aa可以写入文件。对于str类型的字符串  len求的的就是字节数。只是对utf16这种定长编码来说，每个字符占用2个字节，编码后unicode字符串变成str字符串，这时候会加一个大端小端标记（2字节），这是不可见字符。如’’\xff\xfe’’</p>
<p>问题：对于unicode字符串，在内存里存储时，占用几个字节？</p>
<p>Python 2 and Python 3.0-3.2 use either UCS2* or UCS4 for unicode characters, meaning it’ll either use 2 bytes or 4 bytes for <em>each character</em>. Which one is picked is a compile-time option.</p>
<p><code>\u2049</code> is then represented as either <code>\x49\x20</code> or <code>\x20\x49</code> or <code>\x49\x20\x00\x00</code> or <code>\x00\x00\x20\x49</code> depending on the native byte order of your system and if UCS2 or UCS4 was picked. ASCII characters in a unicode string still use 2 or 4 bytes per character too.</p>
<p>Python 3.3 switched to a new internal representation, using the most compact form needed to represent all characters in a string. Either 1 byte, 2 bytes or 4 bytes are picked. ASCII and Latin-1 text uses just 1 byte per character, the rest of the BMP characters require 2 bytes and after that 4 bytes is used.</p>
<h1 id="json-dumps和json-loads"><a href="#json-dumps和json-loads" class="headerlink" title="json dumps和json loads"></a>json dumps和json loads</h1><p>json.dumps将python数据转换为json。loads相反。对应的还可以使用json.dump和load处理文件。</p>
<p>json.dumps得到的json数据基本和python原始的数据一致，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>baidu = <span class="string">&#x27;百度&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>baidu</span><br><span class="line"><span class="string">&#x27;\xe7\x99\xbe\xe5\xba\xa6&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(baidu)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>baidu.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="string">u&#x27;\u767e\u5ea6&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(baidu.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = json.dumps(baidu)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;&quot;\\u767e\\u5ea6&quot;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a</span><br><span class="line"><span class="string">&quot;\u767e\u5ea6&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(a)</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[e <span class="keyword">for</span> e <span class="keyword">in</span> a]</span><br><span class="line">[<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>at = json.dumps(baidu, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>at</span><br><span class="line"><span class="string">&#x27;&quot;\xe7\x99\xbe\xe5\xba\xa6&quot;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> at</span><br><span class="line"><span class="string">&quot;百度&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>at.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="string">u&#x27;&quot;\u767e\u5ea6&quot;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(at)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[e <span class="keyword">for</span> e <span class="keyword">in</span> at]</span><br><span class="line">[<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;\xe7&#x27;</span>, <span class="string">&#x27;\x99&#x27;</span>, <span class="string">&#x27;\xbe&#x27;</span>, <span class="string">&#x27;\xe5&#x27;</span>, <span class="string">&#x27;\xba&#x27;</span>, <span class="string">&#x27;\xa6&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>json.dumps 序列化python数据时对中文默认使用的ascii编码。此时，发现a占用14个字节，存储的是code point组成部份的单个字节。</p>
<p>加<strong>ensure_ascii=False</strong>选项后，会选择默认的中文编码，我这里是utf8。</p>
<h1 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h1><p>python2即将在2020年停止维护，但就目前的趋势看，谁说得定呢，不过python3确实有许多比较好的特性，值得花时间看看</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Cracking-the-Coding-Interview</title>
    <url>/2016/08/24/Cracking-the-coding-interview/</url>
    <content><![CDATA[<h1 id="Cracking-The-Coding-Interview"><a href="#Cracking-The-Coding-Interview" class="headerlink" title="Cracking The Coding Interview"></a>Cracking The Coding Interview</h1><h2 id="1-Foreword"><a href="#1-Foreword" class="headerlink" title="1.Foreword"></a>1.Foreword</h2><p>As you get ready for your interviews, consider these suggestions:</p>
<ul>
<li>  Write Code on Paper</li>
<li>  Know Your Resume</li>
<li>  Don’t Memorize Solutions</li>
<li>  Talk Out Loud</li>
</ul>
<p>Receiving an offer is not about solving questions flawlessly (very few candidates do!), but rather, <strong>it is about answering questions better than other candidates.</strong> So don’t stress out when you get a tricky question - everyone else probably thought it was hard too!</p>
<h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2.Introduction"></a>2.Introduction</h2><h2 id="3-Behind-the-Scenes"><a href="#3-Behind-the-Scenes" class="headerlink" title="3.Behind the Scenes"></a>3.Behind the Scenes</h2><h3 id="3-1-The-Microsoft-Interview"><a href="#3-1-The-Microsoft-Interview" class="headerlink" title="3.1 The Microsoft Interview"></a>3.1 The Microsoft Interview</h3><span id="more"></span> 


<ul>
<li>  Microsoft wants smart people Geeks. People who are passionate about technology.</li>
<li>  You’ll have a short interview with a recruiter where he or she will give you a sample question. Your recruiter is usually there to prep you, and not to grill you on techni- cal questions. Be nice to your recruiter. Your recruiter can be your biggest advocate, even pushing to re-interview you if you stumbled on your first interview. They can fight for you to be hired - or not!</li>
<li>  During the day, you’ll do four or five interviews, often with two different teams Unlike many companies.</li>
<li>  Depending on the team, interviewers may or may not share their feedback on you with the rest of the interview loop.</li>
<li>  When you complete your interviews with a team, you might speak with a hiring manager. If so, that’s a great sign! It likely means that you passed the interviews with a particular team. It’s now down to the hiring manager’s decision.</li>
<li>  You might get a decision that day, or it might be a week. After one week of no word from HR, send them a friendly email asking for a status update.</li>
</ul>
<p>Definitely Prepare: <strong>“Why do you want to work for Microsoft?”</strong></p>
<p>In this question, Microsoft wants to see that you’re passionate about technology. A great answer might be, “I’ve been using Microsoft software as long as I can re- member, and I’m really impressed at how Microsoft manages to create a product that is universally excellent. For example, I’ve been using Visual Studio recently to learn game programming, and it’s APIs are excellent.” Note how this shows a passion for technology!</p>
<h3 id="3-2-The-Amazon-Interview"><a href="#3-2-The-Amazon-Interview" class="headerlink" title="3.2 The Amazon Interview"></a>3.2 The Amazon Interview</h3><ul>
<li>  Amazon’s recruiting process usually begins with one or two phone screens in which you in- terview with a specific team. The engineer who interviews you will usually ask you to write simple code and read it aloud on the phone They will ask a broad set of questions to explore what areas of technology you’re familiar with.</li>
<li>  Next, you fly to Seattle for four or five interviews with one or two teams which have selected you based on your resume and phone interviews. You will have to code on a whiteboard, and some interviewers will stress other skills. Interviewers are each assigned a specific area to probe and may seem very different from each other.</li>
<li>  They can not see other feedback until they have submitted their own and they are discouraged from discussing it until the hiring meeting.</li>
<li>  Amazon’s “bar raiser” interviewer is charged with keeping the interview bar high. If one interview seems significantly harder and different, that’s most like- ly the bar raiser This person has both significant experience with interviews and veto power in the hiring decision.</li>
<li>  While Amazon’s recruiters are excellent at following up with candidates, occa- sionally there are delays. If you haven’t heard from Amazon within a week, we recommend a friendly email.</li>
</ul>
<p>Definitely Prepare:</p>
<ul>
<li>  Amazon is a web-based company, and that means they care about scale. Make sure you prepare for questions in “Large Scale.” You don’t need a background in distributed systems to answer these questions. See our recommendations in the System Design and Memory Limits Chapter.</li>
<li>  Additionally, Amazon tends to ask a lot of questions about object oriented design. Check out the Object Oriented Design chapter for sample questions and suggestions.</li>
</ul>
<h3 id="3-3-The-Google-Interview"><a href="#3-3-The-Google-Interview" class="headerlink" title="3.3 The Google Interview"></a>3.3 The Google Interview</h3><ul>
<li>  However, because Google HR can be a little disorganized, we recommend being proactive in com- munication.</li>
<li>  A Google engineer performs the first phone screen, so expect tough technical questions.</li>
<li>  On your on-site interview, you’ll interview with four to six people, one of whom will be a lunch interviewer. Interviewer feedback is kept confidential from the other interviewers, so you can be assured that you enter each interview with blank slate. Your lunch interviewer doesn’t submit feedback, so this is a great opportunity to ask honest questions.</li>
<li>  Written feedback is submitted to a hiring committee of engineers to make a hire/no-hire recommendation. Feedback is typically broken down into four categories (Analytical Ability, Coding, Experience and Communication) and you are given a score from 1.0 to 4.0 overall.</li>
<li>  The hiring committee understands that you can’t be expected to excel in every interview, but if multiple people raise the same red flag (arrogance, poor coding skills, etc), that can disqualify you. A hiring committee typically wants to see one interviewer who is an “enthusiastic en- dorser”. In other words, a packet with scores of 3.6, 3.1, 3.1 and 2.6 is better than all 3.1s. Your phone screen is usu- ally not a strong factor in the final deci- sion.</li>
<li>  The Google hiring process can be slow. If you don’t hear back within one week, politely ask your recruiter for an up- date. A lack of response says nothing about your performance.</li>
</ul>
<p>Definitely Prepare:</p>
<ul>
<li>  As a web-based company, Google cares about how to design a scalable system. So, make sure you prepare for questions from “System Design and Memory Limits” Additionally, many Google interviewers will ask questions involving Bit Manipulation, so please brush up on these questions.</li>
</ul>
<h3 id="3-4-The-Apple-Interview"><a href="#3-4-The-Apple-Interview" class="headerlink" title="3.4 The Apple Interview"></a>3.4 The Apple Interview</h3><ul>
<li>  Much like the company itself, Apple’s interview process has minimal beaucracy.</li>
<li>  The interviewers will be looking for excellent technical skills, but a passion for the position and company is also very important. While it’s not a prerequisite to be a Mac user, you should at least be familiar with the system.</li>
<li>  The interview process typically begins with a recruiter phone screen to get a basic sense of your skills, <strong>followed up by a series of technical phone screens with team members.</strong></li>
<li>  Once you’re invited on campus, you’ll typically be greeted by the recruiter who provides an overview of the process. You will then have 6-8 interviews with members of the team for which you’re interviewing, as well as key people with whom your team works.</li>
<li>  You can expect a mix of 1-on-1 and 2-on-1 interviews. Be ready to code on a whiteboard and make sure all of your thoughts are clearly communicated. Lunch is with your potential future manager and appears more casual, but is still an interview. Each interviewer is usually focused on a different area and is discouraged from sharing feedback unless there’s something they want subsequent interviewers to drill into.</li>
<li>  Towards the end of the day, your interviewers will compare notes and if everyone still feels you’re a viable candidate, you’ll interview with the director and then VP of the organization you’re applying to. While this decision is rather informal, it’s a very good sign if you make it. This decision also happens behind the scenes and if you don’t pass, you’ll simply be escorted out of the building without ever having been the wiser (until now)</li>
<li>  If you made it to the director and VP interviews, all of your interviewers will gather in a conference room to give an official thumbs up or thumbs down The VP typically won’t be present, but can still veto the hire if they weren’t im- pressed.</li>
<li>  Your recruiter will usually follow up a few days later, but feel free to ping your recruiter for updates.</li>
</ul>
<p>Definitely Prepare:</p>
<ul>
<li>  If you know what team you’re interviewing with, make sure you read up on that product. What do you like about it? What would you improve? Offering specific recommendations can show your passion for the job.</li>
<li>  Also, Apple employees are huge Apple fans. You should show this same passion in your interview.</li>
</ul>
<h3 id="3-5-The-Yahoo-Interview"><a href="#3-5-The-Yahoo-Interview" class="headerlink" title="3.5 The Yahoo Interview"></a>3.5 The Yahoo Interview</h3><ul>
<li><p>  While Yahoo tends to only recruit at the top 10 – 20 schools, other candidates can still get interviewed through Yahoo’s job board (or – better yet – if they can get an internal referral). If you’re one of the lucky ones selected, your interview process will start off with a phone screen. Your phone screen will be with a senior employee (tech lead, manager, etc)</p>
</li>
<li><p>You will typically interview with 6 – 7 people on the same team for 45 minutes each Each interviewer will have an area of focus. Interviews will often be composed as follows:</p>
<ul>
<li>  5 minutes: General conversation Tell me about yourself, your projects, etc</li>
<li>  20 minutes: Coding question For example, implement merge sort</li>
<li>  20 minutes: System design For example, design a large distributed cache These ques- tions will often focus on an area from your past experience or on something your interviewer is currently working on</li>
</ul>
</li>
<li><p>  At the end of the day, you will likely meet with a Program Manag- er or someone else for a general con- versation (product demos, concerns about the company, your competing offers, etc). Meanwhile, your interview- ers will discuss your performance and attempt to come to a decision The hiring manager has the ultimate say and will weigh the positive feedback against the negative.</p>
</li>
<li><p>  If you have done well, you will often get a decision that day, but this is not always the case. There can be many reasons that you might not be told for several days – for example, the team may feel it needs to interview several other people.</p>
</li>
</ul>
<p>Definitely Prepare:</p>
<ul>
<li>  Yahoo, almost as a rule, asks questions about system design, so make sure you prepare for that. They want to know that you can not only write code, but that you can design software. Don’t worry if you don’t have a background in this - you can still reason your way through it!</li>
</ul>
<h2 id="4-Before-the-Interview"><a href="#4-Before-the-Interview" class="headerlink" title="4. Before the Interview"></a>4. Before the Interview</h2><h3 id="4-1-Resume-Advice"><a href="#4-1-Resume-Advice" class="headerlink" title="4.1 Resume Advice"></a>4.1 Resume Advice</h3><p>Resume screeners look for the same things that interviewers do:</p>
<ul>
<li>  <strong>Are you smart?</strong></li>
<li>  <strong>Can you code?</strong></li>
</ul>
<p>That means that you should present your resume to show those two things. Your love of tennis, traveling, or magic cards won’t do much to show that, so it’s likely just wasting space.Keep in mind that recruiters only spend a fixed amount of time (about 20 seconds) looking at your resume. If you limit the content to the best, most impressive, most relevant items, they’ll jump out at the recruiter Weak items only dilute your resume and distract the recruiter from what you’d like them to see.</p>
<hr>
<p><strong>Writing Strong Bullets:</strong></p>
<ul>
<li>  For each role, try to discuss your accomplishments with the following approach: “Accom- plished X by implementing Y which led to Z” Here’s an example:</li>
<li>  “Reduced object rendering time by 75% by applying Floyd’s algorithm, leading to a 10% reduction in system boot time”</li>
<li>  “Increased average match accuracy from 1.2 to 1.5 by implementing a new comparison algorithm based on windiff”</li>
</ul>
<p>Not everything you did will fit into this approach, but the principle is the same: show what you did, how you did it, and what the results were Ideally, you should try to make the results “measurable” somehow.</p>
<hr>
<p><strong>Advice for Non-Native English Speakers and Internationals:</strong></p>
<ul>
<li>  Proofreading: Some companies will throw out your resume just because of a typo. Please get at least one native English speaker to proofread your resume.</li>
<li>  Personal Information: For US positions, do not include age, marital status, or nationality. This sort of personal information is not appreciated by companies, as it creates a legal liability for them However, you may want to include your current work authorization / visa status, particularly when applying to smaller companies who may be unable to sponsor candidates.</li>
</ul>
<h3 id="4-2-Behavioral-Preparation"><a href="#4-2-Behavioral-Preparation" class="headerlink" title="4.2 Behavioral Preparation"></a>4.2 Behavioral Preparation</h3><p>Behavioral questions are asked for a variety of reasons </p>
<ul>
<li>  They can be asked either to get to know your personality,</li>
<li>  to more deeply understand your resume,</li>
<li>  or just to ease you into an interview Either way,</li>
</ul>
<p>these questions are important and can be prepared for.</p>
<p>Behavioral questions are usually of the form “tell me about a time when you ”, and may ask for an example from a specific project or position. I recommend filling in the following “preparation grid” as shown below:</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left">

<col class="org-left">

<col class="org-left">

<col class="org-left">

<col class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&nbsp;</th>
<th scope="col" class="org-left">Project1</th>
<th scope="col" class="org-left">Project2</th>
<th scope="col" class="org-left">Project3</th>
<th scope="col" class="org-left">Project4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Most Challenging</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>

<tr>
<td class="org-left">What You Learned</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>

<tr>
<td class="org-left">Most Interesting</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>

<tr>
<td class="org-left">Hardest Bug</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>

<tr>
<td class="org-left">Enjoyed Most</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>

<tr>
<td class="org-left">Conflicts with Teammates</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>
</tbody>
</table> 
 
 
 
 
 

<p>In each cell, put the corresponding story. We recommend reducing each story to just a couple keywords that you can write in each cell This will make the grid easier to study  </p>
<hr>
<p><strong>What questions should you ask the interviewer?</strong></p>
<ul>
<li><p>Genuine Questions: These are the questions you actually want to know ideas of questions that are valuable to many candidates:</p>
<ul>
<li>  “How much of your day do you spend coding?”</li>
<li>  “How many meetings do you have every week?”</li>
<li>  “What is the ratio of testers to developers to product managers? What is the interac- tion like? How does project planning happen on the team?”</li>
</ul>
</li>
<li><p>Insightful Questions: These questions are designed to demonstrate your deep knowledge of programming or technologies.</p>
<ul>
<li>  “I noticed that you use technology X How do you handle problem Y?”</li>
<li>  “Why did the product choose to use the X protocol over the Y protocol? I know it has benefits like A, B, C, but many companies choose not to use it because of issue D”</li>
</ul>
</li>
<li><p>Passion Questions: These questions are designed to demonstrate your passion for technol- ogy.</p>
<ul>
<li>  “I’m very interested in scalability Did you come in with a background in this, or what opportunities are there to learn about it?”</li>
<li>  “I’m not familiar with technology X, but it sounds like a very interesting solution Could you tell me a bit more about how it works?”</li>
</ul>
</li>
</ul>
<h3 id="4-3-Technical-Preparation"><a href="#4-3-Technical-Preparation" class="headerlink" title="4.3 Technical Preparation"></a>4.3 Technical Preparation</h3><ul>
<li>  Memorizing or trying to learn specific questions won’t help you!</li>
<li>  Try to solve the problem on your own.</li>
<li>  Write the code for the algorithm on paper.</li>
<li>  Type your paper code as-is into a computer.</li>
<li>  Do a mock interview. CareerCup offers a mock interview (这里也可以是找一些小公司面试，边面试边学习边改进)</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col class="org-left">

<col class="org-left">

<col class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Data Structures</th>
<th scope="col" class="org-left">Algorithms</th>
<th scope="col" class="org-left">Concepts</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Linked Lists</td>
<td class="org-left">Breadth First Search</td>
<td class="org-left">Bit Manipulation</td>
</tr>

<tr>
<td class="org-left">Binary Trees</td>
<td class="org-left">Depth First Search</td>
<td class="org-left">Singleton Design Pattern</td>
</tr>

<tr>
<td class="org-left">Tries</td>
<td class="org-left">Binary Search</td>
<td class="org-left">Factory Design Pattern</td>
</tr>

<tr>
<td class="org-left">Stacks</td>
<td class="org-left">Merge Sort</td>
<td class="org-left">Memory (Stack vs Heap)</td>
</tr>

<tr>
<td class="org-left">Queues</td>
<td class="org-left">Quick Sort</td>
<td class="org-left">Recursion</td>
</tr>

<tr>
<td class="org-left">Vectors / ArrayLists</td>
<td class="org-left">Tree Insert / Find / etc</td>
<td class="org-left">Big-O Time</td>
</tr>

<tr>
<td class="org-left">Hash Tables</td>
<td class="org-left">&nbsp;</td>
<td class="org-left">&nbsp;</td>
</tr>
</tbody>
</table>

<h2 id="5-The-Interview-and-Beyond"><a href="#5-The-Interview-and-Beyond" class="headerlink" title="5. The Interview and Beyond"></a>5. The Interview and Beyond</h2><h3 id="5-1-Handling-Behavioral-Questions"><a href="#5-1-Handling-Behavioral-Questions" class="headerlink" title="5.1 Handling Behavioral Questions"></a>5.1 Handling Behavioral Questions</h3><ul>
<li>  Be Specific, Not Arrogant</li>
<li>  Limit Details（这个应该怎么理解呢？详略得到的描述行为问题，其实任何事物的描述都应该这样吧）</li>
<li>  Ask Good Questions</li>
<li>  Structure Answers Using S.A.R(Situation, Action, Response)</li>
</ul>
<h3 id="5-2-Handling-Technical-Questions"><a href="#5-2-Handling-Technical-Questions" class="headerlink" title="5.2 Handling Technical Questions"></a>5.2 Handling Technical Questions</h3><p>A technical interview question can be solved utilizing a five step approach:</p>
<ol>
<li> Ask your interviewer questions to resolve ambiguity</li>
<li> Design an Algorithm</li>
<li> Write pseudo-code first, but make sure to tell your interviewer that you’re writing pseudo-code! Otherwise, he/she may think that you’re never planning to write “real” code, and many interviewers will hold that against you</li>
<li> Write your code, not too slow and not too fast</li>
<li> Test your code and carefully fix any mistakes<br>（感觉五步可以总结为三个步骤：消除歧义确定具体要解决的问题，设计算法伪代码实现从而确认问题和解决方案的正确可行，规定时间内编写实际代码并做到bug free且有良好的风格。在面试的过程中，注意与面试官保持沟通，就像和同学老师讨论问题那样，给予一定尊重，并体现你思考的过程和思路，注意逻辑一定要清楚，想好了再说，确认好了再写，一边写一边讲解）</li>
</ol>
<h3 id="5-3-Five-Algorithm-Approaches"><a href="#5-3-Five-Algorithm-Approaches" class="headerlink" title="5.3 Five Algorithm Approaches"></a>5.3 Five Algorithm Approaches</h3><h3 id="5-4-The-Offer-and-Beyond"><a href="#5-4-The-Offer-and-Beyond" class="headerlink" title="5.4 The Offer and Beyond"></a>5.4 The Offer and Beyond</h3><ul>
<li><p>  <strong>Negotiating.</strong> It’s Always Negotiable! Ok, maybe not always, but usually an offer is negotiable even if a recruiter tells you otherwise. It helps if you have a competing offer But, <strong>don’t lie – Microsoft knows what Google offers, so it just won’t be realistic if you make up numbers.</strong> Also, technology is a small world, and people talk. Be honest.</p>
</li>
<li><p>  <strong>What’s the money like, really?</strong> Think about the full offer package Many companies will have impressive salaries, but small annual bonuses Other companies will have huge annual bonuses, but lower salaries Make sure you look at the <strong>full package (salary, signing bonus, health care benefits, raises, annual bonus, relocation, stock, promotions, etc)</strong> It’s very confusing, and it’s often not clear which company is offering more</p>
</li>
<li><p><strong>What about your career options?</strong> I can’t give you some magical formula to compute which offer to accept, but here’s what I’d recommend thinking about (in no particular order):</p>
<ul>
<li>  Career Path: Make a plan for your career What do you want to do 5, 10 and 15 years out? What skills will you need to develop? Which company or position will help you get there?</li>
<li>  Promotion Opportunity: Do you prefer to move into management, or would you prefer to become an increasingly senior developer?</li>
<li>  Money and Benefits: Of course, the money matters (but if you’re early in your career, it probably doesn’t matter much). As mentioned above, make sure you look at the full package.</li>
<li>  Happiness: Did you like the people? The products? The location? It’s hard to tell, of course, before you work there. What are the options to change teams if you’re unhappy?</li>
<li>  Brand Name: The company’s brand name can mean a lot for your future career Some company names will open doors, while others will not as much.</li>
<li>  <strong>What about company stability? Personally, I think it matters much less than most people think. There are so many software companies out there. If you get laid off and need to find a new job, will it be difficult to find a new one? Only you can answer that.</strong></li>
</ul>
</li>
</ul>
<h3 id="5-5-Top-Ten-Mistakes-Candidates-Make"><a href="#5-5-Top-Ten-Mistakes-Candidates-Make" class="headerlink" title="5.5 Top Ten Mistakes Candidates Make"></a>5.5 Top Ten Mistakes Candidates Make</h3><ul>
<li>  Practicing on a Computer</li>
<li>  Not Rehearsing Behavioral Questions</li>
<li>  Not Doing a Mock Interview</li>
<li>  Trying to Memorize Solutions</li>
<li>  Talking Too Much</li>
<li>  Talking Too Little</li>
<li>  Rushing</li>
<li>  Not Debugging</li>
<li>  Sloppy Coding</li>
<li>  Giving Up</li>
</ul>
<h3 id="5-6-Frequently-Asked-Questions"><a href="#5-6-Frequently-Asked-Questions" class="headerlink" title="5.6 Frequently Asked Questions"></a>5.6 Frequently Asked Questions</h3><p><strong>Should I tell my interviewer if I know a question?</strong></p>
<p>Yes! You should definitely tell your interviewer if you’ve previously heard the question This seems silly to some people - if you already know the question (and answer), you could ace the question, right? Not quite</p>
<p>Here’s why we strongly recommend that you tell your interviewer that you’ve heard the question:</p>
<ol>
<li> Big honesty points. This shows a lot of integrity That’s huge. Remember that the interviewer is evaluating you as a potential teammate I don’t know about you, but I personally prefer to work with honest people!</li>
<li> The question might have changed ever-so-slightly. You don’t want to risk repeating the wrong answer</li>
<li> If you easily belt out the right answer, it’s obvious to the interviewer. They know how hard a problem is supposed to be. It’s very hard to “pretend” to struggle through a question, because you just can’t approach it the same way other candidates do.</li>
</ol>
<h2 id="6-Interview-Questions"><a href="#6-Interview-Questions" class="headerlink" title="6 Interview Questions"></a>6 Interview Questions</h2><ul>
<li>  Data Structures</li>
<li>  Concepts and Algorithms</li>
<li>  Knowledge Based</li>
<li>  Additional Review Problems</li>
</ul>
<h3 id="6-1-Arrays-and-Strings"><a href="#6-1-Arrays-and-Strings" class="headerlink" title="6.1 Arrays and Strings"></a>6.1 Arrays and Strings</h3><ul>
<li><p>1.1 Implement an algorithm to determine if a string has all unique characters. What if you can not use additional data structures?<br>  使用C＋＋的map，一趟扫描即可。</p>
<p>  如果字符串里面全部是a-z的字符，用一个大小为26的数组也可以。</p>
<p>  如果不能用数组，不能用map等数据结构，那就按照ASCII排序，看有没有重复的字符，一趟扫描。</p>
</li>
<li><p>1.2 Write code to reverse a C-Style String. (C-String means that “abcd” is represented as five characters, including the null character.)<br>  两个指针一个0开始加，一个strlen（）－1 开始减？</p>
</li>
</ul>
<ul>
<li><p>1.3 Design an algorithm and write code to remove the duplicate characters in a string without using any additional buffer.<br>  先排序。然后两个指针，指针index初始化为－1，i为0，用i往后扫描，index记录unique字符的个数，一趟扫描即可。</p>
</li>
<li><p>1.4 Write a method to decide if two strings are anagrams or not.<br>  C＋＋的map，value存储个数，一个string加，一个string减，判断最后value是否为0</p>
</li>
<li><p>1.5 Write a method to replace all spaces in a string with ‘%20’.<br>  难点在哪？</p>
</li>
<li><p> 1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees Can you do this in place?</p>
</li>
<li><p>1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column is set to 0.<br>  难点在哪？</p>
</li>
<li><p>1.8 Assume you have a method isSubstring which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring (i e , “waterbottle” is a rotation of “erbottlewat”).<br>  reverse(s1.begin(),s2.end())然后调用isSubstring进行判断</p>
</li>
</ul>
<hr>
<p>1.6</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> m[<span class="built_in">N</span>][<span class="built_in">N</span>];</span><br><span class="line">for(<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">N</span>/<span class="number">2</span>;k++) &#123;</span><br><span class="line">  <span class="built_in">int</span> r = k;</span><br><span class="line">  <span class="built_in">int</span> last = <span class="built_in">n</span> - <span class="number">1</span> - r;</span><br><span class="line">  for(<span class="built_in">int</span> c = r; c &lt;= last; c++) &#123;</span><br><span class="line">    // [r,c], [<span class="built_in">N</span>-<span class="number">1</span>-c,r], [<span class="built_in">N</span>-<span class="number">1</span>-r,<span class="built_in">N</span>-<span class="number">1</span>-c], [c,<span class="built_in">N</span>-<span class="number">1</span>-r]</span><br><span class="line">    <span class="built_in">int</span> tmp = m[r][c];</span><br><span class="line">    m[r][c] = m[c][<span class="built_in">N</span>-<span class="number">1</span>-r];</span><br><span class="line">    m[c][<span class="built_in">N</span>-<span class="number">1</span>-r] = m[<span class="built_in">N</span>-<span class="number">1</span>-r][<span class="built_in">N</span>-<span class="number">1</span>-c];</span><br><span class="line">    m[<span class="built_in">N</span>-<span class="number">1</span>-r][<span class="built_in">N</span>-<span class="number">1</span>-c] = m[<span class="built_in">N</span>-<span class="number">1</span>-c][r];</span><br><span class="line">    m[<span class="built_in">N</span>-<span class="number">1</span>-c][r] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-Linked-Lists"><a href="#6-2-Linked-Lists" class="headerlink" title="6.2 Linked Lists"></a>6.2 Linked Lists</h3><p>Questions:</p>
<ul>
<li><p>  2.1 Write code to remove duplicates from an unsorted linked list. How would you solve this problem if a temporary buffer is not allowed?</p>
</li>
<li><p>  2.2 Implement an algorithm to find the nth to last element of a singly linked list.</p>
</li>
<li><p>  2.3 Implement an algorithm to delete a node in the middle of a single linked list, given only access to that node.</p>
</li>
<li><p>  2.4 You have two numbers represented by a linked list, where each node contains a sin- gle digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.</p>
</li>
<li><p>(x) 2.5 Given a circular linked list, implement an algorithm which returns node at the begin- ning of the loop.</p>
<ul>
<li><p>Assume P,Q at head. P proceeds 1 step, and Q proceed 2 step. There is k nodes before entry node of the circular list. And they takes u step to meet each other at p in the circular list. So we have following equations.</p>
<ol>
<li> k + xn + p= 2u # Q position.</li>
<li> k + yn + p = u # P position.</li>
<li> u = zn # using 1 and 2.</li>
<li> (k + p) = z’n # using 2 and 3.</li>
<li> k % n = (n-p) # done.</li>
</ol>
</li>
<li><p>  see leetcode <a href="https://oj.leetcode.com/problems/linked-list-cycle/">https://oj.leetcode.com/problems/linked-list-cycle/</a> and <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">https://oj.leetcode.com/problems/linked-list-cycle-ii/</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-Stacks-and-Queues"><a href="#6-3-Stacks-and-Queues" class="headerlink" title="6.3 Stacks and Queues"></a>6.3 Stacks and Queues</h3><p>Questions:</p>
<ul>
<li>  3.1 Describe how you could use a single array to implement three stacks.</li>
<li>  3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time.</li>
<li>  3.5 Implement a MyQueue class which implements a queue using two stacks.</li>
<li>  3.6 Write a program to sort a stack in ascending order. You should not make any assump- tions about how the stack is implemented.</li>
</ul>
<h3 id="6-4-Trees-and-Graphs"><a href="#6-4-Trees-and-Graphs" class="headerlink" title="6.4 Trees and Graphs"></a>6.4 Trees and Graphs</h3><ul>
<li><p>Trees</p>
<ul>
<li>  Not all binary trees are binary search trees</li>
<li>  In-Order: Traverse left node, current node, then right</li>
<li>  Pre-Order: Traverse current node, then left node, then right node</li>
<li>  Post-Order: Traverse left node, then right node, then current node</li>
<li>  <strong>AVL Tree, RB Tree.</strong></li>
<li>  <strong>Construct Tree by using Orders</strong></li>
</ul>
</li>
<li><p>Graphs</p>
<ul>
<li>  Depth First Search</li>
<li>  Breadth First Search</li>
<li>  <strong>Dijkstra,Floyd,Prim,Kruskal.</strong></li>
</ul>
</li>
</ul>
<p>Questions:</p>
<ul>
<li>  4.1 Implement a function to check if a tree is balanced.</li>
<li>  4.2 Given a directed graph, design an algorithm to find out whether there is a route be- tween two nodes.</li>
<li>  4.3 Given a sorted (increasing order) array, write an algorithm to create a binary tree with minimal height.</li>
<li>  4.4 Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (eg, if you have a tree with depth D, you’ll have D linked lists).</li>
<li>  4.5 Write an algorithm to find the ‘next’ node (e.g., in-order successor) of a given node in a binary search tree where each node has a link to its parent.</li>
<li>  4.6 Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure.</li>
<li>  4.7 You have two very large binary trees: T1, with millions of nodes, and T2, with hun- dreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.</li>
<li>  4.8 You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum up to that value.</li>
</ul>
<hr>
<p>4.6</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">TreeNode* ancestor(TreeNode* root,TreeNode* p,TreeNode* q,int&amp; cond) &#123;</span><br><span class="line">  if(root == NU<span class="class">LL) return NULL;</span></span><br><span class="line">  if(root == p || root == q) &#123;</span><br><span class="line">    cond++; // root is p<span class="built_in"> or </span>q, find one.</span><br><span class="line">  &#125;</span><br><span class="line">  //<span class="built_in"> check </span>left.</span><br><span class="line"> <span class="built_in"> int </span>c = 0;</span><br><span class="line">  TreeNode* t = ancestor(root-&gt;left, p, q, c);</span><br><span class="line">  if(c == 2) &#123;</span><br><span class="line">    cond = 2;</span><br><span class="line">   <span class="built_in"> return </span>t;</span><br><span class="line">  &#125;</span><br><span class="line">  cond += c;  </span><br><span class="line">  if(cond == 2) &#123;</span><br><span class="line">   <span class="built_in"> return </span>root;</span><br><span class="line">  &#125;</span><br><span class="line">  //<span class="built_in"> check </span>right.</span><br><span class="line">  c = 0;</span><br><span class="line">  t = ancestor(root-&gt;right, p, q, c);</span><br><span class="line">  if(c == 2) &#123;</span><br><span class="line">    cond = 2;</span><br><span class="line">       <span class="built_in"> return </span>t;</span><br><span class="line">  &#125;</span><br><span class="line">  cond += c;</span><br><span class="line">  if(cond == 2) &#123;</span><br><span class="line">   <span class="built_in"> return </span>root;</span><br><span class="line">  &#125;</span><br><span class="line">  // maybe cover one.</span><br><span class="line"> <span class="built_in"> return </span>root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* ancestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line"> <span class="built_in"> int </span>cond;</span><br><span class="line"> <span class="built_in"> return </span>ancestor(root, p, q, cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-5-Bit-Manipulation"><a href="#6-5-Bit-Manipulation" class="headerlink" title="6.5 Bit Manipulation"></a>6.5 Bit Manipulation</h3><p><img data-src="" alt="bitop.png"></p>
<p>Questions:</p>
<ul>
<li>  5.1 You are given two 32-bit numbers, N and M, and two bit positions, i and j Write a method to set all bits between i and j in N equal to M. Input: N = 10000000000, M = 10101, i = 2, j = 6. Output: N = 10001010100</li>
<li>  5.2 Given a (decimal - e g 3 72) number that is passed in as a string, print the binary rep- resentation If the number can not be represented accurately in binary, print “ERROR”</li>
<li>  5.3 Given an integer, print the next smallest and next largest number that have the same number of 1 bits in their binary representation.</li>
<li>  5.4 Explain what the following code does: ((n &amp; (n-1)) == 0).</li>
<li>  5.5 Write a function to determine the number of bits required to convert integer A to integer B.</li>
<li>  5.6 Write a program to swap odd and even bits in an integer with as few instructions as possible (e g , bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, etc).</li>
</ul>
<hr>
<p>5.3</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> previous(<span class="built_in">int</span> number) &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">n</span> = number;</span><br><span class="line">  <span class="built_in">int</span> <span class="symbol">c1</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="symbol">c0</span> = <span class="number">0</span>;</span><br><span class="line">  // <span class="built_in">find</span> <span class="number">0</span>.</span><br><span class="line">  while(<span class="built_in">n</span> &amp; <span class="number">0</span>x1) &#123;</span><br><span class="line">    <span class="built_in">n</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="symbol">c1</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  // <span class="built_in">find</span> <span class="number">1</span>.</span><br><span class="line">  while(!(<span class="built_in">n</span> &amp; <span class="number">0</span>x1)) &#123;</span><br><span class="line">    <span class="built_in">n</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="symbol">c0</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  // rearrange following <span class="number">1</span> <span class="built_in">and</span> <span class="number">0</span>.</span><br><span class="line">  // <span class="number">10</span> with <span class="symbol">c0</span>-<span class="number">1</span>&#123;<span class="number">0</span>&#125; <span class="built_in">and</span> <span class="symbol">c1</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">  // change to <span class="number">01</span> <span class="symbol">c1</span>&#123;<span class="number">1</span>&#125; <span class="symbol">c0</span>-<span class="number">1</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">  <span class="built_in">n</span> = ((<span class="built_in">n</span> &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="symbol">c1</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">n</span> = (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="symbol">c0</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">n</span> = (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="built_in">n</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> next(<span class="built_in">int</span> number) &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">n</span> = number;</span><br><span class="line">  <span class="built_in">int</span> <span class="symbol">c1</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="symbol">c0</span> = <span class="number">0</span>;</span><br><span class="line">  // <span class="built_in">find</span> <span class="number">1</span>.</span><br><span class="line">  while(!(<span class="built_in">n</span> &amp; <span class="number">0</span>x1)) &#123;</span><br><span class="line">    <span class="built_in">n</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="symbol">c0</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  // <span class="built_in">find</span> <span class="number">0</span>.</span><br><span class="line">  while(<span class="built_in">n</span> &amp; <span class="number">0</span>x1) &#123;</span><br><span class="line">    <span class="built_in">n</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="symbol">c1</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  // rearrrange following <span class="number">1</span> <span class="built_in">and</span> <span class="number">0</span>.</span><br><span class="line">  // change to <span class="number">1</span> <span class="symbol">c0</span>+<span class="number">1</span>&#123;<span class="number">0</span>&#125; <span class="symbol">c1</span>-<span class="number">1</span>&#123;<span class="number">1</span>&#125;.</span><br><span class="line">  <span class="built_in">n</span> += <span class="number">1</span>;</span><br><span class="line">  for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=<span class="symbol">c0</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">n</span> = (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="symbol">c1</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">n</span> = (<span class="built_in">n</span> &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="built_in">n</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">n</span> = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int</span> m = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  assert(previous(<span class="built_in">n</span>) == m);</span><br><span class="line">  assert(next(m) == <span class="built_in">n</span>);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-Brain-Teasers"><a href="#6-6-Brain-Teasers" class="headerlink" title="6.6 Brain Teasers"></a>6.6 Brain Teasers</h3><ul>
<li>  Don’t panic when you get a brain teaser. Interviewers want to see how you tackle a problem; they don’t expect you to immediately know the answer. Start talking, and show the interviewer how you approach a problem</li>
<li>  In many cases, you will also find that the brain teasers have some connection back to fundamental laws or theories of computer science.</li>
<li>  If you’re stuck, we recommend simplifying the problem. Solve it for a small number of items or a special case, and then see if you can generalize it.</li>
</ul>
<p>Questions:</p>
<ul>
<li><p>  6.1 Add arithmetic operators (plus, minus, times, divide) to make the following expres- sion true: 3 1 3 6 = 8. You can use any parentheses you’d like.</p>
</li>
<li><p>  (x) 6.2 There is an 8x8 chess board in which two diagonally opposite corners have been cut off. You are given 31 dominos, and a single domino can cover exactly two squares. Can you use the 31 dominos to cover the entire board?</p>
</li>
<li><p>  6.3 You have a five quart jug and a three quart jug, and an unlimited supply of water (but no measuring cups). How would you come up with exactly four quarts of water?</p>
</li>
<li><p>  (x) 6.4 A bunch of men are on an island. A genie comes down and gathers everyone to- gether and places a magical hat on some people’s heads (i e , at least one person has a hat). The hat is magical: it can be seen by other people, but not by the wearer of the hat himself. To remove the hat, those(and only those who have a hat) must dunk themselves underwater at exactly midnight. If there are n people and c hats, how long does it take the men to remove the hats? The men cannot tell each other (in any way) that they have a hat.</p>
</li>
<li><p>(x) 6.5 There is a building of 100 floors If an egg drops from the Nth floor or above it will break. If it’s dropped from any floor below, it will not break. You’re given 2 eggs Find N, while minimizing the number of drops for the worst case.</p>
<ul>
<li>  dp[t][s][e] = 1 + min{ i=[s,e], max(dp[t-1][s][i-1], dp[t][i+1][e]) }. if(s&gt;e) 0 else if(t==0) e-s+1</li>
<li>  note: not easy to deduce actions from dp</li>
<li>  note: and only one step can be decided. I’ve attached the code below.</li>
</ul>
</li>
<li><p>(x) 6.6 There are one hundred closed lockers in a hallway. A man begins by opening all one hundred lockers Next, he closes every second locker. Then he goes to every third locker and closes it if it is open or opens it if it is closed (e g , he toggles every third locker). After his one hundredth pass in the hallway, in which he toggles only locker number one hundred, how many lockers are open?</p>
<ul>
<li>  only n = p * p have been flipped with odd number and final status is open.</li>
</ul>
</li>
</ul>
<hr>
<p>6.5</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> R = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> dp[R][N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s&gt;e) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(dp[t][s][e] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> dp[t][s][e];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=e;i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">get</span>(t,i+<span class="number">1</span>,e),dp[t<span class="number">-1</span>][s][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">-1</span> || r &lt; v) &#123;</span><br><span class="line">      v = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[t][s][e] = v;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=N;j++) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][i][j] = (j-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;R;t++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;=N;s++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;e&lt;=N;e++) &#123;</span><br><span class="line">        <span class="built_in">get</span>(t,s,e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t = R<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> v = dp[t][<span class="number">1</span>][N];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,v);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">bool</span> changed = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(changed) &#123;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;=N;i++) &#123;</span><br><span class="line">      <span class="comment">// search first point that egg breaks.</span></span><br><span class="line">      <span class="comment">// and to my intuition, there will be only one point.</span></span><br><span class="line">      <span class="keyword">if</span>(v == (c + dp[t<span class="number">-1</span>][s][i<span class="number">-1</span>])) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;below %d\n&quot;</span>,i);</span><br><span class="line">        s = i+<span class="number">1</span>;</span><br><span class="line">        c++;</span><br><span class="line">        changed = <span class="literal">true</span>;        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  <span class="built_in">reverse</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-Object-Oriented-Design"><a href="#6-7-Object-Oriented-Design" class="headerlink" title="6.7 Object Oriented Design"></a>6.7 Object Oriented Design</h3><h3 id="6-8-Recursion"><a href="#6-8-Recursion" class="headerlink" title="6.8 Recursion"></a>6.8 Recursion</h3><ul>
<li>  All problems that can be solved recursively can also be solved iteratively (though the code may be much more complicated). Before diving into a recursive code, ask yourself how hard it would be to implement this algorithm iteratively. Discuss the trade-offs with your interviewer.</li>
<li>  Recursive algorithms can be very space inefficient. Each recursive call adds a new layer to the stack, which means that if your algorithm has O(n) recursive calls then it uses O(n) memory Ouch! This is one reason why an iterative algorithm may be better.</li>
</ul>
<p>Questions:</p>
<ul>
<li><p>8.2 Imagine a robot sitting on the upper left hand corner of an NxN grid The robot can only move in two directions: right and down How many possible paths are there for the robot?</p>
<ul>
<li>  Imagine certain squares are “off limits”, such that the robot can not step on them Design an algorithm to get all possible paths for the robot</li>
</ul>
</li>
<li><p>  8.3 Write a method that returns all subsets of a set.</p>
</li>
<li><p>  8.4 Write a method to compute all permutations of a string.</p>
</li>
<li><p>  8.5 Implement an algorithm to print all valid (e g , properly opened and closed) combi- nations of n-pairs of parentheses.</p>
</li>
<li><p>  8.7 Given an infinite number of quarters (25 cents), dimes (10 cents), nickels (5 cents) and pennies (1 cent), write code to calculate the number of ways of representing n cents.</p>
</li>
<li><p>  8.8 Write an algorithm to print all ways of arranging eight queens on a chess board so that none of them share the same row, column or diagonal.</p>
</li>
</ul>
<h3 id="6-9-Sorting-and-Searching"><a href="#6-9-Sorting-and-Searching" class="headerlink" title="6.9 Sorting and Searching"></a>6.9 Sorting and Searching</h3><ul>
<li>  Bubble Sort</li>
<li>  Selection Sort</li>
<li>  Merge Sort</li>
<li>  Quick Sort</li>
<li>  Bucket Sort</li>
<li>  <strong>Binary Search</strong></li>
</ul>
<p>Questions:</p>
<ul>
<li><p>  (x) 9.1 You are given two sorted arrays, A and B, and A has a large enough buffer at the end to hold B Write a method to merge B into A in sorted order.</p>
</li>
<li><p>  9.3 Given a sorted array of n integers that has been rotated an unknown number of times,give an O(logn) algorithm that finds an element in the array. You may assume that the array was originally sorted in increasing order. EXAMPLE: Input: find 5 in array (15 16 19 20 25 1 3 4 5 7 10 14) Output: 8 (the index of 5 in the array)</p>
</li>
<li><p>  9.4 If you have a 2 GB file with one string per line, which sorting algorithm would you use to sort the file and why?</p>
</li>
<li><p>9.5 Given a sorted array of strings which is interspersed with empty strings, write a meth- od to find the location of a given string</p>
<ul>
<li>  Example: find “ball” in [“at”, “”, “”, “”, “ball”, “”, “”, “car”, “”, “”, “dad”, “”, “”] will return 4</li>
<li>  Example: find “ballcar” in [“at”, “”, “”, “”, “”, “ball”, “car”, “”, “”, “dad”, “”, “”] will return -1</li>
</ul>
</li>
<li><p>  9.6 Given a matrix in which each row and each column is sorted, write a method to find an element in it.</p>
</li>
<li><p>  9.7 A circus is designing a tower routine consisting of people standing atop one anoth- er’s shoulders. For practical and aesthetic reasons, each person must be both shorter and lighter than the person below him or her. Given the heights and weights of each person in the circus, write a method to compute the largest possible number of peo- ple in such a tower. EXAMPLE: Input (ht, wt): (65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110) Output: The longest tower is length 6 and includes from top to bottom: (56, 90) (60,95) (65,100) (68,110) (70,150) (75,190)</p>
</li>
</ul>
<hr>
<p>9.3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> e = n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(s &lt;= e) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = (s + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[m] == x) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">if</span>(A[m] &gt; x) &#123;</span><br><span class="line">      <span class="keyword">if</span>(A[s] &lt;= x) &#123;</span><br><span class="line">        e = m - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = m + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(A[e] &gt;=x) &#123;</span><br><span class="line">        s = m + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e = m - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert position.</span></span><br><span class="line">  <span class="comment">// return s;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A[] = &#123;<span class="number">15</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">14</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(A) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BS</span>(A,n,<span class="number">5</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>9.5</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt;&amp; A,<span class="keyword">const</span> string&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> e = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(s &lt;= e) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = (s + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[m] == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = m;</span><br><span class="line">      <span class="keyword">while</span>(u&gt;=<span class="number">0</span> &amp;&amp; A[u] == <span class="string">&quot;&quot;</span>) u--;</span><br><span class="line">      <span class="keyword">if</span>(u &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[u] == x) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[u] &gt; x) &#123;</span><br><span class="line">          e = u - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      u = m;</span><br><span class="line">      <span class="keyword">while</span>(u&lt;=e &amp;&amp; A[u] == <span class="string">&quot;&quot;</span>) u++;</span><br><span class="line">      <span class="keyword">if</span>(u &lt;= e) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[u] == x) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[u] &lt; x) &#123;</span><br><span class="line">          s = u + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(A[m] == x) &#123;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(A[m] &gt; x) &#123;</span><br><span class="line">      m = e - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = e + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ss[] = &#123;<span class="string">&quot;at&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;car&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;dad&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  vector&lt;string&gt; A;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;ss[i];i++) &#123;</span><br><span class="line">    A.<span class="built_in">push_back</span>(ss[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BS</span>(A,<span class="string">&quot;ball&quot;</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">BS</span>(A,<span class="string">&quot;ballcar&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-10-Mathematical"><a href="#6-10-Mathematical" class="headerlink" title="6.10 Mathematical"></a>6.10 Mathematical</h3><p>Questions:</p>
<ul>
<li>10.1 You have a basketball hoop and someone says that you can play 1 of 2 games<ul>
<li>  Game #1: You get one shot to make the hoop</li>
<li>  Game #2: You get three shots and you have to make 2 of 3 shots</li>
<li>  If p is the probability of making a particular shot, for which values of p should you pick one game or the other?</li>
</ul>
</li>
<li>  10.2 There are three ants on different vertices of a triangle What is the probability of colli- sion (between any two or all of them) if they start walking on the sides of the triangle? Similarly find the probability of collision with ‘n’ ants on an ‘n’ vertex polygon</li>
<li>  10.4 Write a method to implement *, - , / operations You should use only the + operator.</li>
<li>  (x) 10.5 Given two squares on a two dimensional plane, find a line that would cut these two squares in half.</li>
<li>  (x) 10.6 Given a two dimensional graph with points on it, find a line which passes the most number of points.</li>
<li>  (x) 10.7 Design an algorithm to find the kth number such that the only prime factors are 3, 5, and 7.</li>
</ul>
<hr>
<p>10.7</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;queue&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;algorithm&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;vector&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> kth(<span class="built_in">int</span> k) &#123;</span><br><span class="line">  priority_queue&lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,std::greater&lt;<span class="built_in">int</span>&gt; &gt; Q3; <span class="comment">// 3,5,7</span></span><br><span class="line">  priority_queue&lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,std::greater&lt;<span class="built_in">int</span>&gt; &gt; Q5; <span class="comment">// 5,7</span></span><br><span class="line">  priority_queue&lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,std::greater&lt;<span class="built_in">int</span>&gt; &gt; Q7; <span class="comment">// 7</span></span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>push(<span class="number">3</span>);</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Q5</span>.</span></span>push(<span class="number">5</span>);</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Q7</span>.</span></span>push(<span class="number">7</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="built_in">int</span> x = min(min(<span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>top<span class="literal">()</span>,<span class="module-access"><span class="module"><span class="identifier">Q5</span>.</span></span>top<span class="literal">()</span>),<span class="module-access"><span class="module"><span class="identifier">Q7</span>.</span></span>top<span class="literal">()</span>);</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">if</span>(k<span class="operator"> == </span><span class="number">0</span>) return x;</span><br><span class="line">    <span class="keyword">if</span>(x<span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>top<span class="literal">()</span>) &#123;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>pop<span class="literal">()</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>push(x<span class="operator"> * </span><span class="number">3</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>push(x<span class="operator"> * </span><span class="number">5</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q3</span>.</span></span>push(x<span class="operator"> * </span><span class="number">7</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x<span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Q5</span>.</span></span>top<span class="literal">()</span>) &#123;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q5</span>.</span></span>pop<span class="literal">()</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q5</span>.</span></span>push(x<span class="operator"> * </span><span class="number">5</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q5</span>.</span></span>push(x<span class="operator"> * </span><span class="number">7</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q7</span>.</span></span>pop<span class="literal">()</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Q7</span>.</span></span>push(x<span class="operator"> * </span><span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span> &#123;</span><br><span class="line">  printf(<span class="string">&quot;%d\n&quot;</span>,kth(<span class="number">13</span>));</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-11-Testing"><a href="#6-11-Testing" class="headerlink" title="6.11 Testing"></a>6.11 Testing</h3><h3 id="6-12-System-Design-and-Memory-Limits"><a href="#6-12-System-Design-and-Memory-Limits" class="headerlink" title="6.12 System Design and Memory Limits"></a>6.12 System Design and Memory Limits</h3><p>Questions:</p>
<ul>
<li><p>  11.1 If you were integrating a feed of end of day stock price information (open, high, low, and closing price) for 5,000 companies, how would you do it? You are responsible for the development, rollout and ongoing monitoring and maintenance of the feed. Describe the different methods you considered and why you would recommend your approach. The feed is delivered once per trading day in a comma-separated format via an FTP site. The feed will be used by 1000 daily users in a web application.</p>
</li>
<li><p>  11.2 How would you design the data structures for a very large social network (Facebook, LinkedIn, etc)? Describe how you would design an algorithm to show the connec- tion, or path, between two people (e g , Me -&gt; Bob -&gt; Susan -&gt; Jason -&gt; You).</p>
</li>
<li><p>(x) 11.3 Given an input file with four billion integers, provide an algorithm to generate an integer which is not contained in the file. Assume you have 1 GB of memory. What if you have only 10 MB of memory?</p>
<ul>
<li>  note: The solution provided by the book should be with a restriction that integers are not repeated. But anyway, the solution is inspiring</li>
</ul>
</li>
<li><p>  11.4 You have an array with all the numbers from 1 to N, where N is at most 32,000. The array may have duplicate entries and you do not know what N is. With only 4KB of memory available, how would you print all duplicate elements in the array?</p>
</li>
<li><p>  11.5 If you were designing a web crawler, how would you avoid getting into infinite loops?</p>
</li>
<li><p>  11.6 You have a billion urls, where each is a huge page How do you detect the duplicate documents?</p>
</li>
<li><p>  11.7 You have to design a database that can store terabytes of data It should support ef- ficient range queries How would you do it?.</p>
</li>
</ul>
<h3 id="6-13-C"><a href="#6-13-C" class="headerlink" title="6.13 C++"></a>6.13 C++</h3><h3 id="6-14-Java"><a href="#6-14-Java" class="headerlink" title="6.14 Java"></a>6.14 Java</h3><h3 id="6-15-Databases"><a href="#6-15-Databases" class="headerlink" title="6.15 Databases"></a>6.15 Databases</h3><h3 id="6-16-Low-Level"><a href="#6-16-Low-Level" class="headerlink" title="6.16 Low Level"></a>6.16 Low Level</h3><p>Questions:</p>
<ul>
<li>  16.1 Explain the following terms: virtual memory, page fault, thrashing.</li>
<li>  (x) 16.2 What is a Branch Target buffer? Explain how it can be used in reducing bubble cycles in cases of branch misprediction.</li>
<li>  (x) 16.3 Describe direct memory access (DMA). Can a user level buffer / pointer be used by kernel or drivers?</li>
<li>  (x) 16.4 Write a step by step execution of things that happen after a user presses a key on the keyboard Use as much detail as possible.</li>
<li>  16.5 Write a program to find whether a machine is big endian or little endian.</li>
<li>  16.6 Discuss how would you make sure that a process doesn’t access an unauthorized part of the stack.</li>
<li>  16.7 What are the best practices to prevent reverse engineering of DLLs?.</li>
<li>  (x) 16.8 A device boots with an empty FIFO queue In the first 400 ns period after startup, and in each subsequent 400 ns period, a maximum of 80 words will be written to the queue Each write takes 4 ns A worker thread requires 3 ns to read a word, and 2 ns to process it before reading the next word What is the shortest depth of the FIFO such that no data is lost?</li>
<li>  16.9 Write an aligned malloc &amp; free function that takes number of bytes and aligned byte (which is always power of 2).</li>
<li>  16.10 Write a function called my2DAlloc which allocates a two dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].</li>
</ul>
<h3 id="6-17-Networking"><a href="#6-17-Networking" class="headerlink" title="6.17 Networking"></a>6.17 Networking</h3><p>Questions:</p>
<ul>
<li>  17.1 Explain what happens, step by step, after you type a URL into a browser. Use as much detail as possible.</li>
<li>  17.2 Explain any common routing protocol in detail For example: BGP, OSPF, RIP</li>
<li>  17.3 Compare and contrast the IPv4 and IPv6 protocols.</li>
<li>  (x) 17.4 What is a network / subnet mask? Explain how host A sends a message / packet to host B when: (a) both are on same network and (b) both are on different networks Explain which layer makes the routing decision and how.</li>
<li>  (x) 17.5 What are the differences between TCP and UDP? Explain how TCP handles reliable delivery (explain ACK mechanism), flow control (explain TCP sender’s / receiver’s win- dow) and congestion control.</li>
</ul>
<h3 id="6-18-Threads-and-Locks"><a href="#6-18-Threads-and-Locks" class="headerlink" title="6.18 Threads and Locks"></a>6.18 Threads and Locks</h3><p>Questions:</p>
<ul>
<li>  18.1 What’s the difference between a thread and a process?</li>
<li>  18.2 How can you measure the time spent in a context switch?</li>
<li>  18.3 Implement a singleton design pattern as a template such that, for any given class Foo, you can call Singleton::instance() and get a pointer to an instance of a singleton of type Foo. Assume the existence of a class Lock which has acquire() and release() methods. How could you make your implementation thread safe and exception safe?.</li>
<li>  18.4 Design a class which provides a lock only if there are no possible deadlocks.</li>
<li>  18.5 You are given a class with synchronized method A, and a normal method C If you have two threads in one instance of a program, can they call A at the same time? Can they call A and C at the same time?</li>
</ul>
<h3 id="6-19-Moderate-Additional-Review-Problems"><a href="#6-19-Moderate-Additional-Review-Problems" class="headerlink" title="6.19 Moderate Additional Review Problems"></a>6.19 Moderate Additional Review Problems</h3><p>Questions: </p>
<ul>
<li>  19.1 Write a function to swap a number in place without temporary variables.</li>
<li>  (x) 19.3 Write an algorithm which computes the number of trailing zeros in n factorial.</li>
<li>  19.4 Write a method which finds the maximum of two numbers. You should not use if- else or any other comparison operator.</li>
<li>  19.6 Given an integer between 0 and 999,999, print an English phrase that describes the integer (eg, “One Thousand, Two Hundred and Thirty Four”).</li>
<li>  19.7 You are given an array of integers (both positive and negative). Find the continuous sequence with the largest sum. Return the sum.</li>
<li>  19.8 Design a method to find the frequency of occurrences of any given word in a book.</li>
<li>  (x) 19.10 Write a method to generate a random number between 1 and 7, given a method that generates a random number between 1 and 5 (i e , implement rand7() using rand5()).</li>
<li>  19.11 Design an algorithm to find all pairs of integers within an array which sum to a speci- fied value.</li>
</ul>
<hr>
<p>19.3</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> zeros(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">  <span class="built_in">int</span> c = <span class="number">0</span>;</span><br><span class="line">  for(<span class="built_in">int</span> k = <span class="number">5</span>; <span class="built_in">n</span> &gt;= k; k *= <span class="number">5</span>) &#123;</span><br><span class="line">    c += <span class="built_in">n</span> / k;</span><br><span class="line">  &#125;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>19.6</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* s1[] = &#123;<span class="string">&quot;Zero&quot;</span>,<span class="string">&quot;One&quot;</span>,<span class="string">&quot;Two&quot;</span>,<span class="string">&quot;Three&quot;</span>,<span class="string">&quot;Four&quot;</span>,<span class="string">&quot;Five&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;Six&quot;</span>,<span class="string">&quot;Seven&quot;</span>,<span class="string">&quot;Eight&quot;</span>,<span class="string">&quot;Nine&quot;</span>,<span class="string">&quot;Ten&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;Eleven&quot;</span>,<span class="string">&quot;Twelve&quot;</span>,<span class="string">&quot;Thirteen&quot;</span>,<span class="string">&quot;Fourteen&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;Fifteen&quot;</span>,<span class="string">&quot;Sixteen&quot;</span>,<span class="string">&quot;Seventeen&quot;</span>,<span class="string">&quot;Eighteen&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* s2[] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;Twenty&quot;</span>,<span class="string">&quot;Thirty&quot;</span>,<span class="string">&quot;Fourty&quot;</span>,<span class="string">&quot;Fifty&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;Sixty&quot;</span>,<span class="string">&quot;Seventy&quot;</span>,<span class="string">&quot;Eighty&quot;</span>,<span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">speak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">19</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s1[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = n % <span class="number">10</span>;    </span><br><span class="line">    string s = s2[n / <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">      s += <span class="string">&quot; &quot;</span>;</span><br><span class="line">      s += s1[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = n % <span class="number">100</span>;</span><br><span class="line">    string s = s1[n / <span class="number">100</span>];</span><br><span class="line">    s += <span class="string">&quot; Hundred&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">      s += <span class="string">&quot; and &quot;</span>;</span><br><span class="line">      s += <span class="built_in">speak</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> m = n % <span class="number">1000</span>;</span><br><span class="line">    string s = <span class="built_in">speak</span>(n / <span class="number">1000</span>);</span><br><span class="line">    s += <span class="string">&quot; Thousand&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">      s += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">      s += <span class="built_in">speak</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">speak</span>(n).<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1001</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1010</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">999100</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-20-Hard-Additional-Review-Problems"><a href="#6-20-Hard-Additional-Review-Problems" class="headerlink" title="6.20 Hard Additional Review Problems"></a>6.20 Hard Additional Review Problems</h3><p>Questions:</p>
<ul>
<li>  (x) 20.1 Write a function that adds two numbers You should not use + or any arithmetic op- erators.</li>
<li>  (x) 20.2 Write a method to shuffle a deck of cards. It must be a perfect shuffle - in other words, each 52! permutations of the deck has to be equally likely. Assume that you are given a random number generator which is perfect.</li>
<li>  (x) 20.3 Write a method to randomly generate a set of m integers from an array of size n. Each element must have equal probability of being chosen.</li>
<li>  (x) 20.4 Write a method to count the number of 2s between 0 and n.</li>
<li>  20.5 You have a large text file containing words. Given any two words, find the shortest distance (in terms of number of words) between them in the file. Can you make the searching operation in O(1) time? What about the space complexity for your solu- tion?</li>
<li>  (x) 20.6 Describe an algorithm to find the largest 1 million numbers in 1 billion numbers. As- sume that the computer memory can hold all one billion numbers.</li>
<li>  (x) 20.7 Write a program to find the longest word made of other words.</li>
<li>  (x) 20.8 Given a string s and an array of smaller strings T, design a method to search s for each small string in T.</li>
<li>  (x) 20.9 Numbers are randomly generated and passed to a method. Write a program to find and maintain the median value as new values are generated.</li>
<li>  (x) 20.10 Given two words of equal length that are in a dictionary, write a method to transform one word into another word by changing only one letter at a time. The new word you get in each step must be in the dictionary.</li>
<li>  (x) 20.11 Imagine you have a square matrix, where each cell is filled with either black or white. Design an algorithm to find the maximum subsquare such that all four borders are filled with black pixels.</li>
<li>  (x) 20.12 Given an NxN matrix of positive and negative integers, write code to find the sub- matrix with the largest possible sum.</li>
<li>  (x) 20.13 Given a dictionary of millions of words, give an algorithm to find the largest possible rectangle of letters such that every row forms a word (reading left to right) and every column forms a word (reading top to bottom).</li>
</ul>
<hr>
<p>20.1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = a ^ b;</span><br><span class="line">  <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(carry == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">add2</span>(sum,carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">add2</span>(<span class="number">190</span>,<span class="number">70</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>20.4</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c2r</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> pow)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> x = n / pow;</span><br><span class="line">  <span class="keyword">int</span> y = n % pow;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">2</span>) &#123;</span><br><span class="line">    res += (y + <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    res += pow;</span><br><span class="line">  &#125;</span><br><span class="line">  res += x * <span class="built_in">c2r</span>(pow<span class="number">-1</span>,pow / <span class="number">10</span>) + <span class="built_in">c2</span>(y);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pow = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>((pow * <span class="number">10</span>) &lt;= n) pow *= <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">c2r</span>(n,pow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">c2</span>(<span class="number">279</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>20.9</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;queue&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;algorithm&gt;</span><br><span class="line">#<span class="keyword">include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Median &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  priority_queue&lt; <span class="built_in">int</span>, vector&lt;<span class="built_in">int</span>&gt;, less&lt;<span class="built_in">int</span>&gt; &gt; Q0;</span><br><span class="line">  priority_queue&lt; <span class="built_in">int</span>, vector&lt;<span class="built_in">int</span>&gt;, greater&lt;<span class="built_in">int</span>&gt; &gt; Q1;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  void insert(<span class="built_in">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>empty<span class="literal">()</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>empty<span class="literal">()</span>) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>push(x);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> y = <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>top<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) &#123;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>pop<span class="literal">()</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>push(y);</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>push(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> x0 = <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>top<span class="literal">()</span>;</span><br><span class="line">    <span class="built_in">int</span> x1 = <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>top<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>size<span class="literal">()</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>size<span class="literal">()</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(x &lt;= x0) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>pop<span class="literal">()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>push(x);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>push(x0);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>push(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(x &gt;= x1) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>pop<span class="literal">()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>push(x);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>push(x1);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>push(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double median<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>size<span class="literal">()</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>size<span class="literal">()</span>) &#123;</span><br><span class="line">      return (<span class="module-access"><span class="module"><span class="identifier">Q0</span>.</span></span>top<span class="literal">()</span> + <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>top<span class="literal">()</span>)<span class="operator"> * </span><span class="number">0.5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      return <span class="module-access"><span class="module"><span class="identifier">Q1</span>.</span></span>top<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span> &#123;</span><br><span class="line">  Median m;</span><br><span class="line">  m.insert(<span class="number">1</span>);</span><br><span class="line">  m.insert(<span class="number">2</span>);</span><br><span class="line">  printf(<span class="string">&quot;%g\n&quot;</span>,m.median<span class="literal">()</span>);</span><br><span class="line">  m.insert(<span class="number">3</span>);</span><br><span class="line">  printf(<span class="string">&quot;%g\n&quot;</span>,m.median<span class="literal">()</span>);</span><br><span class="line">  m.insert<span class="number">(-3)</span>;</span><br><span class="line">  printf(<span class="string">&quot;%g\n&quot;</span>,m.median<span class="literal">()</span>);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>20.11</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> m[<span class="built_in">N</span>][<span class="built_in">N</span>];</span><br><span class="line">for(<span class="built_in">int</span> <span class="built_in">n</span>=<span class="built_in">N</span>;<span class="built_in">n</span>&gt;=<span class="number">1</span>;<span class="built_in">n</span>--) &#123;</span><br><span class="line">  for(<span class="built_in">int</span> r=<span class="number">0</span>;(<span class="built_in">N</span>-r)&gt;=<span class="built_in">n</span>;r++) &#123;</span><br><span class="line">    for(<span class="built_in">int</span> c=<span class="number">0</span>;(<span class="built_in">N</span>-c)&gt;=<span class="built_in">n</span>;r++) &#123;</span><br><span class="line">      <span class="built_in">if</span>(bound(r,c,<span class="built_in">n</span>)) &#123;</span><br><span class="line">        return <span class="built_in">n</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>20.12</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> m[<span class="built_in">N</span>][<span class="built_in">N</span>];</span><br><span class="line"><span class="built_in">int</span> dp[<span class="built_in">N</span>][<span class="built_in">N</span>]; // dp[s][e] = <span class="built_in">sum</span> from (<span class="number">0</span>,<span class="number">0</span>) to (s,e).</span><br><span class="line">for(<span class="built_in">int</span> r=<span class="number">0</span>;r&lt;<span class="built_in">N</span>;r++) &#123;</span><br><span class="line">  for(<span class="built_in">int</span> c=<span class="number">0</span>;c&lt;<span class="built_in">N</span>;c++) &#123;</span><br><span class="line">    <span class="built_in">int</span> s = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;c;i++) &#123;</span><br><span class="line">      s += m[r][i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[r][c] = s;</span><br><span class="line">    <span class="built_in">if</span>(r != <span class="number">0</span>) &#123;</span><br><span class="line">      dp[r][c] += dp[r-<span class="number">1</span>][c];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> v = INT_MIN;</span><br><span class="line">for(<span class="built_in">int</span> rs=<span class="number">0</span>;rs&lt;<span class="built_in">N</span>;rs++) &#123;</span><br><span class="line">  for(<span class="built_in">int</span> re=rs;re&lt;<span class="built_in">N</span>;re++) &#123;</span><br><span class="line">    for(<span class="built_in">int</span> cs=<span class="number">0</span>;cs&lt;<span class="built_in">N</span>;cs++) &#123;</span><br><span class="line">      for(<span class="built_in">int</span> ce=<span class="number">0</span>;ce&lt;<span class="built_in">N</span>;ce++) &#123;</span><br><span class="line">        <span class="built_in">int</span> u = <span class="built_in">sum</span>(rs,cs,re,ce);</span><br><span class="line">        <span class="built_in">if</span>(u &gt; v) v = u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> X(<span class="built_in">int</span> a,<span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="built_in">if</span>(a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) return <span class="number">0</span>;</span><br><span class="line">  return dp[a][b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span>(<span class="built_in">int</span> rs,<span class="built_in">int</span> cs,<span class="built_in">int</span> re,<span class="built_in">int</span> ce) &#123;</span><br><span class="line">  <span class="built_in">int</span> a = X(rs-<span class="number">1</span>,cs-<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span> b = X(rs-<span class="number">1</span>,ce) - X(rs-<span class="number">1</span>,cs-<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span> c = X(re,cs-<span class="number">1</span>) - X(rs-<span class="number">1</span>,cs-<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">int</span> d = X(re,ce);</span><br><span class="line">  return d - a - b - c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>关于Behavior Question：<br><a href="http://www.1point3acres.com/bbs/thread-105717-1-1.html">Crack the Behavior Questions——关于Behavior Question的碎碎念</a></p>
]]></content>
      <categories>
        <category>job</category>
      </categories>
  </entry>
  <entry>
    <title>C++知识归纳整理（不断更新中）</title>
    <url>/2016/07/30/CPP-knowledge/</url>
    <content><![CDATA[<p>这篇文章写了好久，感觉还是没写完。接下来准备慢慢看书，实习，不断更新吧。</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong>分割线</strong></strong></strong></strong></strong></strong></strong></strong>********************</p>
<p>按照侯捷先生在《Effective C++》的观点，以及自己的一些理解，可以将互联网技术岗位关于C＋＋的知识点归纳为以下五个部分：</p>
<ul>
<li>C＋＋基础知识</li>
<li>面向过程的特性</li>
<li>面向对象的特性</li>
<li>泛型编程的特性</li>
<li>标准模板库和算法</li>
</ul>
<span id="more"></span> 

<p>这是我第一次在简书写文章，如果大家有什么意见的话，欢迎随时向我提出来。必须要说明的是，C＋＋知识繁杂磅礴，面试题中可被问到的很多，如果想要成功拿到心仪的offer，除了掌握C＋＋这个工具外，需要结合一些其它领域知识，如基础数据结构和基本的算法，网络编程，多线程编程，（Linux）Shell脚本（awk, sed），编译器使用（gcc/clang, makefile, automake/cmake等），数据库（SQL语言，数据库理论如存储引擎，索引实现，范式等）视频处理，设计模式，机器学习等知识，如果后续有时间，也会对相关知识进行一下归纳。<br>本文主要侧重于纪录分析C＋＋面试中的基础知识，主要包括：关键字使用，</p>
<h1 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static修饰的变量和函数存储在内存的静态文本区，与全局变量存储的位置一致。而静态文本区的字节默认都是0x00</p>
<ul>
<li>修饰局部变量<br>对局部变量添加static修饰符后，变量的存储区由栈改为静态文本区，它的生存周期得到了改变。</li>
<li>修饰全局变量<br>对全局变量添加static，生存周期不会改变，但是会影响作用域。普通全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。这一点，有人称作“隐藏”</li>
<li>修饰函数<br>static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.<br>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const关键字可以修饰变量，引用，函数，对象等：</p>
<p><strong>常变量</strong>：  const 类型说明符 变量名</p>
<p><strong>常引用</strong>：  const 类型说明符 &amp;引用名</p>
<p><strong>常对象</strong>：  类名 const 对象名</p>
<p><strong>常成员函数</strong>：  类名::fun(形参) const</p>
<p><strong>常数组</strong>：  类型说明符 const 数组名[大小]    </p>
<p><strong>常指针</strong>：  const 类型说明符* 指针名 ，类型说明符* const 指针名</p>
<p>在常变量（const 类型说明符 变量名）、常引用（const 类型说明符 &amp;引用名）、常对象（类名 const 对象名）、 常数组（类型说明符 const 数组名[大小]）， const” 与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符） 的位置可以互换。</p>
<p>需要注意的概念其实是<strong>“常量指针”</strong>和<strong>“指针常量”</strong>，也就是const修饰一个指针变量的时候产生的两种差异。我们知道，一个指针变量，使用的时候需要考虑该指针本身和被它所指的对象，看如下例子：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> *<span class="keyword">const</span> pc; //到<span class="built_in">char</span>的<span class="keyword">const</span>指针</span><br><span class="line"><span class="built_in">char</span> <span class="keyword">const</span> *pc1; //到<span class="keyword">const</span> <span class="built_in">char</span>的指针</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *pc2; //到<span class="keyword">const</span> <span class="built_in">char</span>的指针（后两个声明是等同的）</span><br></pre></td></tr></table></figure>

<p>从右向左读的记忆方式：</p>
<p>pc is a const pointer to char. 故pc不能指向别的字符串，但可以修改其指向的字符串的内容。pc是一个指向字符类型的常指针，pc的值不可变，但是pc值（也就是pc指向的地址）所代表的内存空间的内容是可以变的，所以pc是一个指针常量。<br>pc2 is a pointer to const char. 故<em>pc2的内容不可以改变，但pc2可以指向别的字符串。也就是说pc2是指向一个不可变内容空间（常量）的指针，也就是常量指针。pc2＋＋可行，但</em>pc2 = “hello world”不可行。当然，只是说不能通过pc2去修改那段内容，别的方式是可以的。</p>
<p>其实，const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。</p>
<p><strong>常量函数</strong> 常量函数是C++对常量的一个扩展，它很好的确保了C++中类的封装性。在C++中，为了防止类的数据成员被非法访问，将类的成员函数分成了两类，一类是常量成员函数（也被称为观察着）；另一类是非常量成员函数（也被成为变异者）。在一个函数的签名后面加上关键字const后该函数就成了常量函数。对于常量函数，最关键的不同是编译器不允许其修改类的数据成员。<br>当然，我们可以绕过编译器的错误去修改类的数据成员。但是C++也允许我们在数据成员的定义前面加上mutable，以允许该成员可以在常量函数中被修改。当存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。常量对象调用常量成员；非常量对象调用非常量的成员。</p>
<p>另外，需要注意C＋＋中用const定义了一个常量后，不会分配一个空间给它，而是将其写入符号表(symbol table),这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。只有当使用extern或者取地址操作的时候，才会分配空间，但是这不会影响到常量本身的值，因为用到a的时候，编译器根本不会去进行内存空间的读取。这就是c++的常量折叠（constant folding）,即将const常量放在符号表中，而并不给其分配内存。编译器直接进行替换优化。其值仍旧从符号表中读取，不管常量对应的存储空间中的值如何变化，都不会对其值产生影响。</p>
<h3 id="宏定义与const"><a href="#宏定义与const" class="headerlink" title="宏定义与const"></a>宏定义与const</h3><p>C++中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.</p>
<h2 id="四种类型转换"><a href="#四种类型转换" class="headerlink" title="四种类型转换"></a>四种类型转换</h2><ul>
<li><p><strong>static_cast</strong><br>static_cast 很像 C 语言中的旧式类型转换。它能进行基础类型之间的转换，也能将带有可被单参调用的构造函数或用户自定义类型转换操作符的类型转换，还能在存有继承关系的类之间进行转换（即可将基类转换为子类，也可将子类转换为基类），还能将 non-const对象转换为 const对象（注意：反之则不行，那是const_cast的职责。）。<br>注意：static_cast 转换时并不进行运行时安全检查，所以是非安全的，很容易出问题。因此 C++ 引入 dynamic_cast 来处理安全转型。</p>
</li>
<li><p><strong>dynamic_cast</strong><br>dynamic_cast 主要用来在继承体系中的安全向下转型。它能安全地将指向基类的指针转型为指向子类的指针或引用，并获知转型动作成功是否。如果转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时）。dynamic_cast 会动用运行时信息（RTTI）来进行类型安全检查，因此 dynamic_cast 存在一定的效率损失。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase &#123; &#125;;</span><br><span class="line"> CBase b;</span><br><span class="line"> CBase* pb;</span><br><span class="line"> CDerived d;</span><br><span class="line"> CDerived* pd;</span><br><span class="line"> pb = <span class="keyword">dynamic_cast</span>&lt;CBase*&gt;(&amp;d);     <span class="comment">// ok: derived-to-base</span></span><br><span class="line"> pd = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(&amp;b);  <span class="comment">// error: base-to-derived</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中最后一行 VS2010 会报如下错误：<br>error C2683: ‘dynamic_cast’ : ‘CBase’ is not a polymorphic typeIntelliSense: the operand of a runtime dynamic_cast must have a polymorphic class type<br>这是因为 dynamic_cast 只有在基类带有虚函数的情况下才允许将基类转换为子类。当然，允许转换也不代表可以转换成功。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">int</span> a;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    CBase * pba = <span class="keyword">new</span> CDerived;</span><br><span class="line">    CBase * pbb = <span class="keyword">new</span> CBase;</span><br><span class="line">    CDerived * pd1, * pd2;</span><br><span class="line">    pd1 = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(pba);</span><br><span class="line">    pd2 = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(pbb);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>结果是：上面代码中的 pd1 不为 null,而 pd2 为 null。<br>dynamic_cast 也可在 null 指针和指向其他类型的指针之间进行转换，也可以将指向类型的指针转换为 void 指针（基于此，我们可以获取一个对象的内存起始地址 *const void * rawAddress = dynamic_cast&lt;const void *&gt; (this);*）。</p>
<ul>
<li><strong>const_cast</strong><br>前面提到 const_cast 可去除对象的常量性（const），它还可以去除对象的易变性（volatile）。const_cast 的唯一职责就在于此，若将 const_cast 用于其他转型将会报错。</li>
<li><strong>reinterpret_cast</strong><br>reinterpret_cast 用来执行低级转型，如将执行一个 int 的指针强转为 int。其转换结果与编译平台息息相关，不具有可移植性，因此在一般的代码中不常见到它。reinterpret_cast 常用的一个用途是转换函数指针类型，即可以将一种类型的函数指针转换为另一种类型的函数指针，但这种转换可能会导致不正确的结果。总之，reinterpret_cast 只用于底层代码，一般我们都用不到它，如果你的代码中使用到这种转型，务必明白自己在干什么。</li>
</ul>
<p>总结来看，需要类型转换的时候，优先使用C＋＋的这种风格进行类型转换，基础类型转换的时候，使用static_cast, 子类与父类之间进行转换的时候，尤其是基类向子类转换的时候，使用dynamic_cast。其它情况，如转换为void指针，使用dynamic_cast, int型指针到int，以及函数指针之间的转换使用reinterpret_cast, const_cast只用于去除对象的常量性（const）和易变性（volatile）<br>抛开C＋＋为了兼容C而允许隐式类型转换（隐蔽，不安全，易引起非预期的函数调用，对象切割等等），我倾向于认为C＋＋是一种强类型（倾向于不允许隐式类型转换），静态类型（编译前已经知道数据类型）的语言。</p>
<h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><ul>
<li><p>重载（Overload）<br>同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。成员函数被重载的特征：<br>（1）相同的范围（在同一个类中）；<br>（2）函数名字相同；<br>（3）参数不同；<br>（4）virtual关键字可有可无。</p>
</li>
<li><p>重写（Override），也叫覆盖（Overwrite）<br>重写是指派生类函数重写基类函数，是C++的多态的表现，特征是：<br>（1）不同的范围（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有virtual关键字。</p>
</li>
</ul>
<p>说到底，这两个概念其实并没有太大的关联，重载是编译多态的一种实现，重写与需函数相关，用于实现动态绑定，属于编译时多态的实现。</p>
<p><strong>重写与隐藏的关系</strong><br>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：<br>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。<br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。如果有virtual关键字，函数同名，参数相同，就是“重写”了</p>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><p>从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。<br>而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。</p>
<p><strong>指针传递参数和引用传递参数的区别</strong><br>指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。<br>而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。<br>引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。</p>
<p>其实上面这两段话，我并没有看出传指针和传引用两个的区别在哪里？<br>“在栈上分配的对象通常就不能传递指针，因为函数返回之后栈上的对象会被析构”<br>另外<a href="http://www.cnblogs.com/xiaoka/articles/2331456.html">C++中传值，传指针和传引用区别</a>提到，传值与传引用本质上没有区别。以上，留作一个疑问吧</p>
<p>为了进一步加深大家对指针和引用的区别，下面我从编译的角度来阐述它们之间的区别：<br>程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。<br>最后，总结一下指针和引用的相同点和不同点：<br>★相同点：<br>●都是地址的概念；<br>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。<br>★不同点：<br>●指针是一个实体，而引用仅是个别名；<br>●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；<br>●引用没有const<br>  指针有const<br>  const的指针不可变；<br>●引用不能为空，指针可以为空；<br>●sizeof “引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；<br>●指针和引用的自增(++)<br>运算意义不一样；<br>●引用是类型安全的，而指针不是 (<br>引用比指针多了类型检查</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数，32位gcc 4.7上默认为8，32位VS2010上默认为8)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。<br>规则：</p>
<p>1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3、结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。</p>
<p>如果我们不想编译器自动为我们添加补齐位，可以将对齐系数设为1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="comment">// code...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<h2 id="四种智能指针"><a href="#四种智能指针" class="headerlink" title="四种智能指针"></a>四种智能指针</h2><ul>
<li>auto_ptr</li>
<li>unique_ptr</li>
<li>shared_ptr</li>
<li>weak_ptr(暂时不讨论，我也不知道为什么很多地方都不讨论，留一个疑问吧？)</li>
</ul>
<p>智能指针产生的原因在于解决常规指针可能产生的内存泄漏问题，<br><strong>将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间</strong></p>
<p>STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr（本文章暂不讨论）。模板auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，并提供了另外两种解决方案。然而，虽然auto_ptr被摒弃，但它已使用了好多年：同时，如果您的编译器不支持其他两种解决力案，auto_ptr将是唯一的选择。<br>使用auto_ptr仍然会存在，程序将试图删除同一个对象两次的问题。要避免这种问题，方法有多种：</p>
<ul>
<li>定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。</li>
<li>建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。</li>
<li>创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</li>
<li><em>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做</em>* unique_ptr比auto_ptr优秀的地方。<br>如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。<br>如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。</li>
</ul>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>规避可被单参调用的构造函数引起的隐式类型转换<br>所有的智能指针类都有一个explicit构造函数，以指针作为参数.因此不能自动将指针转换为智能指针对象，必须显式调用</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><pre><code>* new和delete
* malloc和free
</code></pre>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="built_in">CMyString</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="built_in">CMyString</span> &amp;str);</span><br><span class="line">	~<span class="built_in">CMyString</span>(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	<span class="keyword">char</span> * m_pData;</span><br></pre></td></tr></table></figure>

<h2 id="对象的大小"><a href="#对象的大小" class="headerlink" title="对象的大小"></a>对象的大小</h2><h2 id="继承（为什么要继承？单继承-多继承）"><a href="#继承（为什么要继承？单继承-多继承）" class="headerlink" title="继承（为什么要继承？单继承 多继承）"></a>继承（为什么要继承？单继承 多继承）</h2><h2 id="类成员变量初始化顺序"><a href="#类成员变量初始化顺序" class="headerlink" title="类成员变量初始化顺序"></a>类成员变量初始化顺序</h2><h2 id="析构函数与构造函数的执行顺序"><a href="#析构函数与构造函数的执行顺序" class="headerlink" title="析构函数与构造函数的执行顺序"></a>析构函数与构造函数的执行顺序</h2><p>常见对象－&gt;构造函数（缺省构造函数，有参构造函数，复制构造函数）<br>销毁对象－&gt;析构函数</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">CMyString::<span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">	m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么拷贝构造函数的参数一定是引用？避免拷贝构造函数不限制的递归复制下去。</p>
<h2 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMyString</span>&amp; <span class="built_in">CMyString</span>::operator = (<span class="keyword">const</span> <span class="built_in">CMyString</span> &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CMyString</span> strTemp(str);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> * pTemp = strTemp.m_pData;</span><br><span class="line">		strTemp.m_pData = m_pData;</span><br><span class="line">		m_pData = pTemp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我在想，这里的指针pTemp使用会不会有问题呢？</p>
<h2 id="虚函数与运行时多态"><a href="#虚函数与运行时多态" class="headerlink" title="虚函数与运行时多态"></a>虚函数与运行时多态</h2><ul>
<li>纯虚函数</li>
<li>虚函数列表</li>
</ul>
<h2 id="函数重载与编译时多态"><a href="#函数重载与编译时多态" class="headerlink" title="函数重载与编译时多态"></a>函数重载与编译时多态</h2><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>归纳面向对象三大特征：封装 继承 多态</p>
<h2 id="面向对象设计之SOLID五大原则？"><a href="#面向对象设计之SOLID五大原则？" class="headerlink" title="面向对象设计之SOLID五大原则？"></a>面向对象设计之SOLID五大原则？</h2><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><p>编写能够正确处理各种不同数据类型参数的代码，只要参数的数据类型满足特定的语法和语义需求。对于C＋＋而言，实现泛型编程的方式就是使用模板。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T</span>&gt;</span><br><span class="line"><span class="symbol">class</span> <span class="symbol">vector</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标准模板库（Standard-Template-Library）"><a href="#标准模板库（Standard-Template-Library）" class="headerlink" title="标准模板库（Standard Template Library）"></a>标准模板库（Standard Template Library）</h1><p>一群优秀的人写的一个优秀的函数库<br>##六大组件</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><h3 id="空间适配器"><a href="#空间适配器" class="headerlink" title="空间适配器"></a>空间适配器</h3><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html">static的作用</a><br><a href="http://www.cnblogs.com/kingln/articles/1129114.html">C++中指针和引用的区别</a><br><a href="http://www.cnblogs.com/luxiaoxun/archive/2012/08/09/2630751.html">C++的重载（overload）与重写（override）</a><br><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html">C/C++中const关键字详解</a><br><a href="http://www.cnblogs.com/lanxuezaipiao/p/4132096.html">C++智能指针简单剖析</a><br><a href="http://blog.csdn.net/tunsanty/article/details/4264738">拷贝构造函数的参数为什么必须使用引用类型</a></p>
]]></content>
      <categories>
        <category>job</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建综述</title>
    <url>/2016/07/12/overview-of-3D-reconstruction/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>对几何3D模型不断增长的需求：电影 游戏  虚拟环境等行业</li>
<li>VR&amp;AR的火爆</li>
<li>房地产 三维地图等领域的需求</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>中国古代建筑三维数字化保护</li>
<li>三维数字化城市</li>
<li>三维地图</li>
<li>VR&amp;&amp;AR游戏，电影等</li>
<li>医疗行业：三维心脏</li>
<li>教育行业等<span id="more"></span></li>
</ul>
<h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p>传统的三维重建主要是依靠昂贵的三维扫描设备，并且需要被扫描的目标保持一段时间的稳定。近年来，由于计算机硬件大规模计算能力的发展，特别是GPU和分布式计算的发展，实时高效的解决方案成为了可能。目前主流的方法主要分为以下两类：</p>
<ul>
<li>基于深度相机的三维重建</li>
<li>基于图像的三维重建</li>
</ul>
<h2 id="基于深度相机的三维重建"><a href="#基于深度相机的三维重建" class="headerlink" title="基于深度相机的三维重建"></a>基于深度相机的三维重建</h2><h3 id="深度相机"><a href="#深度相机" class="headerlink" title="深度相机"></a>深度相机</h3><p><strong>原理</strong> 主要有以下三种：</p>
<ul>
<li> 结构光，这个技术的代表产品是 Kinect 一代，它的传感器芯片用的是 PrimeSense 家的。PrimeSense 现在是苹果旗下的公司。</li>
<li>TOF，time-of-flight，代表产品是 Kinect 二代，由于微软对于 One 这个单词的热爱，它的官方名字是 Kinect One。</li>
<li>双目摄像头，代表产品是 Google Tango 以及 Leap Motion，前者配有四台摄像头，后者有两个</li>
</ul>
<p><strong>主要设备</strong>有Kinect, ASUS Xtion PRO等</p>
<h4 id="Kinect-1代与kinect-2代比较"><a href="#Kinect-1代与kinect-2代比较" class="headerlink" title="Kinect 1代与kinect 2代比较"></a>Kinect 1代与kinect 2代比较</h4><ul>
<li> Kinect v1对应Xbox 360, Kinect v2对应Xbox One</li>
<li> Kinect v1，彩色摄像头为640<em>480，深度摄像头为320</em>240，只能识别两个人的骨骼数据。</li>
<li> Kinect v2，彩色为1080P，深度摄像头为512*424，能识别六个人的骨骼，并且识别稳定精度高。有红外线感应,1代没有</li>
<li>功能（2代）: 通过人体<strong>骨骼追踪</strong>识别与跟踪运动人群，手势识别，面部追踪，目标测距；语音识别，声源定位</li>
</ul>
<p>目前基于深度相机进行三维重建的工作有很多，最经典的应该属微软剑桥研究院的<a href="https://www.microsoft.com/en-us/research/project/kinectfusion-project-page/">Kinect Fusion, 2011</a>, 微软有自己的<a href="https://www.microsoft.com/en-us/download/details.aspx?id=44561">SDK</a>, 注意一代和二代的原理有很大的不同，分别下载对应的SDK，目前对Kinect 2代的支持还不是特别好，它对硬件也有一定的要求（特别是USB3.0接口）：<br><img data-src="http://upload-images.jianshu.io/upload_images/2336041-a2217b442cf62e23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kinect SDK2.0 System Requirements.png"><br>当然，开源社区也有许多基于Kinect Fusion的开源实现，如由PCL团队开发的<a href="%5Bhttp://pointclouds.org/news/kinectfusion-open-source.html%5D(http://pointclouds.org/news/kinectfusion-open-source.html)">KinFu</a>,论文在<a href="https://homes.di.unimi.it/borghese/Teaching/IntelligentSystems/Documents/PirovanoMichele-VisualReconstructionReport.pdf">这里</a>。高通公司<a href="http://www.nullspace.at/">nullspace</a>的开源项目<a href="https://github.com/GerhardR/kfusion">kfusion</a>, 但是个人觉得目前效果最好的，应该要属<a href="https://github.com/mp3guy/Kintinuous">Kintinuous,Real-time large scale dense visual SLAM system</a>了。不过Kintinuous对kinect 2代的支持效果还不好，目前Kinect 1代和华硕的Xtion支持比较好（可能和他们都是PrimeSense的TOF原理有关吧）</p>
<h2 id="基于图像的三维重建（3D-Reconstruction-from-multiple-Images）"><a href="#基于图像的三维重建（3D-Reconstruction-from-multiple-Images）" class="headerlink" title="基于图像的三维重建（3D Reconstruction from multiple Images）"></a>基于图像的三维重建（3D Reconstruction from multiple Images）</h2><p><strong>关键点</strong>  实时要求/室内场景/大范围场景/点云精确度要求<br>由于基于深度相机（RGB-D）会受到红外距离的限制，如kinect支持的距离为0.5-5m，而且容易产生空洞（holes），所以比较适合室内场景，目前应用最多的是机器人Visual SLAM方面。但是从三维重建的实际应用角度来看，不够方便（主要是Kinect需要使用外接电源，而且需要连接电脑），目前工业界用的最多的方法应该是基于图像的三维几何重建了，其主要步骤包括<strong>局部特征匹配</strong>，<strong>Structure-from-Motion</strong>, <strong>Multi-View Stereo</strong>， <strong>Surface Reconstruction</strong>，<strong>Surface Texturing</strong> 等。<br>这种方法主要需要解决的问题是判断相机的姿态（位置和方向），这点和Visual SLAM比较类似。<br><img data-src="http://upload-images.jianshu.io/upload_images/2336041-fd295f78ef103cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="立体视觉的核心问题"><br>通过对照片特征的检测与匹配，得到相机的姿态，并计算出稀疏的场景三维点云。</p>
<p>目前比较好的算法主要有：</p>
<ul>
<li><strong>[VisualSFM]</strong>(<a href="http://ccwu.me/vsfm/">http://ccwu.me/vsfm/</a>)</li>
<li><a href="http://imagine.enpc.fr/~moulonp/openMVG/">OpenMVG</a></li>
<li>经典的<a href="http://www.cs.cornell.edu/~snavely/bundler/">Bundler</a></li>
<li><a href="http://www.gcc.tu-darmstadt.de/home/proj/mve/">MVE</a></li>
</ul>
<h1 id="目前已知的研究小组有："><a href="#目前已知的研究小组有：" class="headerlink" title="目前已知的研究小组有：#"></a>目前已知的研究小组有：#</h1><p><a href="http://idl.baidu.com/IDL-news-16.html">百度深度学习研究院</a><br><a href="http://vision.ia.ac.cn/zh/applications/index.html">中科院自动化所模式识别国重机器视觉课题组</a><br><a href="http://vision.middlebury.edu/mview/data/">美国明德学院（Middlebury college）</a><br><a href="http://www.cs.ust.hk/~quan/WebPami/pami.html">香港科技大学</a><br><a href="http://www.gcc.tu-darmstadt.de/home/proj/mve/">德国达姆施塔特工业大学MVE</a> <br><a href="%5Bhttps://github.com/openMVG/openMVG%5D(https://github.com/openMVG/openMVG)">OpenMVG</a></p>
<p><strong>相关人物</strong><br><a href="http://vis.uky.edu/~wangl/">王亮</a><br><a href="http://www.cad.zju.edu.cn/home/gfzhang/">章国峰</a></p>
<p>#参考文献#<br><a href="http://imagine.enpc.fr/demos/stereo/index.htm">3D Photography Gallery</a><br><a href="http://wedidstuff.heavyimage.com/index.php/2013/07/12/open-source-photogrammetry-workflow/">wedidstuff</a></p>
<p>基于图像的三维重建是我的研究重点，接下来将会对具体的技术，如特征提取算法，稀疏重建，立体匹配与重建，表面重建等分别说明。</p>
<p>如果上面有什么不对的地方，欢迎大家指教。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>3d-reconstruction</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Hexo和Github搭建静态博客</title>
    <url>/2016/06/25/how-to-build-a-blog-with-Hexo-and-Github/</url>
    <content><![CDATA[<p>   最近两天加周三的一个晚上，参照网上的博客搭建了属于自己的<a href="www.ac4fun.com">博客</a>，其实之前也对比过Jekyll，Octopress，Python实现的<a href="https://github.com/evilbinary/myblog">myblog</a>, 以及第三方博客，如Blogger，cnblogs，csdn等等，只能说各有千秋吧，还是希望能够有一个属于自己的空间。为避免忘记，也为了表示对社区的感谢，现在对部署过程进行一下纪录。主要包括：</p>
<ol>
<li> 基本Hexo的搭建</li>
<li> 主题的选择</li>
<li> 扩展功能的介绍</li>
</ol>
<span id="more"></span> 

<p>开始之前，先对系统环境进行一下说明，Hexo的部署需要Node.js的支持。我的网站部署在<a href="https://github.com/kingsleynuaa">Github</a>上，也有其他的开源空间（如Coding）可选，本文以Github为例，并假设你已经有了Github帐号。</p>
<h5 id="系统环境："><a href="#系统环境：" class="headerlink" title="系统环境："></a>系统环境：</h5><ul>
<li>OS X 10.11</li>
<li>Xcode 7.2</li>
<li><a href="https://nodejs.org/dist/v4.4.6/node-v4.4.6.pkg">Node.js v4.4.6 LTS</a> 直接官网下载，一路默认安装即可</li>
<li>Git 2.6.2(Windows用户请下载客户端)</li>
<li>SSH</li>
</ul>
<p>以上对于Mac用户来说，只需下载并安装Node.js即可。<br>在Terminal下进行测试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>
<p>显示版本号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ 2.15.5</span><br></pre></td></tr></table></figure>

<p>说明Node.js安装成功。</p>
<h5 id="SSH连接Github（可选）"><a href="#SSH连接Github（可选）" class="headerlink" title="SSH连接Github（可选）"></a>SSH连接Github（可选）</h5><p>本步骤可选，但是为了避免每次访问Github都需要输入密码，可以选择配置SSH Key，直接上步骤：</p>
<p>1.设置git参数：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.gmail</span> <span class="string">&quot;Your Email&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里的用户名和邮箱不一定是你的Github帐号的用户名和邮箱</p>
<p>2.生成SSH密钥（此处省略备份已有密钥的步骤）</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">&quot;kingsleynuaa@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>按三次回车即可，可以在~/.ssh目录下看到id_rsa（私钥，注意保密）和id_rsa.pub(公钥，可随意公开)两个文件</p>
<p>3.添加私钥到SSH，添加公钥到Github页面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ ssh-<span class="builtin-name">add</span> id_rsa</span><br></pre></td></tr></table></figure>
<p>在<a href="https://github.com/settings/keys">Github－setting－key</a>页面添加公钥，即id_rsa.pub里面的内容（可用vim打开查看并复制）</p>
<p>4.测试是否成功</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure>
<p>出现类似提示表示成功</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ Hi kingsleynuaa! You&#x27;ve successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br><span class="line">Connection <span class="keyword">to</span> github.com closed.</span><br></pre></td></tr></table></figure>
<p>此处推荐学习Git的好书<a href="http://git.oschina.net/progit/">Pro Git</a></p>
<p>OK, 现在开始用Github正式搭建Hexo.</p>
<h1 id="基本Hexo的搭建"><a href="#基本Hexo的搭建" class="headerlink" title="基本Hexo的搭建"></a>基本Hexo的搭建</h1><p>cd命令进入你要部署的文件目录，在Terminal下运行以下命令（去掉＃以后的说明文字）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> ~/                    <span class="comment">#进入用户目录</span></span><br><span class="line"><span class="variable">$</span> mkdir AC4Fun             <span class="comment">#建立文件夹，你的网站将部署在这里，名称可自行修改</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> AC4Fun					</span><br><span class="line"><span class="variable">$</span> npm install <span class="literal">-g</span> hexo      <span class="comment">#安装Hexo</span></span><br><span class="line"><span class="variable">$</span> hexo init</span><br><span class="line"><span class="variable">$</span> npm install</span><br></pre></td></tr></table></figure>

<p>至此，Hexo已经在本地部署完成。来试试写一篇文章吧</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后使用vi或者其他编辑器编辑文档并保存，生成网页文件，并开始服务器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>此时，即可在本地浏览器中打开页面<a href="http://localhost:4000/">http://localhost:4000</a> 查看啦，😄，第一次看到自己的网站的时候是不是还有一些激动呢？</p>
<p>OK，此时，网站文件仍然在本地，需要部署到Github才能被更多人看到呢</p>
<h3 id="安装Git部署插件"><a href="#安装Git部署插件" class="headerlink" title="安装Git部署插件"></a>安装Git部署插件</h3><p>首先在你的Github中新建一个Repository：<strong>用户名.github.io</strong> (如kingsleynuaa.github.io)，接下来安装插件：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-config-yml-文件"><a href="#配置-config-yml-文件" class="headerlink" title="配置 _config.yml 文件"></a>配置 _config.yml 文件</h3><p>在Hexo安装的目录，如 ~/AC4Fun/ 中找到 _config.yml 文件,打开并翻到最后，找到 deploy 字样，改成如下格式：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">deploy:</span> </span><br><span class="line"><span class="symbol">  type:</span> git </span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//github.com/用户名/用户名.github.io.git </span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure>

<p>需要注意的是：冒号后面有一个空格；使用github可以不用写branch那一行。接下来就可以将网站从本地部署到Github啦（你也可以选择修改以上标签部署到别的空间），输入命令:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>至此，如果没问题的话，打开你的github同名网站就可以看到属于你自己的个人博客啦～<br>如我的博客：kingsleynuaa.github.io </p>
<p>下面对上述经常需要使用的命令做一下简单总结：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo clean    <span class="comment">#清楚public文件夹，重新部署之前的步骤</span></span><br><span class="line"><span class="variable">$ </span>hexo generate <span class="comment">#修改配置或者提交新文章后都需要重新部署，主要是生命public文件夹里面的内容</span></span><br><span class="line"><span class="variable">$ </span>hexo deploy   <span class="comment">#将更新后的的博客上传至你的github空间</span></span><br></pre></td></tr></table></figure>

<p>现在你已经部署好了你的个人博客，并且学会了如何写一篇博客。</p>
<p>不过，这个网站仍然有很多不足，比如，界面你就不太喜欢，怎么办呢？我们可以更换主题啊～</p>
<h1 id="选择主题与优化"><a href="#选择主题与优化" class="headerlink" title="选择主题与优化"></a>选择主题与优化</h1><p>在开始选择合适的主题与优化之前我们先来了解一下Hexo博客的结构，并做一下简单的说明。<br>Hexo的结构如下：<br><img data-src="http://o9bsgo1ar.bkt.clouddn.com/tree_main.png" alt="treeMain"></p>
<ul>
<li>.deploy_git：执行hexo deploy命令部署到GitHub上的内容目录</li>
<li>public：执行hexo generate命令，输出的静态网页内容目录</li>
<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li>
<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>
<li>node_modules安装的一些Hexo工具，每个都会在这里建立一个文件夹，并以Hexo－开头</li>
<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、 favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。<ul>
<li>_drafts：草稿文章</li>
<li>_posts：发布文章</li>
</ul>
</li>
<li>themes：主题文件目录</li>
<li>_config.yml：全局配置文件，大多数的设置都在这里。详情可以查看源文件注释。</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
</ul>
<p>下面开始修改主题，一般都去<a href="https://github.com/hexojs/hexo/wiki/Themes">官网</a>选择自己喜欢的主题，clone到自己的theme文件夹下并修改全局配置文件下的theme标签，Hexo默认为landscape。每个主题的作者都会比较详细的介绍自己主题的配置说明。这里就不详述了。</p>
<p>我选择的是<a href="http://gengbiao.me/">coney</a>,可以点击<a href="http://www.ac4fun.com/">AC4Fun</a>查看。一般觉得比较好的还有<a href="https://github.com/A-limon/pacman">Pacman</a>等等</p>
<h2 id="自定义域名（可选）"><a href="#自定义域名（可选）" class="headerlink" title="自定义域名（可选）"></a>自定义域名（可选）</h2><p>首先需要购买域名，可选网站有GoDaddy（听说有优惠码，会便宜很多），我选择的是阿里云的服务，直接购买了三年的域名，对比价格发现相差不多。<br>你需要在source文件夹下新建一个文件名为CNAME，文件内容为你的自定义域名（如<a href="http://www.ac4fun.com）,然后在Aliyun后台添加域名解析到你的github地址即可。[参考](http://jingyan.baidu.com/article/3c343ff70fb6e60d3779632f.html)">www.ac4fun.com）,然后在Aliyun后台添加域名解析到你的github地址即可。[参考](http://jingyan.baidu.com/article/3c343ff70fb6e60d3779632f.html)</a></p>
<h1 id="扩展功能的介绍"><a href="#扩展功能的介绍" class="headerlink" title="扩展功能的介绍"></a>扩展功能的介绍</h1><h3 id="评论框"><a href="#评论框" class="headerlink" title="评论框"></a>评论框</h3><p>Hexo默认采用的是Disqus，我觉得挺好的，直接在全局配置文件下修改disqus标签enable为true即可。<br>当然你可以可以配置<a href="http://duoshuo.com/">duoshuo</a>,需要注册多说的帐号，并修改<em>你的主题</em>下_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname，并修改你的主题下文件夹中的layout_partial\comment.ejs</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;% if (config.disqus_shortname &amp;&amp; page.comments)&#123; %&gt;</span></span><br><span class="line"><span class="section">&lt;section id=<span class="string">&quot;comment&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">#你的通用代码</span></span><br><span class="line"><span class="section">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>通用代码见多说官网，注册登录后可以找到。</p>
<h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><p>在hexo\source\下手工新建about和index.md，并在主题配置文件下修改memu下的标签。</p>
<h3 id="页面统计"><a href="#页面统计" class="headerlink" title="页面统计"></a>页面统计</h3><ol>
<li>注册并登录百度统计，获取你的统计代码。</li>
<li>在主题配置文件下新建</li>
</ol>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_tongji:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在\layout_partial\目录下新建baidu_tongji.ejs并添加如下代码：</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;% if (theme.baidu_tongji)&#123; %&gt;</span></span><br><span class="line"><span class="section">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">#你的百度统计代码</span></span><br><span class="line"><span class="section">&lt;/script&gt;</span></span><br><span class="line"><span class="section">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编辑文件layout_partial\head.ejs，在『/head』之前增加：</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&lt;<span class="meta">%</span>- partial<span class="comment">(&#x27;baidu_tongji&#x27;)</span> <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>本部分来自教程［3］，当然使用Baidu站内搜索功能也可以的。</p>
<p>主要步骤如下：</p>
<ol>
<li><a href="https://swiftype.com/">Swiftype官网</a>注册帐号，按照提示输入你的<a href="www.ac4fun.com">自定义域名</a>，起名字（最好和你的域名一致）</li>
<li>安装。按照提示一步步往下即可，一路Next，注意“Results container”部分如果不喜欢弹出模式可以选择否，然后点击<strong>Active</strong>激活</li>
<li>在主题配置文件_config_yml中添加标签：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">swift_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在Hexo主目录下新建search文件夹并新建index.md文件，在index.md写入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">layout: search</span><br><span class="line">title: search</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p>然后在主题目录下的layout_partial目录下，先打开header.ejs，<br>在</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/2336041-b2669cff72e2b56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="header.ejs 插入点之前"></p>
<p>与</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/2336041-4fb60070444cb2d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="header.ejs 插入点之后"></p>
<p>之间添加</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;% &#125;<span class="keyword">else</span> <span class="keyword">if</span>	(theme.swift_search&amp;&amp;theme.swift_search.enable)&#123; %&gt;</span><br><span class="line">						&lt;<span class="keyword">form</span> <span class="keyword">class</span>=<span class="string">&quot;search&quot;</span> action=<span class="string">&quot;&lt;%- config.root %&gt;search/index.html&quot;</span> method=<span class="string">&quot;get&quot;</span> accept-charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">						&lt;<span class="keyword">label</span>&gt;<span class="keyword">Search</span>&lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">						&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;search&quot;</span> </span><br><span class="line"><span class="keyword">class</span>=<span class="string">&quot;st-default-search-input&quot;</span> maxlength=<span class="string">&quot;20&quot;</span> placeholder=<span class="string">&quot;Search&quot;</span> /&gt;</span><br><span class="line">						&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="http://upload-images.jianshu.io/upload_images/2336041-c0442a1b58c77e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="待插入代码示例"></p>
<p>有一定程序设计经验的人应该很容易看懂，就是在if－else中加入一种情况</p>
<p>然后将search.js文件清空，并替换如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;% if(theme.swiftype_search.enable) &#123; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;page&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;st-results-container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;st-search-container&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;width:80%&quot;</span>&gt;</span> Loading now...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-class">.st-result-text</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#fafafa</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">  <span class="attribute">border-left</span>: <span class="number">0.5em</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">transition</span>: border-left <span class="number">0.45s</span>;</span></span><br><span class="line"><span class="css">  -moz-<span class="attribute">transition</span>: border-left <span class="number">0.45s</span>;</span></span><br><span class="line"><span class="css">  -o-<span class="attribute">transition</span>: border-left <span class="number">0.45s</span>;</span></span><br><span class="line"><span class="css">  -ms-<span class="attribute">transition</span>: border-left <span class="number">0.45s</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">transition</span>: border-left <span class="number">0.45s</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">0.5em</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.st-result-text</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">1em</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.st-result-text</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">border-left</span>: <span class="number">0.5em</span> solid <span class="number">#ea6753</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.st-result-text</span> <span class="selector-tag">h3</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2ca6cb</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-size</span>: <span class="number">22px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.st-snippet</span> <span class="selector-tag">em</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#ea6753</span>;</span></span><br><span class="line"><span class="css">&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意下面到&lt;/script&gt;结束的代码块要替换成自己上面保存的Install Code代码--!&gt;</span></span><br><span class="line"><span class="comment">&lt;script type=&quot;text/javascript&quot;&gt;</span></span><br><span class="line"><span class="comment">  (function(w,d,t,u,n,s,e)&#123;w[&#x27;SwiftypeObject&#x27;]=n;w[n]=w[n]||function()&#123;</span></span><br><span class="line"><span class="comment">  (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);</span></span><br><span class="line"><span class="comment">  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);</span></span><br><span class="line"><span class="comment">  &#125;)(window,document,&#x27;script&#x27;,&#x27;//s.swiftypecdn.com/install/v2/st.js&#x27;,&#x27;_st&#x27;);  </span></span><br><span class="line"><span class="comment">  _st(&#x27;install&#x27;,&#x27;zpDUHTyGUc4YVxxVWn9w&#x27;,&#x27;2.0.0&#x27;);</span></span><br><span class="line"><span class="comment">&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后打开footer.ejs（其实header也行，随便你），在最后一个标签之前添加一开始拷贝的那段js代码.</p>
<p>然后重新部署即可。<a href="http://www.ac4fun.com/search/index.html#stq=&stp=1">效果</a></p>
<p>扩展功能介绍就到这里，其他关于如何建立更漂亮的博客，分享，图床，微博秀等我觉得没什么必要或者暂时没有时间，就没有弄了，建议感兴趣的自行摸索，有问题欢迎沟通</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>   其实这是我第一次用markdown写这么长的文章，从下午到晚上九点，整整写了快6个小时。不得不说，自己知道了，然后总结出来，还是很耗费时间的，但是我相信这个是十分有意义的，而且也能够方便自己以后查阅。<br>   另外，以前总觉得前端的工作比较烦，但是现在感觉能做好做美观一个页面还是挺有意义，也挺不容易的。昨晚这个博客，希望以后能够好好写博客，做好自己的知识管理。定期和自己来一次约会。如果有人能够看到这里，我真是非常感动的呢～哈哈，也希望通过博客能够找到志同道合的人。如果博客中有什么问题，也希望大家能够告诉我，我会及时修正的。如果有什么可以改进的地方，只要能方便大家理解的，也希望大家能够及时提出来，谢谢啦～<br>   好吧，这是博客开通以来，第一篇博客，希望能够一直坚持下去，争取做到一周一篇。</p>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><ol>
<li><a href="http://blog.csdn.net/xsckernel/article/details/8563993">git 使用（ssh key创建和github使用</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool">Hexo你的博客</a></li>
<li><a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html">利用swiftype为hexo添加站内搜索v2.0</a></li>
</ol>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要写博客</title>
    <url>/2016/06/22/why-write-blog/</url>
    <content><![CDATA[<p>这个问题我思考了很久，却仍然没有一个能够让自己很满意的答案。不得不承认，建立技术博客的初衷是因为找工作，哈哈，说起来还是有点功利的性质的。但是凡事总是一半一半吧，想了想，坚持写博客的好处可能会有下面几点吧。</p>
<span id="more"></span> 

<h1 id="锻炼表达能力"><a href="#锻炼表达能力" class="headerlink" title="锻炼表达能力"></a>锻炼表达能力</h1><p>做为一个程序员，或者说六年多的工科学习生涯，让自己的逻辑思维和理性思维得到了很大的锻炼，但是因为日常需要比较正式的口头表达的机会实在是少之又少，整天埋头做题，写代码，看论文，就算是交流，除了每周一次的组会，很少有那种需要正式完整表达的时候。发展到后面，会常常觉得自己的口语表达能力急剧下退。以前人们常说，能够很好的表达的人，一定是逻辑思维非常清楚的人，其实并不是。这句话的前提是建立在这个人能够有一个比较好的表达能力的基础之上的。<br>所有因为自己“思维发散”或“想法跳脱”而觉得无法被周围的人理解的人，其实都应该意识到，这是自己的语言表达能力出现了问题。</p>
<p>表达的基本要求是口齿清晰，逻辑清楚，表达流畅。只有坚持练习表达，练习怎么样把你知道，把你懂的事情，把你的观点解释给别人听，才能把同理心植入对方心底。其实所谓无法用语言来形容的，你自己才有的“某种独特的感悟或心境”基本不存在，正如“太阳底下没有新鲜事”，你所遇到的，你所感悟的，在时空的长河里，基本上都有与你经历相似 感悟类同的人等着你。</p>
<h1 id="纪录生活和技术成长"><a href="#纪录生活和技术成长" class="headerlink" title="纪录生活和技术成长"></a>纪录生活和技术成长</h1><h1 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h1><p>总结  升华 </p>
<h1 id="寻找志同道合的人"><a href="#寻找志同道合的人" class="headerlink" title="寻找志同道合的人"></a>寻找志同道合的人</h1>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
